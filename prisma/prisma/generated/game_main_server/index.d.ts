
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Bankbindlist
 * 
 */
export type Bankbindlist = {
  cardId: number
  userId: number
  account: string
  name: string
  bankType: string
}

/**
 * Model Bankname
 * 
 */
export type Bankname = {
  typeId: number
  bankName: string
}

/**
 * Model Chatlog
 * 
 */
export type Chatlog = {
  id: number
  userId: number
  toUserId: number
  nickname: string
  msg: string
  isSendEnd: number
  addDate: Date
}

/**
 * Model Diamond_changelog
 * 
 */
export type Diamond_changelog = {
  id: number
  userid: number
  diamond_before: number
  diamond_change: number
  diamond_current: number
  change_type: number
  change_time: Date
  isOnline: number
}

/**
 * Model Dongshanzaiqi
 * 
 */
export type Dongshanzaiqi = {
  userId: number
  dcount: number
  dtime: Date
}

/**
 * Model Game_login_history
 * 
 */
export type Game_login_history = {
  id: number
  userId: number
  gameId: number
  serverId: string
  encoin: number
  login_score: number
  logout_score: number
  loginDate: Date
  logoutDate: Date
}

/**
 * Model Game_onlinenum
 * 
 */
export type Game_onlinenum = {
  id: number
  gid: number
  gport: string
  num: number
  createtime: string
}

/**
 * Model Lineout
 * 
 */
export type Lineout = {
  userId: number
}

/**
 * Model Login_history
 * 
 */
export type Login_history = {
  id: number
  userId: number
  loginType: string
  loginToken: string
  passwordToken: number
  score: number
  loginDate: Date
  loginIp: string
}

/**
 * Model Logintemp
 * 
 */
export type Logintemp = {
  id: number
  loginid: number
  logincode: string
  loginDate: Date
}

/**
 * Model Logout_history
 * 
 */
export type Logout_history = {
  id: number
  userId: number
  logoutType: number
  score: number
  logoutDate: Date
  logoutIp: string
}

/**
 * Model Mark
 * 
 */
export type Mark = {
  id: number
  userId: number
  useCoin: number
  winCoin: number
  tax: number
  gameId: number
  serverId: number
  balanceTime: Date
  mark: number
}

/**
 * Model Msg
 * 
 */
export type Msg = {
  msgId: number
  userId: number
  winPropId: number
  winPropCount: number
  winScore: number
  matchlogId: number
  isGetPrize: number
  type: number
  AddDate: Date
  sendCoinUserId: number
  nickName: string
}

/**
 * Model Newuseraccounts
 * 
 */
export type Newuseraccounts = {
  Id: number
  Account: string
  Password: string
  nickname: string
  score: number
  AddDate: Date
  LoginCount: number
  p: string
  diamond: number
  giftTicket: number
  phoneNo: string
  email: string
  sex: number
  city: string
  province: string
  country: string
  headimgurl: string
  language: string
  Robot: number
  ChannelType: string
  official: number
  gametoken: string
  qdid: number
  housecard: number
  totalRecharge: Prisma.Decimal
  loginip: string
  iscanlogin: number
  diansha_score: number
  diansha_gameids: string
  is_vip: number
  g4_uid: string
  account_using: number
  bankPwd: string
  bankScore: number
}

/**
 * Model Pcdandan
 * 
 */
export type Pcdandan = {
  userId: number
  pcdandanId: string
  Devid: string
}

/**
 * Model Prop_changelog
 * 
 */
export type Prop_changelog = {
  id: number
  userid: number
  propid: number
  change_before: number
  change_count: number
  change_after: number
  insertTime: Date
  gameid: number
  codeid: number
}

/**
 * Model Prop_item
 * 
 */
export type Prop_item = {
  id: number
  userid: number
  propid: number
  propcount: number
}

/**
 * Model Recharge
 * 
 */
export type Recharge = {
  id: number
  userId: number
  Account: string
  total_fee: number
  out_trade_no: string
  goodsid: number
  state: number
  createTime: Date
}

/**
 * Model Recharge_first
 * 
 */
export type Recharge_first = {
  userId: number
  FIRST: number
  anyFirst: number
  goods1: number
  goods2: number
  goods3: number
  goods4: number
  goods5: number
  daytime: Date
}

/**
 * Model Rechargelog
 * 
 */
export type Rechargelog = {
  id: number
  adminid: number
  userid: number
  createtime: string
  czfee: number
  oldfee: number
  newfee: number
  type: number
}

/**
 * Model Returnscorelog
 * 
 */
export type Returnscorelog = {
  id: number
  msg: string
  ret: string
  createtime: string
}

/**
 * Model Score_changelog
 * 
 */
export type Score_changelog = {
  id: number
  userid: string
  ret: string
  createtime: string
}

/**
 * Model Scoreout
 * 
 */
export type Scoreout = {
  id: number
  userId: number
  score: number
  coin: number
  tax: number
  addDate: Date
  state: string
  outDate: Date
  cardType: number
  cardId: number
  out_trade_no: string
  zfb_account: string
  zfb_name: string
  remark: string
}

/**
 * Model Sendcoinlog
 * 
 */
export type Sendcoinlog = {
  id: number
  userid: number
  getcoinuserid: number
  sendcoin: number
  addtime: Date
}

/**
 * Model Server_log
 * 
 */
export type Server_log = {
  id: number
  txt: string
  status: number
  createtime: string
  updatetime: string
}

/**
 * Model Tempadddiamond
 * 
 */
export type Tempadddiamond = {
  userId: number
  score: number
  change_type: number
}

/**
 * Model Tempaddscore
 * 
 */
export type Tempaddscore = {
  userId: number
  score: number
  change_type: number
}

/**
 * Model Ticket_changelog
 * 
 */
export type Ticket_changelog = {
  userid: number
  score_before: number
  score_change: number
  score_current: number
  change_type: number
  change_time: Date
  isOnline: number
}

/**
 * Model User_admin
 * 
 */
export type User_admin = {
  id: number
  user: string
  password: string
  ip: string
  time: string
  userflag: number
}

/**
 * Model Userinfo
 * 
 */
export type Userinfo = {
  userId: number
  Devid: number
  firstexchange: number
  zhifubao: string
  zhifubaoName: string
}

/**
 * Model Userinfo_imp
 * 
 */
export type Userinfo_imp = {
  userId: number
  score: number
  diamond: number
  giftTicket: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bankbindlists
 * const bankbindlists = await prisma.bankbindlist.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bankbindlists
   * const bankbindlists = await prisma.bankbindlist.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.bankbindlist`: Exposes CRUD operations for the **Bankbindlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bankbindlists
    * const bankbindlists = await prisma.bankbindlist.findMany()
    * ```
    */
  get bankbindlist(): Prisma.BankbindlistDelegate<GlobalReject>;

  /**
   * `prisma.bankname`: Exposes CRUD operations for the **Bankname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banknames
    * const banknames = await prisma.bankname.findMany()
    * ```
    */
  get bankname(): Prisma.BanknameDelegate<GlobalReject>;

  /**
   * `prisma.chatlog`: Exposes CRUD operations for the **Chatlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatlogs
    * const chatlogs = await prisma.chatlog.findMany()
    * ```
    */
  get chatlog(): Prisma.ChatlogDelegate<GlobalReject>;

  /**
   * `prisma.diamond_changelog`: Exposes CRUD operations for the **Diamond_changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diamond_changelogs
    * const diamond_changelogs = await prisma.diamond_changelog.findMany()
    * ```
    */
  get diamond_changelog(): Prisma.Diamond_changelogDelegate<GlobalReject>;

  /**
   * `prisma.dongshanzaiqi`: Exposes CRUD operations for the **Dongshanzaiqi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dongshanzaiqis
    * const dongshanzaiqis = await prisma.dongshanzaiqi.findMany()
    * ```
    */
  get dongshanzaiqi(): Prisma.DongshanzaiqiDelegate<GlobalReject>;

  /**
   * `prisma.game_login_history`: Exposes CRUD operations for the **Game_login_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_login_histories
    * const game_login_histories = await prisma.game_login_history.findMany()
    * ```
    */
  get game_login_history(): Prisma.Game_login_historyDelegate<GlobalReject>;

  /**
   * `prisma.game_onlinenum`: Exposes CRUD operations for the **Game_onlinenum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_onlinenums
    * const game_onlinenums = await prisma.game_onlinenum.findMany()
    * ```
    */
  get game_onlinenum(): Prisma.Game_onlinenumDelegate<GlobalReject>;

  /**
   * `prisma.lineout`: Exposes CRUD operations for the **Lineout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lineouts
    * const lineouts = await prisma.lineout.findMany()
    * ```
    */
  get lineout(): Prisma.LineoutDelegate<GlobalReject>;

  /**
   * `prisma.login_history`: Exposes CRUD operations for the **Login_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Login_histories
    * const login_histories = await prisma.login_history.findMany()
    * ```
    */
  get login_history(): Prisma.Login_historyDelegate<GlobalReject>;

  /**
   * `prisma.logintemp`: Exposes CRUD operations for the **Logintemp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logintemps
    * const logintemps = await prisma.logintemp.findMany()
    * ```
    */
  get logintemp(): Prisma.LogintempDelegate<GlobalReject>;

  /**
   * `prisma.logout_history`: Exposes CRUD operations for the **Logout_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logout_histories
    * const logout_histories = await prisma.logout_history.findMany()
    * ```
    */
  get logout_history(): Prisma.Logout_historyDelegate<GlobalReject>;

  /**
   * `prisma.mark`: Exposes CRUD operations for the **Mark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marks
    * const marks = await prisma.mark.findMany()
    * ```
    */
  get mark(): Prisma.MarkDelegate<GlobalReject>;

  /**
   * `prisma.msg`: Exposes CRUD operations for the **Msg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Msgs
    * const msgs = await prisma.msg.findMany()
    * ```
    */
  get msg(): Prisma.MsgDelegate<GlobalReject>;

  /**
   * `prisma.newuseraccounts`: Exposes CRUD operations for the **Newuseraccounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newuseraccounts
    * const newuseraccounts = await prisma.newuseraccounts.findMany()
    * ```
    */
  get newuseraccounts(): Prisma.NewuseraccountsDelegate<GlobalReject>;

  /**
   * `prisma.pcdandan`: Exposes CRUD operations for the **Pcdandan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pcdandans
    * const pcdandans = await prisma.pcdandan.findMany()
    * ```
    */
  get pcdandan(): Prisma.PcdandanDelegate<GlobalReject>;

  /**
   * `prisma.prop_changelog`: Exposes CRUD operations for the **Prop_changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prop_changelogs
    * const prop_changelogs = await prisma.prop_changelog.findMany()
    * ```
    */
  get prop_changelog(): Prisma.Prop_changelogDelegate<GlobalReject>;

  /**
   * `prisma.prop_item`: Exposes CRUD operations for the **Prop_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prop_items
    * const prop_items = await prisma.prop_item.findMany()
    * ```
    */
  get prop_item(): Prisma.Prop_itemDelegate<GlobalReject>;

  /**
   * `prisma.recharge`: Exposes CRUD operations for the **Recharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recharges
    * const recharges = await prisma.recharge.findMany()
    * ```
    */
  get recharge(): Prisma.RechargeDelegate<GlobalReject>;

  /**
   * `prisma.recharge_first`: Exposes CRUD operations for the **Recharge_first** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recharge_firsts
    * const recharge_firsts = await prisma.recharge_first.findMany()
    * ```
    */
  get recharge_first(): Prisma.Recharge_firstDelegate<GlobalReject>;

  /**
   * `prisma.rechargelog`: Exposes CRUD operations for the **Rechargelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rechargelogs
    * const rechargelogs = await prisma.rechargelog.findMany()
    * ```
    */
  get rechargelog(): Prisma.RechargelogDelegate<GlobalReject>;

  /**
   * `prisma.returnscorelog`: Exposes CRUD operations for the **Returnscorelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Returnscorelogs
    * const returnscorelogs = await prisma.returnscorelog.findMany()
    * ```
    */
  get returnscorelog(): Prisma.ReturnscorelogDelegate<GlobalReject>;

  /**
   * `prisma.score_changelog`: Exposes CRUD operations for the **Score_changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Score_changelogs
    * const score_changelogs = await prisma.score_changelog.findMany()
    * ```
    */
  get score_changelog(): Prisma.Score_changelogDelegate<GlobalReject>;

  /**
   * `prisma.scoreout`: Exposes CRUD operations for the **Scoreout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scoreouts
    * const scoreouts = await prisma.scoreout.findMany()
    * ```
    */
  get scoreout(): Prisma.ScoreoutDelegate<GlobalReject>;

  /**
   * `prisma.sendcoinlog`: Exposes CRUD operations for the **Sendcoinlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sendcoinlogs
    * const sendcoinlogs = await prisma.sendcoinlog.findMany()
    * ```
    */
  get sendcoinlog(): Prisma.SendcoinlogDelegate<GlobalReject>;

  /**
   * `prisma.server_log`: Exposes CRUD operations for the **Server_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Server_logs
    * const server_logs = await prisma.server_log.findMany()
    * ```
    */
  get server_log(): Prisma.Server_logDelegate<GlobalReject>;

  /**
   * `prisma.tempadddiamond`: Exposes CRUD operations for the **Tempadddiamond** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tempadddiamonds
    * const tempadddiamonds = await prisma.tempadddiamond.findMany()
    * ```
    */
  get tempadddiamond(): Prisma.TempadddiamondDelegate<GlobalReject>;

  /**
   * `prisma.tempaddscore`: Exposes CRUD operations for the **Tempaddscore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tempaddscores
    * const tempaddscores = await prisma.tempaddscore.findMany()
    * ```
    */
  get tempaddscore(): Prisma.TempaddscoreDelegate<GlobalReject>;

  /**
   * `prisma.ticket_changelog`: Exposes CRUD operations for the **Ticket_changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ticket_changelogs
    * const ticket_changelogs = await prisma.ticket_changelog.findMany()
    * ```
    */
  get ticket_changelog(): Prisma.Ticket_changelogDelegate<GlobalReject>;

  /**
   * `prisma.user_admin`: Exposes CRUD operations for the **User_admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_admins
    * const user_admins = await prisma.user_admin.findMany()
    * ```
    */
  get user_admin(): Prisma.User_adminDelegate<GlobalReject>;

  /**
   * `prisma.userinfo`: Exposes CRUD operations for the **Userinfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userinfos
    * const userinfos = await prisma.userinfo.findMany()
    * ```
    */
  get userinfo(): Prisma.UserinfoDelegate<GlobalReject>;

  /**
   * `prisma.userinfo_imp`: Exposes CRUD operations for the **Userinfo_imp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userinfo_imps
    * const userinfo_imps = await prisma.userinfo_imp.findMany()
    * ```
    */
  get userinfo_imp(): Prisma.Userinfo_impDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Bankbindlist: 'Bankbindlist',
    Bankname: 'Bankname',
    Chatlog: 'Chatlog',
    Diamond_changelog: 'Diamond_changelog',
    Dongshanzaiqi: 'Dongshanzaiqi',
    Game_login_history: 'Game_login_history',
    Game_onlinenum: 'Game_onlinenum',
    Lineout: 'Lineout',
    Login_history: 'Login_history',
    Logintemp: 'Logintemp',
    Logout_history: 'Logout_history',
    Mark: 'Mark',
    Msg: 'Msg',
    Newuseraccounts: 'Newuseraccounts',
    Pcdandan: 'Pcdandan',
    Prop_changelog: 'Prop_changelog',
    Prop_item: 'Prop_item',
    Recharge: 'Recharge',
    Recharge_first: 'Recharge_first',
    Rechargelog: 'Rechargelog',
    Returnscorelog: 'Returnscorelog',
    Score_changelog: 'Score_changelog',
    Scoreout: 'Scoreout',
    Sendcoinlog: 'Sendcoinlog',
    Server_log: 'Server_log',
    Tempadddiamond: 'Tempadddiamond',
    Tempaddscore: 'Tempaddscore',
    Ticket_changelog: 'Ticket_changelog',
    User_admin: 'User_admin',
    Userinfo: 'Userinfo',
    Userinfo_imp: 'Userinfo_imp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Bankbindlist
   */


  export type AggregateBankbindlist = {
    _count: BankbindlistCountAggregateOutputType | null
    _avg: BankbindlistAvgAggregateOutputType | null
    _sum: BankbindlistSumAggregateOutputType | null
    _min: BankbindlistMinAggregateOutputType | null
    _max: BankbindlistMaxAggregateOutputType | null
  }

  export type BankbindlistAvgAggregateOutputType = {
    cardId: number | null
    userId: number | null
  }

  export type BankbindlistSumAggregateOutputType = {
    cardId: number | null
    userId: number | null
  }

  export type BankbindlistMinAggregateOutputType = {
    cardId: number | null
    userId: number | null
    account: string | null
    name: string | null
    bankType: string | null
  }

  export type BankbindlistMaxAggregateOutputType = {
    cardId: number | null
    userId: number | null
    account: string | null
    name: string | null
    bankType: string | null
  }

  export type BankbindlistCountAggregateOutputType = {
    cardId: number
    userId: number
    account: number
    name: number
    bankType: number
    _all: number
  }


  export type BankbindlistAvgAggregateInputType = {
    cardId?: true
    userId?: true
  }

  export type BankbindlistSumAggregateInputType = {
    cardId?: true
    userId?: true
  }

  export type BankbindlistMinAggregateInputType = {
    cardId?: true
    userId?: true
    account?: true
    name?: true
    bankType?: true
  }

  export type BankbindlistMaxAggregateInputType = {
    cardId?: true
    userId?: true
    account?: true
    name?: true
    bankType?: true
  }

  export type BankbindlistCountAggregateInputType = {
    cardId?: true
    userId?: true
    account?: true
    name?: true
    bankType?: true
    _all?: true
  }

  export type BankbindlistAggregateArgs = {
    /**
     * Filter which Bankbindlist to aggregate.
     */
    where?: BankbindlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bankbindlists to fetch.
     */
    orderBy?: Enumerable<BankbindlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankbindlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bankbindlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bankbindlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bankbindlists
    **/
    _count?: true | BankbindlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankbindlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankbindlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankbindlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankbindlistMaxAggregateInputType
  }

  export type GetBankbindlistAggregateType<T extends BankbindlistAggregateArgs> = {
        [P in keyof T & keyof AggregateBankbindlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankbindlist[P]>
      : GetScalarType<T[P], AggregateBankbindlist[P]>
  }




  export type BankbindlistGroupByArgs = {
    where?: BankbindlistWhereInput
    orderBy?: Enumerable<BankbindlistOrderByWithAggregationInput>
    by: BankbindlistScalarFieldEnum[]
    having?: BankbindlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankbindlistCountAggregateInputType | true
    _avg?: BankbindlistAvgAggregateInputType
    _sum?: BankbindlistSumAggregateInputType
    _min?: BankbindlistMinAggregateInputType
    _max?: BankbindlistMaxAggregateInputType
  }


  export type BankbindlistGroupByOutputType = {
    cardId: number
    userId: number
    account: string
    name: string
    bankType: string
    _count: BankbindlistCountAggregateOutputType | null
    _avg: BankbindlistAvgAggregateOutputType | null
    _sum: BankbindlistSumAggregateOutputType | null
    _min: BankbindlistMinAggregateOutputType | null
    _max: BankbindlistMaxAggregateOutputType | null
  }

  type GetBankbindlistGroupByPayload<T extends BankbindlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BankbindlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankbindlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankbindlistGroupByOutputType[P]>
            : GetScalarType<T[P], BankbindlistGroupByOutputType[P]>
        }
      >
    >


  export type BankbindlistSelect = {
    cardId?: boolean
    userId?: boolean
    account?: boolean
    name?: boolean
    bankType?: boolean
  }


  export type BankbindlistGetPayload<S extends boolean | null | undefined | BankbindlistArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Bankbindlist :
    S extends undefined ? never :
    S extends { include: any } & (BankbindlistArgs | BankbindlistFindManyArgs)
    ? Bankbindlist 
    : S extends { select: any } & (BankbindlistArgs | BankbindlistFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Bankbindlist ? Bankbindlist[P] : never
  } 
      : Bankbindlist


  type BankbindlistCountArgs = 
    Omit<BankbindlistFindManyArgs, 'select' | 'include'> & {
      select?: BankbindlistCountAggregateInputType | true
    }

  export interface BankbindlistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Bankbindlist that matches the filter.
     * @param {BankbindlistFindUniqueArgs} args - Arguments to find a Bankbindlist
     * @example
     * // Get one Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankbindlistFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankbindlistFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bankbindlist'> extends True ? Prisma__BankbindlistClient<BankbindlistGetPayload<T>> : Prisma__BankbindlistClient<BankbindlistGetPayload<T> | null, null>

    /**
     * Find one Bankbindlist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankbindlistFindUniqueOrThrowArgs} args - Arguments to find a Bankbindlist
     * @example
     * // Get one Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankbindlistFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BankbindlistFindUniqueOrThrowArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Find the first Bankbindlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistFindFirstArgs} args - Arguments to find a Bankbindlist
     * @example
     * // Get one Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankbindlistFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankbindlistFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bankbindlist'> extends True ? Prisma__BankbindlistClient<BankbindlistGetPayload<T>> : Prisma__BankbindlistClient<BankbindlistGetPayload<T> | null, null>

    /**
     * Find the first Bankbindlist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistFindFirstOrThrowArgs} args - Arguments to find a Bankbindlist
     * @example
     * // Get one Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankbindlistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BankbindlistFindFirstOrThrowArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Find zero or more Bankbindlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bankbindlists
     * const bankbindlists = await prisma.bankbindlist.findMany()
     * 
     * // Get first 10 Bankbindlists
     * const bankbindlists = await prisma.bankbindlist.findMany({ take: 10 })
     * 
     * // Only select the `cardId`
     * const bankbindlistWithCardIdOnly = await prisma.bankbindlist.findMany({ select: { cardId: true } })
     * 
    **/
    findMany<T extends BankbindlistFindManyArgs>(
      args?: SelectSubset<T, BankbindlistFindManyArgs>
    ): Prisma.PrismaPromise<Array<BankbindlistGetPayload<T>>>

    /**
     * Create a Bankbindlist.
     * @param {BankbindlistCreateArgs} args - Arguments to create a Bankbindlist.
     * @example
     * // Create one Bankbindlist
     * const Bankbindlist = await prisma.bankbindlist.create({
     *   data: {
     *     // ... data to create a Bankbindlist
     *   }
     * })
     * 
    **/
    create<T extends BankbindlistCreateArgs>(
      args: SelectSubset<T, BankbindlistCreateArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Create many Bankbindlists.
     *     @param {BankbindlistCreateManyArgs} args - Arguments to create many Bankbindlists.
     *     @example
     *     // Create many Bankbindlists
     *     const bankbindlist = await prisma.bankbindlist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankbindlistCreateManyArgs>(
      args?: SelectSubset<T, BankbindlistCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bankbindlist.
     * @param {BankbindlistDeleteArgs} args - Arguments to delete one Bankbindlist.
     * @example
     * // Delete one Bankbindlist
     * const Bankbindlist = await prisma.bankbindlist.delete({
     *   where: {
     *     // ... filter to delete one Bankbindlist
     *   }
     * })
     * 
    **/
    delete<T extends BankbindlistDeleteArgs>(
      args: SelectSubset<T, BankbindlistDeleteArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Update one Bankbindlist.
     * @param {BankbindlistUpdateArgs} args - Arguments to update one Bankbindlist.
     * @example
     * // Update one Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankbindlistUpdateArgs>(
      args: SelectSubset<T, BankbindlistUpdateArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Delete zero or more Bankbindlists.
     * @param {BankbindlistDeleteManyArgs} args - Arguments to filter Bankbindlists to delete.
     * @example
     * // Delete a few Bankbindlists
     * const { count } = await prisma.bankbindlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankbindlistDeleteManyArgs>(
      args?: SelectSubset<T, BankbindlistDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bankbindlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bankbindlists
     * const bankbindlist = await prisma.bankbindlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankbindlistUpdateManyArgs>(
      args: SelectSubset<T, BankbindlistUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bankbindlist.
     * @param {BankbindlistUpsertArgs} args - Arguments to update or create a Bankbindlist.
     * @example
     * // Update or create a Bankbindlist
     * const bankbindlist = await prisma.bankbindlist.upsert({
     *   create: {
     *     // ... data to create a Bankbindlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bankbindlist we want to update
     *   }
     * })
    **/
    upsert<T extends BankbindlistUpsertArgs>(
      args: SelectSubset<T, BankbindlistUpsertArgs>
    ): Prisma__BankbindlistClient<BankbindlistGetPayload<T>>

    /**
     * Count the number of Bankbindlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistCountArgs} args - Arguments to filter Bankbindlists to count.
     * @example
     * // Count the number of Bankbindlists
     * const count = await prisma.bankbindlist.count({
     *   where: {
     *     // ... the filter for the Bankbindlists we want to count
     *   }
     * })
    **/
    count<T extends BankbindlistCountArgs>(
      args?: Subset<T, BankbindlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankbindlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bankbindlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankbindlistAggregateArgs>(args: Subset<T, BankbindlistAggregateArgs>): Prisma.PrismaPromise<GetBankbindlistAggregateType<T>>

    /**
     * Group by Bankbindlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankbindlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankbindlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankbindlistGroupByArgs['orderBy'] }
        : { orderBy?: BankbindlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankbindlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankbindlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Bankbindlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankbindlistClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Bankbindlist base type for findUnique actions
   */
  export type BankbindlistFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter, which Bankbindlist to fetch.
     */
    where: BankbindlistWhereUniqueInput
  }

  /**
   * Bankbindlist findUnique
   */
  export interface BankbindlistFindUniqueArgs extends BankbindlistFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bankbindlist findUniqueOrThrow
   */
  export type BankbindlistFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter, which Bankbindlist to fetch.
     */
    where: BankbindlistWhereUniqueInput
  }


  /**
   * Bankbindlist base type for findFirst actions
   */
  export type BankbindlistFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter, which Bankbindlist to fetch.
     */
    where?: BankbindlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bankbindlists to fetch.
     */
    orderBy?: Enumerable<BankbindlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bankbindlists.
     */
    cursor?: BankbindlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bankbindlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bankbindlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bankbindlists.
     */
    distinct?: Enumerable<BankbindlistScalarFieldEnum>
  }

  /**
   * Bankbindlist findFirst
   */
  export interface BankbindlistFindFirstArgs extends BankbindlistFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bankbindlist findFirstOrThrow
   */
  export type BankbindlistFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter, which Bankbindlist to fetch.
     */
    where?: BankbindlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bankbindlists to fetch.
     */
    orderBy?: Enumerable<BankbindlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bankbindlists.
     */
    cursor?: BankbindlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bankbindlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bankbindlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bankbindlists.
     */
    distinct?: Enumerable<BankbindlistScalarFieldEnum>
  }


  /**
   * Bankbindlist findMany
   */
  export type BankbindlistFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter, which Bankbindlists to fetch.
     */
    where?: BankbindlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bankbindlists to fetch.
     */
    orderBy?: Enumerable<BankbindlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bankbindlists.
     */
    cursor?: BankbindlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bankbindlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bankbindlists.
     */
    skip?: number
    distinct?: Enumerable<BankbindlistScalarFieldEnum>
  }


  /**
   * Bankbindlist create
   */
  export type BankbindlistCreateArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * The data needed to create a Bankbindlist.
     */
    data: XOR<BankbindlistCreateInput, BankbindlistUncheckedCreateInput>
  }


  /**
   * Bankbindlist createMany
   */
  export type BankbindlistCreateManyArgs = {
    /**
     * The data used to create many Bankbindlists.
     */
    data: Enumerable<BankbindlistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bankbindlist update
   */
  export type BankbindlistUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * The data needed to update a Bankbindlist.
     */
    data: XOR<BankbindlistUpdateInput, BankbindlistUncheckedUpdateInput>
    /**
     * Choose, which Bankbindlist to update.
     */
    where: BankbindlistWhereUniqueInput
  }


  /**
   * Bankbindlist updateMany
   */
  export type BankbindlistUpdateManyArgs = {
    /**
     * The data used to update Bankbindlists.
     */
    data: XOR<BankbindlistUpdateManyMutationInput, BankbindlistUncheckedUpdateManyInput>
    /**
     * Filter which Bankbindlists to update
     */
    where?: BankbindlistWhereInput
  }


  /**
   * Bankbindlist upsert
   */
  export type BankbindlistUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * The filter to search for the Bankbindlist to update in case it exists.
     */
    where: BankbindlistWhereUniqueInput
    /**
     * In case the Bankbindlist found by the `where` argument doesn't exist, create a new Bankbindlist with this data.
     */
    create: XOR<BankbindlistCreateInput, BankbindlistUncheckedCreateInput>
    /**
     * In case the Bankbindlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankbindlistUpdateInput, BankbindlistUncheckedUpdateInput>
  }


  /**
   * Bankbindlist delete
   */
  export type BankbindlistDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
    /**
     * Filter which Bankbindlist to delete.
     */
    where: BankbindlistWhereUniqueInput
  }


  /**
   * Bankbindlist deleteMany
   */
  export type BankbindlistDeleteManyArgs = {
    /**
     * Filter which Bankbindlists to delete
     */
    where?: BankbindlistWhereInput
  }


  /**
   * Bankbindlist without action
   */
  export type BankbindlistArgs = {
    /**
     * Select specific fields to fetch from the Bankbindlist
     */
    select?: BankbindlistSelect | null
  }



  /**
   * Model Bankname
   */


  export type AggregateBankname = {
    _count: BanknameCountAggregateOutputType | null
    _avg: BanknameAvgAggregateOutputType | null
    _sum: BanknameSumAggregateOutputType | null
    _min: BanknameMinAggregateOutputType | null
    _max: BanknameMaxAggregateOutputType | null
  }

  export type BanknameAvgAggregateOutputType = {
    typeId: number | null
  }

  export type BanknameSumAggregateOutputType = {
    typeId: number | null
  }

  export type BanknameMinAggregateOutputType = {
    typeId: number | null
    bankName: string | null
  }

  export type BanknameMaxAggregateOutputType = {
    typeId: number | null
    bankName: string | null
  }

  export type BanknameCountAggregateOutputType = {
    typeId: number
    bankName: number
    _all: number
  }


  export type BanknameAvgAggregateInputType = {
    typeId?: true
  }

  export type BanknameSumAggregateInputType = {
    typeId?: true
  }

  export type BanknameMinAggregateInputType = {
    typeId?: true
    bankName?: true
  }

  export type BanknameMaxAggregateInputType = {
    typeId?: true
    bankName?: true
  }

  export type BanknameCountAggregateInputType = {
    typeId?: true
    bankName?: true
    _all?: true
  }

  export type BanknameAggregateArgs = {
    /**
     * Filter which Bankname to aggregate.
     */
    where?: BanknameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banknames to fetch.
     */
    orderBy?: Enumerable<BanknameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanknameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banknames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banknames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banknames
    **/
    _count?: true | BanknameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanknameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanknameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanknameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanknameMaxAggregateInputType
  }

  export type GetBanknameAggregateType<T extends BanknameAggregateArgs> = {
        [P in keyof T & keyof AggregateBankname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankname[P]>
      : GetScalarType<T[P], AggregateBankname[P]>
  }




  export type BanknameGroupByArgs = {
    where?: BanknameWhereInput
    orderBy?: Enumerable<BanknameOrderByWithAggregationInput>
    by: BanknameScalarFieldEnum[]
    having?: BanknameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanknameCountAggregateInputType | true
    _avg?: BanknameAvgAggregateInputType
    _sum?: BanknameSumAggregateInputType
    _min?: BanknameMinAggregateInputType
    _max?: BanknameMaxAggregateInputType
  }


  export type BanknameGroupByOutputType = {
    typeId: number
    bankName: string
    _count: BanknameCountAggregateOutputType | null
    _avg: BanknameAvgAggregateOutputType | null
    _sum: BanknameSumAggregateOutputType | null
    _min: BanknameMinAggregateOutputType | null
    _max: BanknameMaxAggregateOutputType | null
  }

  type GetBanknameGroupByPayload<T extends BanknameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BanknameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanknameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanknameGroupByOutputType[P]>
            : GetScalarType<T[P], BanknameGroupByOutputType[P]>
        }
      >
    >


  export type BanknameSelect = {
    typeId?: boolean
    bankName?: boolean
  }


  export type BanknameGetPayload<S extends boolean | null | undefined | BanknameArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Bankname :
    S extends undefined ? never :
    S extends { include: any } & (BanknameArgs | BanknameFindManyArgs)
    ? Bankname 
    : S extends { select: any } & (BanknameArgs | BanknameFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Bankname ? Bankname[P] : never
  } 
      : Bankname


  type BanknameCountArgs = 
    Omit<BanknameFindManyArgs, 'select' | 'include'> & {
      select?: BanknameCountAggregateInputType | true
    }

  export interface BanknameDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Bankname that matches the filter.
     * @param {BanknameFindUniqueArgs} args - Arguments to find a Bankname
     * @example
     * // Get one Bankname
     * const bankname = await prisma.bankname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BanknameFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BanknameFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bankname'> extends True ? Prisma__BanknameClient<BanknameGetPayload<T>> : Prisma__BanknameClient<BanknameGetPayload<T> | null, null>

    /**
     * Find one Bankname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BanknameFindUniqueOrThrowArgs} args - Arguments to find a Bankname
     * @example
     * // Get one Bankname
     * const bankname = await prisma.bankname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BanknameFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BanknameFindUniqueOrThrowArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Find the first Bankname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameFindFirstArgs} args - Arguments to find a Bankname
     * @example
     * // Get one Bankname
     * const bankname = await prisma.bankname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BanknameFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BanknameFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bankname'> extends True ? Prisma__BanknameClient<BanknameGetPayload<T>> : Prisma__BanknameClient<BanknameGetPayload<T> | null, null>

    /**
     * Find the first Bankname that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameFindFirstOrThrowArgs} args - Arguments to find a Bankname
     * @example
     * // Get one Bankname
     * const bankname = await prisma.bankname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BanknameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BanknameFindFirstOrThrowArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Find zero or more Banknames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banknames
     * const banknames = await prisma.bankname.findMany()
     * 
     * // Get first 10 Banknames
     * const banknames = await prisma.bankname.findMany({ take: 10 })
     * 
     * // Only select the `typeId`
     * const banknameWithTypeIdOnly = await prisma.bankname.findMany({ select: { typeId: true } })
     * 
    **/
    findMany<T extends BanknameFindManyArgs>(
      args?: SelectSubset<T, BanknameFindManyArgs>
    ): Prisma.PrismaPromise<Array<BanknameGetPayload<T>>>

    /**
     * Create a Bankname.
     * @param {BanknameCreateArgs} args - Arguments to create a Bankname.
     * @example
     * // Create one Bankname
     * const Bankname = await prisma.bankname.create({
     *   data: {
     *     // ... data to create a Bankname
     *   }
     * })
     * 
    **/
    create<T extends BanknameCreateArgs>(
      args: SelectSubset<T, BanknameCreateArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Create many Banknames.
     *     @param {BanknameCreateManyArgs} args - Arguments to create many Banknames.
     *     @example
     *     // Create many Banknames
     *     const bankname = await prisma.bankname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BanknameCreateManyArgs>(
      args?: SelectSubset<T, BanknameCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bankname.
     * @param {BanknameDeleteArgs} args - Arguments to delete one Bankname.
     * @example
     * // Delete one Bankname
     * const Bankname = await prisma.bankname.delete({
     *   where: {
     *     // ... filter to delete one Bankname
     *   }
     * })
     * 
    **/
    delete<T extends BanknameDeleteArgs>(
      args: SelectSubset<T, BanknameDeleteArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Update one Bankname.
     * @param {BanknameUpdateArgs} args - Arguments to update one Bankname.
     * @example
     * // Update one Bankname
     * const bankname = await prisma.bankname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BanknameUpdateArgs>(
      args: SelectSubset<T, BanknameUpdateArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Delete zero or more Banknames.
     * @param {BanknameDeleteManyArgs} args - Arguments to filter Banknames to delete.
     * @example
     * // Delete a few Banknames
     * const { count } = await prisma.bankname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BanknameDeleteManyArgs>(
      args?: SelectSubset<T, BanknameDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banknames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banknames
     * const bankname = await prisma.bankname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BanknameUpdateManyArgs>(
      args: SelectSubset<T, BanknameUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bankname.
     * @param {BanknameUpsertArgs} args - Arguments to update or create a Bankname.
     * @example
     * // Update or create a Bankname
     * const bankname = await prisma.bankname.upsert({
     *   create: {
     *     // ... data to create a Bankname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bankname we want to update
     *   }
     * })
    **/
    upsert<T extends BanknameUpsertArgs>(
      args: SelectSubset<T, BanknameUpsertArgs>
    ): Prisma__BanknameClient<BanknameGetPayload<T>>

    /**
     * Count the number of Banknames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameCountArgs} args - Arguments to filter Banknames to count.
     * @example
     * // Count the number of Banknames
     * const count = await prisma.bankname.count({
     *   where: {
     *     // ... the filter for the Banknames we want to count
     *   }
     * })
    **/
    count<T extends BanknameCountArgs>(
      args?: Subset<T, BanknameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanknameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bankname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanknameAggregateArgs>(args: Subset<T, BanknameAggregateArgs>): Prisma.PrismaPromise<GetBanknameAggregateType<T>>

    /**
     * Group by Bankname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanknameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanknameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanknameGroupByArgs['orderBy'] }
        : { orderBy?: BanknameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanknameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanknameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Bankname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BanknameClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Bankname base type for findUnique actions
   */
  export type BanknameFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter, which Bankname to fetch.
     */
    where: BanknameWhereUniqueInput
  }

  /**
   * Bankname findUnique
   */
  export interface BanknameFindUniqueArgs extends BanknameFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bankname findUniqueOrThrow
   */
  export type BanknameFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter, which Bankname to fetch.
     */
    where: BanknameWhereUniqueInput
  }


  /**
   * Bankname base type for findFirst actions
   */
  export type BanknameFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter, which Bankname to fetch.
     */
    where?: BanknameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banknames to fetch.
     */
    orderBy?: Enumerable<BanknameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banknames.
     */
    cursor?: BanknameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banknames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banknames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banknames.
     */
    distinct?: Enumerable<BanknameScalarFieldEnum>
  }

  /**
   * Bankname findFirst
   */
  export interface BanknameFindFirstArgs extends BanknameFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bankname findFirstOrThrow
   */
  export type BanknameFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter, which Bankname to fetch.
     */
    where?: BanknameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banknames to fetch.
     */
    orderBy?: Enumerable<BanknameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banknames.
     */
    cursor?: BanknameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banknames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banknames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banknames.
     */
    distinct?: Enumerable<BanknameScalarFieldEnum>
  }


  /**
   * Bankname findMany
   */
  export type BanknameFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter, which Banknames to fetch.
     */
    where?: BanknameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banknames to fetch.
     */
    orderBy?: Enumerable<BanknameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banknames.
     */
    cursor?: BanknameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banknames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banknames.
     */
    skip?: number
    distinct?: Enumerable<BanknameScalarFieldEnum>
  }


  /**
   * Bankname create
   */
  export type BanknameCreateArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * The data needed to create a Bankname.
     */
    data: XOR<BanknameCreateInput, BanknameUncheckedCreateInput>
  }


  /**
   * Bankname createMany
   */
  export type BanknameCreateManyArgs = {
    /**
     * The data used to create many Banknames.
     */
    data: Enumerable<BanknameCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bankname update
   */
  export type BanknameUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * The data needed to update a Bankname.
     */
    data: XOR<BanknameUpdateInput, BanknameUncheckedUpdateInput>
    /**
     * Choose, which Bankname to update.
     */
    where: BanknameWhereUniqueInput
  }


  /**
   * Bankname updateMany
   */
  export type BanknameUpdateManyArgs = {
    /**
     * The data used to update Banknames.
     */
    data: XOR<BanknameUpdateManyMutationInput, BanknameUncheckedUpdateManyInput>
    /**
     * Filter which Banknames to update
     */
    where?: BanknameWhereInput
  }


  /**
   * Bankname upsert
   */
  export type BanknameUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * The filter to search for the Bankname to update in case it exists.
     */
    where: BanknameWhereUniqueInput
    /**
     * In case the Bankname found by the `where` argument doesn't exist, create a new Bankname with this data.
     */
    create: XOR<BanknameCreateInput, BanknameUncheckedCreateInput>
    /**
     * In case the Bankname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanknameUpdateInput, BanknameUncheckedUpdateInput>
  }


  /**
   * Bankname delete
   */
  export type BanknameDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
    /**
     * Filter which Bankname to delete.
     */
    where: BanknameWhereUniqueInput
  }


  /**
   * Bankname deleteMany
   */
  export type BanknameDeleteManyArgs = {
    /**
     * Filter which Banknames to delete
     */
    where?: BanknameWhereInput
  }


  /**
   * Bankname without action
   */
  export type BanknameArgs = {
    /**
     * Select specific fields to fetch from the Bankname
     */
    select?: BanknameSelect | null
  }



  /**
   * Model Chatlog
   */


  export type AggregateChatlog = {
    _count: ChatlogCountAggregateOutputType | null
    _avg: ChatlogAvgAggregateOutputType | null
    _sum: ChatlogSumAggregateOutputType | null
    _min: ChatlogMinAggregateOutputType | null
    _max: ChatlogMaxAggregateOutputType | null
  }

  export type ChatlogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    toUserId: number | null
    isSendEnd: number | null
  }

  export type ChatlogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    toUserId: number | null
    isSendEnd: number | null
  }

  export type ChatlogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    toUserId: number | null
    nickname: string | null
    msg: string | null
    isSendEnd: number | null
    addDate: Date | null
  }

  export type ChatlogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    toUserId: number | null
    nickname: string | null
    msg: string | null
    isSendEnd: number | null
    addDate: Date | null
  }

  export type ChatlogCountAggregateOutputType = {
    id: number
    userId: number
    toUserId: number
    nickname: number
    msg: number
    isSendEnd: number
    addDate: number
    _all: number
  }


  export type ChatlogAvgAggregateInputType = {
    id?: true
    userId?: true
    toUserId?: true
    isSendEnd?: true
  }

  export type ChatlogSumAggregateInputType = {
    id?: true
    userId?: true
    toUserId?: true
    isSendEnd?: true
  }

  export type ChatlogMinAggregateInputType = {
    id?: true
    userId?: true
    toUserId?: true
    nickname?: true
    msg?: true
    isSendEnd?: true
    addDate?: true
  }

  export type ChatlogMaxAggregateInputType = {
    id?: true
    userId?: true
    toUserId?: true
    nickname?: true
    msg?: true
    isSendEnd?: true
    addDate?: true
  }

  export type ChatlogCountAggregateInputType = {
    id?: true
    userId?: true
    toUserId?: true
    nickname?: true
    msg?: true
    isSendEnd?: true
    addDate?: true
    _all?: true
  }

  export type ChatlogAggregateArgs = {
    /**
     * Filter which Chatlog to aggregate.
     */
    where?: ChatlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatlogs to fetch.
     */
    orderBy?: Enumerable<ChatlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatlogs
    **/
    _count?: true | ChatlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatlogMaxAggregateInputType
  }

  export type GetChatlogAggregateType<T extends ChatlogAggregateArgs> = {
        [P in keyof T & keyof AggregateChatlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatlog[P]>
      : GetScalarType<T[P], AggregateChatlog[P]>
  }




  export type ChatlogGroupByArgs = {
    where?: ChatlogWhereInput
    orderBy?: Enumerable<ChatlogOrderByWithAggregationInput>
    by: ChatlogScalarFieldEnum[]
    having?: ChatlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatlogCountAggregateInputType | true
    _avg?: ChatlogAvgAggregateInputType
    _sum?: ChatlogSumAggregateInputType
    _min?: ChatlogMinAggregateInputType
    _max?: ChatlogMaxAggregateInputType
  }


  export type ChatlogGroupByOutputType = {
    id: number
    userId: number
    toUserId: number
    nickname: string
    msg: string
    isSendEnd: number
    addDate: Date
    _count: ChatlogCountAggregateOutputType | null
    _avg: ChatlogAvgAggregateOutputType | null
    _sum: ChatlogSumAggregateOutputType | null
    _min: ChatlogMinAggregateOutputType | null
    _max: ChatlogMaxAggregateOutputType | null
  }

  type GetChatlogGroupByPayload<T extends ChatlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatlogGroupByOutputType[P]>
            : GetScalarType<T[P], ChatlogGroupByOutputType[P]>
        }
      >
    >


  export type ChatlogSelect = {
    id?: boolean
    userId?: boolean
    toUserId?: boolean
    nickname?: boolean
    msg?: boolean
    isSendEnd?: boolean
    addDate?: boolean
  }


  export type ChatlogGetPayload<S extends boolean | null | undefined | ChatlogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Chatlog :
    S extends undefined ? never :
    S extends { include: any } & (ChatlogArgs | ChatlogFindManyArgs)
    ? Chatlog 
    : S extends { select: any } & (ChatlogArgs | ChatlogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Chatlog ? Chatlog[P] : never
  } 
      : Chatlog


  type ChatlogCountArgs = 
    Omit<ChatlogFindManyArgs, 'select' | 'include'> & {
      select?: ChatlogCountAggregateInputType | true
    }

  export interface ChatlogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Chatlog that matches the filter.
     * @param {ChatlogFindUniqueArgs} args - Arguments to find a Chatlog
     * @example
     * // Get one Chatlog
     * const chatlog = await prisma.chatlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatlogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatlogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chatlog'> extends True ? Prisma__ChatlogClient<ChatlogGetPayload<T>> : Prisma__ChatlogClient<ChatlogGetPayload<T> | null, null>

    /**
     * Find one Chatlog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatlogFindUniqueOrThrowArgs} args - Arguments to find a Chatlog
     * @example
     * // Get one Chatlog
     * const chatlog = await prisma.chatlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatlogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatlogFindUniqueOrThrowArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Find the first Chatlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogFindFirstArgs} args - Arguments to find a Chatlog
     * @example
     * // Get one Chatlog
     * const chatlog = await prisma.chatlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatlogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatlogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chatlog'> extends True ? Prisma__ChatlogClient<ChatlogGetPayload<T>> : Prisma__ChatlogClient<ChatlogGetPayload<T> | null, null>

    /**
     * Find the first Chatlog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogFindFirstOrThrowArgs} args - Arguments to find a Chatlog
     * @example
     * // Get one Chatlog
     * const chatlog = await prisma.chatlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatlogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatlogFindFirstOrThrowArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Find zero or more Chatlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatlogs
     * const chatlogs = await prisma.chatlog.findMany()
     * 
     * // Get first 10 Chatlogs
     * const chatlogs = await prisma.chatlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatlogWithIdOnly = await prisma.chatlog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatlogFindManyArgs>(
      args?: SelectSubset<T, ChatlogFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatlogGetPayload<T>>>

    /**
     * Create a Chatlog.
     * @param {ChatlogCreateArgs} args - Arguments to create a Chatlog.
     * @example
     * // Create one Chatlog
     * const Chatlog = await prisma.chatlog.create({
     *   data: {
     *     // ... data to create a Chatlog
     *   }
     * })
     * 
    **/
    create<T extends ChatlogCreateArgs>(
      args: SelectSubset<T, ChatlogCreateArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Create many Chatlogs.
     *     @param {ChatlogCreateManyArgs} args - Arguments to create many Chatlogs.
     *     @example
     *     // Create many Chatlogs
     *     const chatlog = await prisma.chatlog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatlogCreateManyArgs>(
      args?: SelectSubset<T, ChatlogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chatlog.
     * @param {ChatlogDeleteArgs} args - Arguments to delete one Chatlog.
     * @example
     * // Delete one Chatlog
     * const Chatlog = await prisma.chatlog.delete({
     *   where: {
     *     // ... filter to delete one Chatlog
     *   }
     * })
     * 
    **/
    delete<T extends ChatlogDeleteArgs>(
      args: SelectSubset<T, ChatlogDeleteArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Update one Chatlog.
     * @param {ChatlogUpdateArgs} args - Arguments to update one Chatlog.
     * @example
     * // Update one Chatlog
     * const chatlog = await prisma.chatlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatlogUpdateArgs>(
      args: SelectSubset<T, ChatlogUpdateArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Delete zero or more Chatlogs.
     * @param {ChatlogDeleteManyArgs} args - Arguments to filter Chatlogs to delete.
     * @example
     * // Delete a few Chatlogs
     * const { count } = await prisma.chatlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatlogDeleteManyArgs>(
      args?: SelectSubset<T, ChatlogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatlogs
     * const chatlog = await prisma.chatlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatlogUpdateManyArgs>(
      args: SelectSubset<T, ChatlogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatlog.
     * @param {ChatlogUpsertArgs} args - Arguments to update or create a Chatlog.
     * @example
     * // Update or create a Chatlog
     * const chatlog = await prisma.chatlog.upsert({
     *   create: {
     *     // ... data to create a Chatlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatlog we want to update
     *   }
     * })
    **/
    upsert<T extends ChatlogUpsertArgs>(
      args: SelectSubset<T, ChatlogUpsertArgs>
    ): Prisma__ChatlogClient<ChatlogGetPayload<T>>

    /**
     * Count the number of Chatlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogCountArgs} args - Arguments to filter Chatlogs to count.
     * @example
     * // Count the number of Chatlogs
     * const count = await prisma.chatlog.count({
     *   where: {
     *     // ... the filter for the Chatlogs we want to count
     *   }
     * })
    **/
    count<T extends ChatlogCountArgs>(
      args?: Subset<T, ChatlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatlogAggregateArgs>(args: Subset<T, ChatlogAggregateArgs>): Prisma.PrismaPromise<GetChatlogAggregateType<T>>

    /**
     * Group by Chatlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatlogGroupByArgs['orderBy'] }
        : { orderBy?: ChatlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatlogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Chatlog base type for findUnique actions
   */
  export type ChatlogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter, which Chatlog to fetch.
     */
    where: ChatlogWhereUniqueInput
  }

  /**
   * Chatlog findUnique
   */
  export interface ChatlogFindUniqueArgs extends ChatlogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chatlog findUniqueOrThrow
   */
  export type ChatlogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter, which Chatlog to fetch.
     */
    where: ChatlogWhereUniqueInput
  }


  /**
   * Chatlog base type for findFirst actions
   */
  export type ChatlogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter, which Chatlog to fetch.
     */
    where?: ChatlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatlogs to fetch.
     */
    orderBy?: Enumerable<ChatlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatlogs.
     */
    cursor?: ChatlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatlogs.
     */
    distinct?: Enumerable<ChatlogScalarFieldEnum>
  }

  /**
   * Chatlog findFirst
   */
  export interface ChatlogFindFirstArgs extends ChatlogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chatlog findFirstOrThrow
   */
  export type ChatlogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter, which Chatlog to fetch.
     */
    where?: ChatlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatlogs to fetch.
     */
    orderBy?: Enumerable<ChatlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatlogs.
     */
    cursor?: ChatlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatlogs.
     */
    distinct?: Enumerable<ChatlogScalarFieldEnum>
  }


  /**
   * Chatlog findMany
   */
  export type ChatlogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter, which Chatlogs to fetch.
     */
    where?: ChatlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatlogs to fetch.
     */
    orderBy?: Enumerable<ChatlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatlogs.
     */
    cursor?: ChatlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatlogs.
     */
    skip?: number
    distinct?: Enumerable<ChatlogScalarFieldEnum>
  }


  /**
   * Chatlog create
   */
  export type ChatlogCreateArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * The data needed to create a Chatlog.
     */
    data: XOR<ChatlogCreateInput, ChatlogUncheckedCreateInput>
  }


  /**
   * Chatlog createMany
   */
  export type ChatlogCreateManyArgs = {
    /**
     * The data used to create many Chatlogs.
     */
    data: Enumerable<ChatlogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chatlog update
   */
  export type ChatlogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * The data needed to update a Chatlog.
     */
    data: XOR<ChatlogUpdateInput, ChatlogUncheckedUpdateInput>
    /**
     * Choose, which Chatlog to update.
     */
    where: ChatlogWhereUniqueInput
  }


  /**
   * Chatlog updateMany
   */
  export type ChatlogUpdateManyArgs = {
    /**
     * The data used to update Chatlogs.
     */
    data: XOR<ChatlogUpdateManyMutationInput, ChatlogUncheckedUpdateManyInput>
    /**
     * Filter which Chatlogs to update
     */
    where?: ChatlogWhereInput
  }


  /**
   * Chatlog upsert
   */
  export type ChatlogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * The filter to search for the Chatlog to update in case it exists.
     */
    where: ChatlogWhereUniqueInput
    /**
     * In case the Chatlog found by the `where` argument doesn't exist, create a new Chatlog with this data.
     */
    create: XOR<ChatlogCreateInput, ChatlogUncheckedCreateInput>
    /**
     * In case the Chatlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatlogUpdateInput, ChatlogUncheckedUpdateInput>
  }


  /**
   * Chatlog delete
   */
  export type ChatlogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
    /**
     * Filter which Chatlog to delete.
     */
    where: ChatlogWhereUniqueInput
  }


  /**
   * Chatlog deleteMany
   */
  export type ChatlogDeleteManyArgs = {
    /**
     * Filter which Chatlogs to delete
     */
    where?: ChatlogWhereInput
  }


  /**
   * Chatlog without action
   */
  export type ChatlogArgs = {
    /**
     * Select specific fields to fetch from the Chatlog
     */
    select?: ChatlogSelect | null
  }



  /**
   * Model Diamond_changelog
   */


  export type AggregateDiamond_changelog = {
    _count: Diamond_changelogCountAggregateOutputType | null
    _avg: Diamond_changelogAvgAggregateOutputType | null
    _sum: Diamond_changelogSumAggregateOutputType | null
    _min: Diamond_changelogMinAggregateOutputType | null
    _max: Diamond_changelogMaxAggregateOutputType | null
  }

  export type Diamond_changelogAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    diamond_before: number | null
    diamond_change: number | null
    diamond_current: number | null
    change_type: number | null
    isOnline: number | null
  }

  export type Diamond_changelogSumAggregateOutputType = {
    id: number | null
    userid: number | null
    diamond_before: number | null
    diamond_change: number | null
    diamond_current: number | null
    change_type: number | null
    isOnline: number | null
  }

  export type Diamond_changelogMinAggregateOutputType = {
    id: number | null
    userid: number | null
    diamond_before: number | null
    diamond_change: number | null
    diamond_current: number | null
    change_type: number | null
    change_time: Date | null
    isOnline: number | null
  }

  export type Diamond_changelogMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    diamond_before: number | null
    diamond_change: number | null
    diamond_current: number | null
    change_type: number | null
    change_time: Date | null
    isOnline: number | null
  }

  export type Diamond_changelogCountAggregateOutputType = {
    id: number
    userid: number
    diamond_before: number
    diamond_change: number
    diamond_current: number
    change_type: number
    change_time: number
    isOnline: number
    _all: number
  }


  export type Diamond_changelogAvgAggregateInputType = {
    id?: true
    userid?: true
    diamond_before?: true
    diamond_change?: true
    diamond_current?: true
    change_type?: true
    isOnline?: true
  }

  export type Diamond_changelogSumAggregateInputType = {
    id?: true
    userid?: true
    diamond_before?: true
    diamond_change?: true
    diamond_current?: true
    change_type?: true
    isOnline?: true
  }

  export type Diamond_changelogMinAggregateInputType = {
    id?: true
    userid?: true
    diamond_before?: true
    diamond_change?: true
    diamond_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
  }

  export type Diamond_changelogMaxAggregateInputType = {
    id?: true
    userid?: true
    diamond_before?: true
    diamond_change?: true
    diamond_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
  }

  export type Diamond_changelogCountAggregateInputType = {
    id?: true
    userid?: true
    diamond_before?: true
    diamond_change?: true
    diamond_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
    _all?: true
  }

  export type Diamond_changelogAggregateArgs = {
    /**
     * Filter which Diamond_changelog to aggregate.
     */
    where?: Diamond_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diamond_changelogs to fetch.
     */
    orderBy?: Enumerable<Diamond_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Diamond_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diamond_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diamond_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diamond_changelogs
    **/
    _count?: true | Diamond_changelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Diamond_changelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Diamond_changelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Diamond_changelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Diamond_changelogMaxAggregateInputType
  }

  export type GetDiamond_changelogAggregateType<T extends Diamond_changelogAggregateArgs> = {
        [P in keyof T & keyof AggregateDiamond_changelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiamond_changelog[P]>
      : GetScalarType<T[P], AggregateDiamond_changelog[P]>
  }




  export type Diamond_changelogGroupByArgs = {
    where?: Diamond_changelogWhereInput
    orderBy?: Enumerable<Diamond_changelogOrderByWithAggregationInput>
    by: Diamond_changelogScalarFieldEnum[]
    having?: Diamond_changelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Diamond_changelogCountAggregateInputType | true
    _avg?: Diamond_changelogAvgAggregateInputType
    _sum?: Diamond_changelogSumAggregateInputType
    _min?: Diamond_changelogMinAggregateInputType
    _max?: Diamond_changelogMaxAggregateInputType
  }


  export type Diamond_changelogGroupByOutputType = {
    id: number
    userid: number
    diamond_before: number
    diamond_change: number
    diamond_current: number
    change_type: number
    change_time: Date
    isOnline: number
    _count: Diamond_changelogCountAggregateOutputType | null
    _avg: Diamond_changelogAvgAggregateOutputType | null
    _sum: Diamond_changelogSumAggregateOutputType | null
    _min: Diamond_changelogMinAggregateOutputType | null
    _max: Diamond_changelogMaxAggregateOutputType | null
  }

  type GetDiamond_changelogGroupByPayload<T extends Diamond_changelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Diamond_changelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Diamond_changelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Diamond_changelogGroupByOutputType[P]>
            : GetScalarType<T[P], Diamond_changelogGroupByOutputType[P]>
        }
      >
    >


  export type Diamond_changelogSelect = {
    id?: boolean
    userid?: boolean
    diamond_before?: boolean
    diamond_change?: boolean
    diamond_current?: boolean
    change_type?: boolean
    change_time?: boolean
    isOnline?: boolean
  }


  export type Diamond_changelogGetPayload<S extends boolean | null | undefined | Diamond_changelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Diamond_changelog :
    S extends undefined ? never :
    S extends { include: any } & (Diamond_changelogArgs | Diamond_changelogFindManyArgs)
    ? Diamond_changelog 
    : S extends { select: any } & (Diamond_changelogArgs | Diamond_changelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Diamond_changelog ? Diamond_changelog[P] : never
  } 
      : Diamond_changelog


  type Diamond_changelogCountArgs = 
    Omit<Diamond_changelogFindManyArgs, 'select' | 'include'> & {
      select?: Diamond_changelogCountAggregateInputType | true
    }

  export interface Diamond_changelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Diamond_changelog that matches the filter.
     * @param {Diamond_changelogFindUniqueArgs} args - Arguments to find a Diamond_changelog
     * @example
     * // Get one Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Diamond_changelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Diamond_changelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Diamond_changelog'> extends True ? Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>> : Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T> | null, null>

    /**
     * Find one Diamond_changelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Diamond_changelogFindUniqueOrThrowArgs} args - Arguments to find a Diamond_changelog
     * @example
     * // Get one Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Diamond_changelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Diamond_changelogFindUniqueOrThrowArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Find the first Diamond_changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogFindFirstArgs} args - Arguments to find a Diamond_changelog
     * @example
     * // Get one Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Diamond_changelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Diamond_changelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Diamond_changelog'> extends True ? Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>> : Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T> | null, null>

    /**
     * Find the first Diamond_changelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogFindFirstOrThrowArgs} args - Arguments to find a Diamond_changelog
     * @example
     * // Get one Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Diamond_changelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Diamond_changelogFindFirstOrThrowArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Find zero or more Diamond_changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diamond_changelogs
     * const diamond_changelogs = await prisma.diamond_changelog.findMany()
     * 
     * // Get first 10 Diamond_changelogs
     * const diamond_changelogs = await prisma.diamond_changelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diamond_changelogWithIdOnly = await prisma.diamond_changelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Diamond_changelogFindManyArgs>(
      args?: SelectSubset<T, Diamond_changelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<Diamond_changelogGetPayload<T>>>

    /**
     * Create a Diamond_changelog.
     * @param {Diamond_changelogCreateArgs} args - Arguments to create a Diamond_changelog.
     * @example
     * // Create one Diamond_changelog
     * const Diamond_changelog = await prisma.diamond_changelog.create({
     *   data: {
     *     // ... data to create a Diamond_changelog
     *   }
     * })
     * 
    **/
    create<T extends Diamond_changelogCreateArgs>(
      args: SelectSubset<T, Diamond_changelogCreateArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Create many Diamond_changelogs.
     *     @param {Diamond_changelogCreateManyArgs} args - Arguments to create many Diamond_changelogs.
     *     @example
     *     // Create many Diamond_changelogs
     *     const diamond_changelog = await prisma.diamond_changelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Diamond_changelogCreateManyArgs>(
      args?: SelectSubset<T, Diamond_changelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diamond_changelog.
     * @param {Diamond_changelogDeleteArgs} args - Arguments to delete one Diamond_changelog.
     * @example
     * // Delete one Diamond_changelog
     * const Diamond_changelog = await prisma.diamond_changelog.delete({
     *   where: {
     *     // ... filter to delete one Diamond_changelog
     *   }
     * })
     * 
    **/
    delete<T extends Diamond_changelogDeleteArgs>(
      args: SelectSubset<T, Diamond_changelogDeleteArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Update one Diamond_changelog.
     * @param {Diamond_changelogUpdateArgs} args - Arguments to update one Diamond_changelog.
     * @example
     * // Update one Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Diamond_changelogUpdateArgs>(
      args: SelectSubset<T, Diamond_changelogUpdateArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Delete zero or more Diamond_changelogs.
     * @param {Diamond_changelogDeleteManyArgs} args - Arguments to filter Diamond_changelogs to delete.
     * @example
     * // Delete a few Diamond_changelogs
     * const { count } = await prisma.diamond_changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Diamond_changelogDeleteManyArgs>(
      args?: SelectSubset<T, Diamond_changelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diamond_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diamond_changelogs
     * const diamond_changelog = await prisma.diamond_changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Diamond_changelogUpdateManyArgs>(
      args: SelectSubset<T, Diamond_changelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diamond_changelog.
     * @param {Diamond_changelogUpsertArgs} args - Arguments to update or create a Diamond_changelog.
     * @example
     * // Update or create a Diamond_changelog
     * const diamond_changelog = await prisma.diamond_changelog.upsert({
     *   create: {
     *     // ... data to create a Diamond_changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diamond_changelog we want to update
     *   }
     * })
    **/
    upsert<T extends Diamond_changelogUpsertArgs>(
      args: SelectSubset<T, Diamond_changelogUpsertArgs>
    ): Prisma__Diamond_changelogClient<Diamond_changelogGetPayload<T>>

    /**
     * Count the number of Diamond_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogCountArgs} args - Arguments to filter Diamond_changelogs to count.
     * @example
     * // Count the number of Diamond_changelogs
     * const count = await prisma.diamond_changelog.count({
     *   where: {
     *     // ... the filter for the Diamond_changelogs we want to count
     *   }
     * })
    **/
    count<T extends Diamond_changelogCountArgs>(
      args?: Subset<T, Diamond_changelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Diamond_changelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diamond_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Diamond_changelogAggregateArgs>(args: Subset<T, Diamond_changelogAggregateArgs>): Prisma.PrismaPromise<GetDiamond_changelogAggregateType<T>>

    /**
     * Group by Diamond_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diamond_changelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Diamond_changelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Diamond_changelogGroupByArgs['orderBy'] }
        : { orderBy?: Diamond_changelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Diamond_changelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiamond_changelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Diamond_changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Diamond_changelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Diamond_changelog base type for findUnique actions
   */
  export type Diamond_changelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter, which Diamond_changelog to fetch.
     */
    where: Diamond_changelogWhereUniqueInput
  }

  /**
   * Diamond_changelog findUnique
   */
  export interface Diamond_changelogFindUniqueArgs extends Diamond_changelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Diamond_changelog findUniqueOrThrow
   */
  export type Diamond_changelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter, which Diamond_changelog to fetch.
     */
    where: Diamond_changelogWhereUniqueInput
  }


  /**
   * Diamond_changelog base type for findFirst actions
   */
  export type Diamond_changelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter, which Diamond_changelog to fetch.
     */
    where?: Diamond_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diamond_changelogs to fetch.
     */
    orderBy?: Enumerable<Diamond_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diamond_changelogs.
     */
    cursor?: Diamond_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diamond_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diamond_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diamond_changelogs.
     */
    distinct?: Enumerable<Diamond_changelogScalarFieldEnum>
  }

  /**
   * Diamond_changelog findFirst
   */
  export interface Diamond_changelogFindFirstArgs extends Diamond_changelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Diamond_changelog findFirstOrThrow
   */
  export type Diamond_changelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter, which Diamond_changelog to fetch.
     */
    where?: Diamond_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diamond_changelogs to fetch.
     */
    orderBy?: Enumerable<Diamond_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diamond_changelogs.
     */
    cursor?: Diamond_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diamond_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diamond_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diamond_changelogs.
     */
    distinct?: Enumerable<Diamond_changelogScalarFieldEnum>
  }


  /**
   * Diamond_changelog findMany
   */
  export type Diamond_changelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter, which Diamond_changelogs to fetch.
     */
    where?: Diamond_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diamond_changelogs to fetch.
     */
    orderBy?: Enumerable<Diamond_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diamond_changelogs.
     */
    cursor?: Diamond_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diamond_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diamond_changelogs.
     */
    skip?: number
    distinct?: Enumerable<Diamond_changelogScalarFieldEnum>
  }


  /**
   * Diamond_changelog create
   */
  export type Diamond_changelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * The data needed to create a Diamond_changelog.
     */
    data: XOR<Diamond_changelogCreateInput, Diamond_changelogUncheckedCreateInput>
  }


  /**
   * Diamond_changelog createMany
   */
  export type Diamond_changelogCreateManyArgs = {
    /**
     * The data used to create many Diamond_changelogs.
     */
    data: Enumerable<Diamond_changelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Diamond_changelog update
   */
  export type Diamond_changelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * The data needed to update a Diamond_changelog.
     */
    data: XOR<Diamond_changelogUpdateInput, Diamond_changelogUncheckedUpdateInput>
    /**
     * Choose, which Diamond_changelog to update.
     */
    where: Diamond_changelogWhereUniqueInput
  }


  /**
   * Diamond_changelog updateMany
   */
  export type Diamond_changelogUpdateManyArgs = {
    /**
     * The data used to update Diamond_changelogs.
     */
    data: XOR<Diamond_changelogUpdateManyMutationInput, Diamond_changelogUncheckedUpdateManyInput>
    /**
     * Filter which Diamond_changelogs to update
     */
    where?: Diamond_changelogWhereInput
  }


  /**
   * Diamond_changelog upsert
   */
  export type Diamond_changelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * The filter to search for the Diamond_changelog to update in case it exists.
     */
    where: Diamond_changelogWhereUniqueInput
    /**
     * In case the Diamond_changelog found by the `where` argument doesn't exist, create a new Diamond_changelog with this data.
     */
    create: XOR<Diamond_changelogCreateInput, Diamond_changelogUncheckedCreateInput>
    /**
     * In case the Diamond_changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Diamond_changelogUpdateInput, Diamond_changelogUncheckedUpdateInput>
  }


  /**
   * Diamond_changelog delete
   */
  export type Diamond_changelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
    /**
     * Filter which Diamond_changelog to delete.
     */
    where: Diamond_changelogWhereUniqueInput
  }


  /**
   * Diamond_changelog deleteMany
   */
  export type Diamond_changelogDeleteManyArgs = {
    /**
     * Filter which Diamond_changelogs to delete
     */
    where?: Diamond_changelogWhereInput
  }


  /**
   * Diamond_changelog without action
   */
  export type Diamond_changelogArgs = {
    /**
     * Select specific fields to fetch from the Diamond_changelog
     */
    select?: Diamond_changelogSelect | null
  }



  /**
   * Model Dongshanzaiqi
   */


  export type AggregateDongshanzaiqi = {
    _count: DongshanzaiqiCountAggregateOutputType | null
    _avg: DongshanzaiqiAvgAggregateOutputType | null
    _sum: DongshanzaiqiSumAggregateOutputType | null
    _min: DongshanzaiqiMinAggregateOutputType | null
    _max: DongshanzaiqiMaxAggregateOutputType | null
  }

  export type DongshanzaiqiAvgAggregateOutputType = {
    userId: number | null
    dcount: number | null
  }

  export type DongshanzaiqiSumAggregateOutputType = {
    userId: number | null
    dcount: number | null
  }

  export type DongshanzaiqiMinAggregateOutputType = {
    userId: number | null
    dcount: number | null
    dtime: Date | null
  }

  export type DongshanzaiqiMaxAggregateOutputType = {
    userId: number | null
    dcount: number | null
    dtime: Date | null
  }

  export type DongshanzaiqiCountAggregateOutputType = {
    userId: number
    dcount: number
    dtime: number
    _all: number
  }


  export type DongshanzaiqiAvgAggregateInputType = {
    userId?: true
    dcount?: true
  }

  export type DongshanzaiqiSumAggregateInputType = {
    userId?: true
    dcount?: true
  }

  export type DongshanzaiqiMinAggregateInputType = {
    userId?: true
    dcount?: true
    dtime?: true
  }

  export type DongshanzaiqiMaxAggregateInputType = {
    userId?: true
    dcount?: true
    dtime?: true
  }

  export type DongshanzaiqiCountAggregateInputType = {
    userId?: true
    dcount?: true
    dtime?: true
    _all?: true
  }

  export type DongshanzaiqiAggregateArgs = {
    /**
     * Filter which Dongshanzaiqi to aggregate.
     */
    where?: DongshanzaiqiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dongshanzaiqis to fetch.
     */
    orderBy?: Enumerable<DongshanzaiqiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DongshanzaiqiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dongshanzaiqis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dongshanzaiqis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dongshanzaiqis
    **/
    _count?: true | DongshanzaiqiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DongshanzaiqiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DongshanzaiqiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DongshanzaiqiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DongshanzaiqiMaxAggregateInputType
  }

  export type GetDongshanzaiqiAggregateType<T extends DongshanzaiqiAggregateArgs> = {
        [P in keyof T & keyof AggregateDongshanzaiqi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDongshanzaiqi[P]>
      : GetScalarType<T[P], AggregateDongshanzaiqi[P]>
  }




  export type DongshanzaiqiGroupByArgs = {
    where?: DongshanzaiqiWhereInput
    orderBy?: Enumerable<DongshanzaiqiOrderByWithAggregationInput>
    by: DongshanzaiqiScalarFieldEnum[]
    having?: DongshanzaiqiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DongshanzaiqiCountAggregateInputType | true
    _avg?: DongshanzaiqiAvgAggregateInputType
    _sum?: DongshanzaiqiSumAggregateInputType
    _min?: DongshanzaiqiMinAggregateInputType
    _max?: DongshanzaiqiMaxAggregateInputType
  }


  export type DongshanzaiqiGroupByOutputType = {
    userId: number
    dcount: number
    dtime: Date
    _count: DongshanzaiqiCountAggregateOutputType | null
    _avg: DongshanzaiqiAvgAggregateOutputType | null
    _sum: DongshanzaiqiSumAggregateOutputType | null
    _min: DongshanzaiqiMinAggregateOutputType | null
    _max: DongshanzaiqiMaxAggregateOutputType | null
  }

  type GetDongshanzaiqiGroupByPayload<T extends DongshanzaiqiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DongshanzaiqiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DongshanzaiqiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DongshanzaiqiGroupByOutputType[P]>
            : GetScalarType<T[P], DongshanzaiqiGroupByOutputType[P]>
        }
      >
    >


  export type DongshanzaiqiSelect = {
    userId?: boolean
    dcount?: boolean
    dtime?: boolean
  }


  export type DongshanzaiqiGetPayload<S extends boolean | null | undefined | DongshanzaiqiArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Dongshanzaiqi :
    S extends undefined ? never :
    S extends { include: any } & (DongshanzaiqiArgs | DongshanzaiqiFindManyArgs)
    ? Dongshanzaiqi 
    : S extends { select: any } & (DongshanzaiqiArgs | DongshanzaiqiFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Dongshanzaiqi ? Dongshanzaiqi[P] : never
  } 
      : Dongshanzaiqi


  type DongshanzaiqiCountArgs = 
    Omit<DongshanzaiqiFindManyArgs, 'select' | 'include'> & {
      select?: DongshanzaiqiCountAggregateInputType | true
    }

  export interface DongshanzaiqiDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Dongshanzaiqi that matches the filter.
     * @param {DongshanzaiqiFindUniqueArgs} args - Arguments to find a Dongshanzaiqi
     * @example
     * // Get one Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DongshanzaiqiFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DongshanzaiqiFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dongshanzaiqi'> extends True ? Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>> : Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T> | null, null>

    /**
     * Find one Dongshanzaiqi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DongshanzaiqiFindUniqueOrThrowArgs} args - Arguments to find a Dongshanzaiqi
     * @example
     * // Get one Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DongshanzaiqiFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DongshanzaiqiFindUniqueOrThrowArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Find the first Dongshanzaiqi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiFindFirstArgs} args - Arguments to find a Dongshanzaiqi
     * @example
     * // Get one Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DongshanzaiqiFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DongshanzaiqiFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dongshanzaiqi'> extends True ? Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>> : Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T> | null, null>

    /**
     * Find the first Dongshanzaiqi that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiFindFirstOrThrowArgs} args - Arguments to find a Dongshanzaiqi
     * @example
     * // Get one Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DongshanzaiqiFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DongshanzaiqiFindFirstOrThrowArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Find zero or more Dongshanzaiqis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dongshanzaiqis
     * const dongshanzaiqis = await prisma.dongshanzaiqi.findMany()
     * 
     * // Get first 10 Dongshanzaiqis
     * const dongshanzaiqis = await prisma.dongshanzaiqi.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const dongshanzaiqiWithUserIdOnly = await prisma.dongshanzaiqi.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends DongshanzaiqiFindManyArgs>(
      args?: SelectSubset<T, DongshanzaiqiFindManyArgs>
    ): Prisma.PrismaPromise<Array<DongshanzaiqiGetPayload<T>>>

    /**
     * Create a Dongshanzaiqi.
     * @param {DongshanzaiqiCreateArgs} args - Arguments to create a Dongshanzaiqi.
     * @example
     * // Create one Dongshanzaiqi
     * const Dongshanzaiqi = await prisma.dongshanzaiqi.create({
     *   data: {
     *     // ... data to create a Dongshanzaiqi
     *   }
     * })
     * 
    **/
    create<T extends DongshanzaiqiCreateArgs>(
      args: SelectSubset<T, DongshanzaiqiCreateArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Create many Dongshanzaiqis.
     *     @param {DongshanzaiqiCreateManyArgs} args - Arguments to create many Dongshanzaiqis.
     *     @example
     *     // Create many Dongshanzaiqis
     *     const dongshanzaiqi = await prisma.dongshanzaiqi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DongshanzaiqiCreateManyArgs>(
      args?: SelectSubset<T, DongshanzaiqiCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dongshanzaiqi.
     * @param {DongshanzaiqiDeleteArgs} args - Arguments to delete one Dongshanzaiqi.
     * @example
     * // Delete one Dongshanzaiqi
     * const Dongshanzaiqi = await prisma.dongshanzaiqi.delete({
     *   where: {
     *     // ... filter to delete one Dongshanzaiqi
     *   }
     * })
     * 
    **/
    delete<T extends DongshanzaiqiDeleteArgs>(
      args: SelectSubset<T, DongshanzaiqiDeleteArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Update one Dongshanzaiqi.
     * @param {DongshanzaiqiUpdateArgs} args - Arguments to update one Dongshanzaiqi.
     * @example
     * // Update one Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DongshanzaiqiUpdateArgs>(
      args: SelectSubset<T, DongshanzaiqiUpdateArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Delete zero or more Dongshanzaiqis.
     * @param {DongshanzaiqiDeleteManyArgs} args - Arguments to filter Dongshanzaiqis to delete.
     * @example
     * // Delete a few Dongshanzaiqis
     * const { count } = await prisma.dongshanzaiqi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DongshanzaiqiDeleteManyArgs>(
      args?: SelectSubset<T, DongshanzaiqiDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dongshanzaiqis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dongshanzaiqis
     * const dongshanzaiqi = await prisma.dongshanzaiqi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DongshanzaiqiUpdateManyArgs>(
      args: SelectSubset<T, DongshanzaiqiUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dongshanzaiqi.
     * @param {DongshanzaiqiUpsertArgs} args - Arguments to update or create a Dongshanzaiqi.
     * @example
     * // Update or create a Dongshanzaiqi
     * const dongshanzaiqi = await prisma.dongshanzaiqi.upsert({
     *   create: {
     *     // ... data to create a Dongshanzaiqi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dongshanzaiqi we want to update
     *   }
     * })
    **/
    upsert<T extends DongshanzaiqiUpsertArgs>(
      args: SelectSubset<T, DongshanzaiqiUpsertArgs>
    ): Prisma__DongshanzaiqiClient<DongshanzaiqiGetPayload<T>>

    /**
     * Count the number of Dongshanzaiqis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiCountArgs} args - Arguments to filter Dongshanzaiqis to count.
     * @example
     * // Count the number of Dongshanzaiqis
     * const count = await prisma.dongshanzaiqi.count({
     *   where: {
     *     // ... the filter for the Dongshanzaiqis we want to count
     *   }
     * })
    **/
    count<T extends DongshanzaiqiCountArgs>(
      args?: Subset<T, DongshanzaiqiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DongshanzaiqiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dongshanzaiqi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DongshanzaiqiAggregateArgs>(args: Subset<T, DongshanzaiqiAggregateArgs>): Prisma.PrismaPromise<GetDongshanzaiqiAggregateType<T>>

    /**
     * Group by Dongshanzaiqi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DongshanzaiqiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DongshanzaiqiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DongshanzaiqiGroupByArgs['orderBy'] }
        : { orderBy?: DongshanzaiqiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DongshanzaiqiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDongshanzaiqiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dongshanzaiqi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DongshanzaiqiClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dongshanzaiqi base type for findUnique actions
   */
  export type DongshanzaiqiFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter, which Dongshanzaiqi to fetch.
     */
    where: DongshanzaiqiWhereUniqueInput
  }

  /**
   * Dongshanzaiqi findUnique
   */
  export interface DongshanzaiqiFindUniqueArgs extends DongshanzaiqiFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dongshanzaiqi findUniqueOrThrow
   */
  export type DongshanzaiqiFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter, which Dongshanzaiqi to fetch.
     */
    where: DongshanzaiqiWhereUniqueInput
  }


  /**
   * Dongshanzaiqi base type for findFirst actions
   */
  export type DongshanzaiqiFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter, which Dongshanzaiqi to fetch.
     */
    where?: DongshanzaiqiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dongshanzaiqis to fetch.
     */
    orderBy?: Enumerable<DongshanzaiqiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dongshanzaiqis.
     */
    cursor?: DongshanzaiqiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dongshanzaiqis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dongshanzaiqis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dongshanzaiqis.
     */
    distinct?: Enumerable<DongshanzaiqiScalarFieldEnum>
  }

  /**
   * Dongshanzaiqi findFirst
   */
  export interface DongshanzaiqiFindFirstArgs extends DongshanzaiqiFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dongshanzaiqi findFirstOrThrow
   */
  export type DongshanzaiqiFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter, which Dongshanzaiqi to fetch.
     */
    where?: DongshanzaiqiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dongshanzaiqis to fetch.
     */
    orderBy?: Enumerable<DongshanzaiqiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dongshanzaiqis.
     */
    cursor?: DongshanzaiqiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dongshanzaiqis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dongshanzaiqis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dongshanzaiqis.
     */
    distinct?: Enumerable<DongshanzaiqiScalarFieldEnum>
  }


  /**
   * Dongshanzaiqi findMany
   */
  export type DongshanzaiqiFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter, which Dongshanzaiqis to fetch.
     */
    where?: DongshanzaiqiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dongshanzaiqis to fetch.
     */
    orderBy?: Enumerable<DongshanzaiqiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dongshanzaiqis.
     */
    cursor?: DongshanzaiqiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dongshanzaiqis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dongshanzaiqis.
     */
    skip?: number
    distinct?: Enumerable<DongshanzaiqiScalarFieldEnum>
  }


  /**
   * Dongshanzaiqi create
   */
  export type DongshanzaiqiCreateArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * The data needed to create a Dongshanzaiqi.
     */
    data: XOR<DongshanzaiqiCreateInput, DongshanzaiqiUncheckedCreateInput>
  }


  /**
   * Dongshanzaiqi createMany
   */
  export type DongshanzaiqiCreateManyArgs = {
    /**
     * The data used to create many Dongshanzaiqis.
     */
    data: Enumerable<DongshanzaiqiCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dongshanzaiqi update
   */
  export type DongshanzaiqiUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * The data needed to update a Dongshanzaiqi.
     */
    data: XOR<DongshanzaiqiUpdateInput, DongshanzaiqiUncheckedUpdateInput>
    /**
     * Choose, which Dongshanzaiqi to update.
     */
    where: DongshanzaiqiWhereUniqueInput
  }


  /**
   * Dongshanzaiqi updateMany
   */
  export type DongshanzaiqiUpdateManyArgs = {
    /**
     * The data used to update Dongshanzaiqis.
     */
    data: XOR<DongshanzaiqiUpdateManyMutationInput, DongshanzaiqiUncheckedUpdateManyInput>
    /**
     * Filter which Dongshanzaiqis to update
     */
    where?: DongshanzaiqiWhereInput
  }


  /**
   * Dongshanzaiqi upsert
   */
  export type DongshanzaiqiUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * The filter to search for the Dongshanzaiqi to update in case it exists.
     */
    where: DongshanzaiqiWhereUniqueInput
    /**
     * In case the Dongshanzaiqi found by the `where` argument doesn't exist, create a new Dongshanzaiqi with this data.
     */
    create: XOR<DongshanzaiqiCreateInput, DongshanzaiqiUncheckedCreateInput>
    /**
     * In case the Dongshanzaiqi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DongshanzaiqiUpdateInput, DongshanzaiqiUncheckedUpdateInput>
  }


  /**
   * Dongshanzaiqi delete
   */
  export type DongshanzaiqiDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
    /**
     * Filter which Dongshanzaiqi to delete.
     */
    where: DongshanzaiqiWhereUniqueInput
  }


  /**
   * Dongshanzaiqi deleteMany
   */
  export type DongshanzaiqiDeleteManyArgs = {
    /**
     * Filter which Dongshanzaiqis to delete
     */
    where?: DongshanzaiqiWhereInput
  }


  /**
   * Dongshanzaiqi without action
   */
  export type DongshanzaiqiArgs = {
    /**
     * Select specific fields to fetch from the Dongshanzaiqi
     */
    select?: DongshanzaiqiSelect | null
  }



  /**
   * Model Game_login_history
   */


  export type AggregateGame_login_history = {
    _count: Game_login_historyCountAggregateOutputType | null
    _avg: Game_login_historyAvgAggregateOutputType | null
    _sum: Game_login_historySumAggregateOutputType | null
    _min: Game_login_historyMinAggregateOutputType | null
    _max: Game_login_historyMaxAggregateOutputType | null
  }

  export type Game_login_historyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    encoin: number | null
    login_score: number | null
    logout_score: number | null
  }

  export type Game_login_historySumAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    encoin: number | null
    login_score: number | null
    logout_score: number | null
  }

  export type Game_login_historyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    serverId: string | null
    encoin: number | null
    login_score: number | null
    logout_score: number | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type Game_login_historyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: number | null
    serverId: string | null
    encoin: number | null
    login_score: number | null
    logout_score: number | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type Game_login_historyCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    serverId: number
    encoin: number
    login_score: number
    logout_score: number
    loginDate: number
    logoutDate: number
    _all: number
  }


  export type Game_login_historyAvgAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    encoin?: true
    login_score?: true
    logout_score?: true
  }

  export type Game_login_historySumAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    encoin?: true
    login_score?: true
    logout_score?: true
  }

  export type Game_login_historyMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    serverId?: true
    encoin?: true
    login_score?: true
    logout_score?: true
    loginDate?: true
    logoutDate?: true
  }

  export type Game_login_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    serverId?: true
    encoin?: true
    login_score?: true
    logout_score?: true
    loginDate?: true
    logoutDate?: true
  }

  export type Game_login_historyCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    serverId?: true
    encoin?: true
    login_score?: true
    logout_score?: true
    loginDate?: true
    logoutDate?: true
    _all?: true
  }

  export type Game_login_historyAggregateArgs = {
    /**
     * Filter which Game_login_history to aggregate.
     */
    where?: Game_login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_login_histories to fetch.
     */
    orderBy?: Enumerable<Game_login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Game_login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Game_login_histories
    **/
    _count?: true | Game_login_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_login_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_login_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_login_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_login_historyMaxAggregateInputType
  }

  export type GetGame_login_historyAggregateType<T extends Game_login_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_login_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_login_history[P]>
      : GetScalarType<T[P], AggregateGame_login_history[P]>
  }




  export type Game_login_historyGroupByArgs = {
    where?: Game_login_historyWhereInput
    orderBy?: Enumerable<Game_login_historyOrderByWithAggregationInput>
    by: Game_login_historyScalarFieldEnum[]
    having?: Game_login_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_login_historyCountAggregateInputType | true
    _avg?: Game_login_historyAvgAggregateInputType
    _sum?: Game_login_historySumAggregateInputType
    _min?: Game_login_historyMinAggregateInputType
    _max?: Game_login_historyMaxAggregateInputType
  }


  export type Game_login_historyGroupByOutputType = {
    id: number
    userId: number
    gameId: number
    serverId: string
    encoin: number
    login_score: number
    logout_score: number
    loginDate: Date
    logoutDate: Date
    _count: Game_login_historyCountAggregateOutputType | null
    _avg: Game_login_historyAvgAggregateOutputType | null
    _sum: Game_login_historySumAggregateOutputType | null
    _min: Game_login_historyMinAggregateOutputType | null
    _max: Game_login_historyMaxAggregateOutputType | null
  }

  type GetGame_login_historyGroupByPayload<T extends Game_login_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Game_login_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_login_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_login_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Game_login_historyGroupByOutputType[P]>
        }
      >
    >


  export type Game_login_historySelect = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    serverId?: boolean
    encoin?: boolean
    login_score?: boolean
    logout_score?: boolean
    loginDate?: boolean
    logoutDate?: boolean
  }


  export type Game_login_historyGetPayload<S extends boolean | null | undefined | Game_login_historyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Game_login_history :
    S extends undefined ? never :
    S extends { include: any } & (Game_login_historyArgs | Game_login_historyFindManyArgs)
    ? Game_login_history 
    : S extends { select: any } & (Game_login_historyArgs | Game_login_historyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Game_login_history ? Game_login_history[P] : never
  } 
      : Game_login_history


  type Game_login_historyCountArgs = 
    Omit<Game_login_historyFindManyArgs, 'select' | 'include'> & {
      select?: Game_login_historyCountAggregateInputType | true
    }

  export interface Game_login_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Game_login_history that matches the filter.
     * @param {Game_login_historyFindUniqueArgs} args - Arguments to find a Game_login_history
     * @example
     * // Get one Game_login_history
     * const game_login_history = await prisma.game_login_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Game_login_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Game_login_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Game_login_history'> extends True ? Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>> : Prisma__Game_login_historyClient<Game_login_historyGetPayload<T> | null, null>

    /**
     * Find one Game_login_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Game_login_historyFindUniqueOrThrowArgs} args - Arguments to find a Game_login_history
     * @example
     * // Get one Game_login_history
     * const game_login_history = await prisma.game_login_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Game_login_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Game_login_historyFindUniqueOrThrowArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Find the first Game_login_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyFindFirstArgs} args - Arguments to find a Game_login_history
     * @example
     * // Get one Game_login_history
     * const game_login_history = await prisma.game_login_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Game_login_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Game_login_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Game_login_history'> extends True ? Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>> : Prisma__Game_login_historyClient<Game_login_historyGetPayload<T> | null, null>

    /**
     * Find the first Game_login_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyFindFirstOrThrowArgs} args - Arguments to find a Game_login_history
     * @example
     * // Get one Game_login_history
     * const game_login_history = await prisma.game_login_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Game_login_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Game_login_historyFindFirstOrThrowArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Find zero or more Game_login_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_login_histories
     * const game_login_histories = await prisma.game_login_history.findMany()
     * 
     * // Get first 10 Game_login_histories
     * const game_login_histories = await prisma.game_login_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_login_historyWithIdOnly = await prisma.game_login_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Game_login_historyFindManyArgs>(
      args?: SelectSubset<T, Game_login_historyFindManyArgs>
    ): Prisma.PrismaPromise<Array<Game_login_historyGetPayload<T>>>

    /**
     * Create a Game_login_history.
     * @param {Game_login_historyCreateArgs} args - Arguments to create a Game_login_history.
     * @example
     * // Create one Game_login_history
     * const Game_login_history = await prisma.game_login_history.create({
     *   data: {
     *     // ... data to create a Game_login_history
     *   }
     * })
     * 
    **/
    create<T extends Game_login_historyCreateArgs>(
      args: SelectSubset<T, Game_login_historyCreateArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Create many Game_login_histories.
     *     @param {Game_login_historyCreateManyArgs} args - Arguments to create many Game_login_histories.
     *     @example
     *     // Create many Game_login_histories
     *     const game_login_history = await prisma.game_login_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Game_login_historyCreateManyArgs>(
      args?: SelectSubset<T, Game_login_historyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game_login_history.
     * @param {Game_login_historyDeleteArgs} args - Arguments to delete one Game_login_history.
     * @example
     * // Delete one Game_login_history
     * const Game_login_history = await prisma.game_login_history.delete({
     *   where: {
     *     // ... filter to delete one Game_login_history
     *   }
     * })
     * 
    **/
    delete<T extends Game_login_historyDeleteArgs>(
      args: SelectSubset<T, Game_login_historyDeleteArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Update one Game_login_history.
     * @param {Game_login_historyUpdateArgs} args - Arguments to update one Game_login_history.
     * @example
     * // Update one Game_login_history
     * const game_login_history = await prisma.game_login_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Game_login_historyUpdateArgs>(
      args: SelectSubset<T, Game_login_historyUpdateArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Delete zero or more Game_login_histories.
     * @param {Game_login_historyDeleteManyArgs} args - Arguments to filter Game_login_histories to delete.
     * @example
     * // Delete a few Game_login_histories
     * const { count } = await prisma.game_login_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Game_login_historyDeleteManyArgs>(
      args?: SelectSubset<T, Game_login_historyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_login_histories
     * const game_login_history = await prisma.game_login_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Game_login_historyUpdateManyArgs>(
      args: SelectSubset<T, Game_login_historyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_login_history.
     * @param {Game_login_historyUpsertArgs} args - Arguments to update or create a Game_login_history.
     * @example
     * // Update or create a Game_login_history
     * const game_login_history = await prisma.game_login_history.upsert({
     *   create: {
     *     // ... data to create a Game_login_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_login_history we want to update
     *   }
     * })
    **/
    upsert<T extends Game_login_historyUpsertArgs>(
      args: SelectSubset<T, Game_login_historyUpsertArgs>
    ): Prisma__Game_login_historyClient<Game_login_historyGetPayload<T>>

    /**
     * Count the number of Game_login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyCountArgs} args - Arguments to filter Game_login_histories to count.
     * @example
     * // Count the number of Game_login_histories
     * const count = await prisma.game_login_history.count({
     *   where: {
     *     // ... the filter for the Game_login_histories we want to count
     *   }
     * })
    **/
    count<T extends Game_login_historyCountArgs>(
      args?: Subset<T, Game_login_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_login_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_login_historyAggregateArgs>(args: Subset<T, Game_login_historyAggregateArgs>): Prisma.PrismaPromise<GetGame_login_historyAggregateType<T>>

    /**
     * Group by Game_login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_login_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Game_login_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Game_login_historyGroupByArgs['orderBy'] }
        : { orderBy?: Game_login_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Game_login_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_login_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Game_login_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Game_login_historyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Game_login_history base type for findUnique actions
   */
  export type Game_login_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter, which Game_login_history to fetch.
     */
    where: Game_login_historyWhereUniqueInput
  }

  /**
   * Game_login_history findUnique
   */
  export interface Game_login_historyFindUniqueArgs extends Game_login_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game_login_history findUniqueOrThrow
   */
  export type Game_login_historyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter, which Game_login_history to fetch.
     */
    where: Game_login_historyWhereUniqueInput
  }


  /**
   * Game_login_history base type for findFirst actions
   */
  export type Game_login_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter, which Game_login_history to fetch.
     */
    where?: Game_login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_login_histories to fetch.
     */
    orderBy?: Enumerable<Game_login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Game_login_histories.
     */
    cursor?: Game_login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Game_login_histories.
     */
    distinct?: Enumerable<Game_login_historyScalarFieldEnum>
  }

  /**
   * Game_login_history findFirst
   */
  export interface Game_login_historyFindFirstArgs extends Game_login_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game_login_history findFirstOrThrow
   */
  export type Game_login_historyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter, which Game_login_history to fetch.
     */
    where?: Game_login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_login_histories to fetch.
     */
    orderBy?: Enumerable<Game_login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Game_login_histories.
     */
    cursor?: Game_login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Game_login_histories.
     */
    distinct?: Enumerable<Game_login_historyScalarFieldEnum>
  }


  /**
   * Game_login_history findMany
   */
  export type Game_login_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter, which Game_login_histories to fetch.
     */
    where?: Game_login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_login_histories to fetch.
     */
    orderBy?: Enumerable<Game_login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Game_login_histories.
     */
    cursor?: Game_login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_login_histories.
     */
    skip?: number
    distinct?: Enumerable<Game_login_historyScalarFieldEnum>
  }


  /**
   * Game_login_history create
   */
  export type Game_login_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * The data needed to create a Game_login_history.
     */
    data: XOR<Game_login_historyCreateInput, Game_login_historyUncheckedCreateInput>
  }


  /**
   * Game_login_history createMany
   */
  export type Game_login_historyCreateManyArgs = {
    /**
     * The data used to create many Game_login_histories.
     */
    data: Enumerable<Game_login_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Game_login_history update
   */
  export type Game_login_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * The data needed to update a Game_login_history.
     */
    data: XOR<Game_login_historyUpdateInput, Game_login_historyUncheckedUpdateInput>
    /**
     * Choose, which Game_login_history to update.
     */
    where: Game_login_historyWhereUniqueInput
  }


  /**
   * Game_login_history updateMany
   */
  export type Game_login_historyUpdateManyArgs = {
    /**
     * The data used to update Game_login_histories.
     */
    data: XOR<Game_login_historyUpdateManyMutationInput, Game_login_historyUncheckedUpdateManyInput>
    /**
     * Filter which Game_login_histories to update
     */
    where?: Game_login_historyWhereInput
  }


  /**
   * Game_login_history upsert
   */
  export type Game_login_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * The filter to search for the Game_login_history to update in case it exists.
     */
    where: Game_login_historyWhereUniqueInput
    /**
     * In case the Game_login_history found by the `where` argument doesn't exist, create a new Game_login_history with this data.
     */
    create: XOR<Game_login_historyCreateInput, Game_login_historyUncheckedCreateInput>
    /**
     * In case the Game_login_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Game_login_historyUpdateInput, Game_login_historyUncheckedUpdateInput>
  }


  /**
   * Game_login_history delete
   */
  export type Game_login_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
    /**
     * Filter which Game_login_history to delete.
     */
    where: Game_login_historyWhereUniqueInput
  }


  /**
   * Game_login_history deleteMany
   */
  export type Game_login_historyDeleteManyArgs = {
    /**
     * Filter which Game_login_histories to delete
     */
    where?: Game_login_historyWhereInput
  }


  /**
   * Game_login_history without action
   */
  export type Game_login_historyArgs = {
    /**
     * Select specific fields to fetch from the Game_login_history
     */
    select?: Game_login_historySelect | null
  }



  /**
   * Model Game_onlinenum
   */


  export type AggregateGame_onlinenum = {
    _count: Game_onlinenumCountAggregateOutputType | null
    _avg: Game_onlinenumAvgAggregateOutputType | null
    _sum: Game_onlinenumSumAggregateOutputType | null
    _min: Game_onlinenumMinAggregateOutputType | null
    _max: Game_onlinenumMaxAggregateOutputType | null
  }

  export type Game_onlinenumAvgAggregateOutputType = {
    id: number | null
    gid: number | null
    num: number | null
  }

  export type Game_onlinenumSumAggregateOutputType = {
    id: number | null
    gid: number | null
    num: number | null
  }

  export type Game_onlinenumMinAggregateOutputType = {
    id: number | null
    gid: number | null
    gport: string | null
    num: number | null
    createtime: string | null
  }

  export type Game_onlinenumMaxAggregateOutputType = {
    id: number | null
    gid: number | null
    gport: string | null
    num: number | null
    createtime: string | null
  }

  export type Game_onlinenumCountAggregateOutputType = {
    id: number
    gid: number
    gport: number
    num: number
    createtime: number
    _all: number
  }


  export type Game_onlinenumAvgAggregateInputType = {
    id?: true
    gid?: true
    num?: true
  }

  export type Game_onlinenumSumAggregateInputType = {
    id?: true
    gid?: true
    num?: true
  }

  export type Game_onlinenumMinAggregateInputType = {
    id?: true
    gid?: true
    gport?: true
    num?: true
    createtime?: true
  }

  export type Game_onlinenumMaxAggregateInputType = {
    id?: true
    gid?: true
    gport?: true
    num?: true
    createtime?: true
  }

  export type Game_onlinenumCountAggregateInputType = {
    id?: true
    gid?: true
    gport?: true
    num?: true
    createtime?: true
    _all?: true
  }

  export type Game_onlinenumAggregateArgs = {
    /**
     * Filter which Game_onlinenum to aggregate.
     */
    where?: Game_onlinenumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_onlinenums to fetch.
     */
    orderBy?: Enumerable<Game_onlinenumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Game_onlinenumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_onlinenums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_onlinenums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Game_onlinenums
    **/
    _count?: true | Game_onlinenumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_onlinenumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_onlinenumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_onlinenumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_onlinenumMaxAggregateInputType
  }

  export type GetGame_onlinenumAggregateType<T extends Game_onlinenumAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_onlinenum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_onlinenum[P]>
      : GetScalarType<T[P], AggregateGame_onlinenum[P]>
  }




  export type Game_onlinenumGroupByArgs = {
    where?: Game_onlinenumWhereInput
    orderBy?: Enumerable<Game_onlinenumOrderByWithAggregationInput>
    by: Game_onlinenumScalarFieldEnum[]
    having?: Game_onlinenumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_onlinenumCountAggregateInputType | true
    _avg?: Game_onlinenumAvgAggregateInputType
    _sum?: Game_onlinenumSumAggregateInputType
    _min?: Game_onlinenumMinAggregateInputType
    _max?: Game_onlinenumMaxAggregateInputType
  }


  export type Game_onlinenumGroupByOutputType = {
    id: number
    gid: number
    gport: string
    num: number
    createtime: string
    _count: Game_onlinenumCountAggregateOutputType | null
    _avg: Game_onlinenumAvgAggregateOutputType | null
    _sum: Game_onlinenumSumAggregateOutputType | null
    _min: Game_onlinenumMinAggregateOutputType | null
    _max: Game_onlinenumMaxAggregateOutputType | null
  }

  type GetGame_onlinenumGroupByPayload<T extends Game_onlinenumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Game_onlinenumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_onlinenumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_onlinenumGroupByOutputType[P]>
            : GetScalarType<T[P], Game_onlinenumGroupByOutputType[P]>
        }
      >
    >


  export type Game_onlinenumSelect = {
    id?: boolean
    gid?: boolean
    gport?: boolean
    num?: boolean
    createtime?: boolean
  }


  export type Game_onlinenumGetPayload<S extends boolean | null | undefined | Game_onlinenumArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Game_onlinenum :
    S extends undefined ? never :
    S extends { include: any } & (Game_onlinenumArgs | Game_onlinenumFindManyArgs)
    ? Game_onlinenum 
    : S extends { select: any } & (Game_onlinenumArgs | Game_onlinenumFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Game_onlinenum ? Game_onlinenum[P] : never
  } 
      : Game_onlinenum


  type Game_onlinenumCountArgs = 
    Omit<Game_onlinenumFindManyArgs, 'select' | 'include'> & {
      select?: Game_onlinenumCountAggregateInputType | true
    }

  export interface Game_onlinenumDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Game_onlinenum that matches the filter.
     * @param {Game_onlinenumFindUniqueArgs} args - Arguments to find a Game_onlinenum
     * @example
     * // Get one Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Game_onlinenumFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Game_onlinenumFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Game_onlinenum'> extends True ? Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>> : Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T> | null, null>

    /**
     * Find one Game_onlinenum that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Game_onlinenumFindUniqueOrThrowArgs} args - Arguments to find a Game_onlinenum
     * @example
     * // Get one Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Game_onlinenumFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Game_onlinenumFindUniqueOrThrowArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Find the first Game_onlinenum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumFindFirstArgs} args - Arguments to find a Game_onlinenum
     * @example
     * // Get one Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Game_onlinenumFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Game_onlinenumFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Game_onlinenum'> extends True ? Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>> : Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T> | null, null>

    /**
     * Find the first Game_onlinenum that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumFindFirstOrThrowArgs} args - Arguments to find a Game_onlinenum
     * @example
     * // Get one Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Game_onlinenumFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Game_onlinenumFindFirstOrThrowArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Find zero or more Game_onlinenums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_onlinenums
     * const game_onlinenums = await prisma.game_onlinenum.findMany()
     * 
     * // Get first 10 Game_onlinenums
     * const game_onlinenums = await prisma.game_onlinenum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_onlinenumWithIdOnly = await prisma.game_onlinenum.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Game_onlinenumFindManyArgs>(
      args?: SelectSubset<T, Game_onlinenumFindManyArgs>
    ): Prisma.PrismaPromise<Array<Game_onlinenumGetPayload<T>>>

    /**
     * Create a Game_onlinenum.
     * @param {Game_onlinenumCreateArgs} args - Arguments to create a Game_onlinenum.
     * @example
     * // Create one Game_onlinenum
     * const Game_onlinenum = await prisma.game_onlinenum.create({
     *   data: {
     *     // ... data to create a Game_onlinenum
     *   }
     * })
     * 
    **/
    create<T extends Game_onlinenumCreateArgs>(
      args: SelectSubset<T, Game_onlinenumCreateArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Create many Game_onlinenums.
     *     @param {Game_onlinenumCreateManyArgs} args - Arguments to create many Game_onlinenums.
     *     @example
     *     // Create many Game_onlinenums
     *     const game_onlinenum = await prisma.game_onlinenum.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Game_onlinenumCreateManyArgs>(
      args?: SelectSubset<T, Game_onlinenumCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game_onlinenum.
     * @param {Game_onlinenumDeleteArgs} args - Arguments to delete one Game_onlinenum.
     * @example
     * // Delete one Game_onlinenum
     * const Game_onlinenum = await prisma.game_onlinenum.delete({
     *   where: {
     *     // ... filter to delete one Game_onlinenum
     *   }
     * })
     * 
    **/
    delete<T extends Game_onlinenumDeleteArgs>(
      args: SelectSubset<T, Game_onlinenumDeleteArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Update one Game_onlinenum.
     * @param {Game_onlinenumUpdateArgs} args - Arguments to update one Game_onlinenum.
     * @example
     * // Update one Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Game_onlinenumUpdateArgs>(
      args: SelectSubset<T, Game_onlinenumUpdateArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Delete zero or more Game_onlinenums.
     * @param {Game_onlinenumDeleteManyArgs} args - Arguments to filter Game_onlinenums to delete.
     * @example
     * // Delete a few Game_onlinenums
     * const { count } = await prisma.game_onlinenum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Game_onlinenumDeleteManyArgs>(
      args?: SelectSubset<T, Game_onlinenumDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_onlinenums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_onlinenums
     * const game_onlinenum = await prisma.game_onlinenum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Game_onlinenumUpdateManyArgs>(
      args: SelectSubset<T, Game_onlinenumUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_onlinenum.
     * @param {Game_onlinenumUpsertArgs} args - Arguments to update or create a Game_onlinenum.
     * @example
     * // Update or create a Game_onlinenum
     * const game_onlinenum = await prisma.game_onlinenum.upsert({
     *   create: {
     *     // ... data to create a Game_onlinenum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_onlinenum we want to update
     *   }
     * })
    **/
    upsert<T extends Game_onlinenumUpsertArgs>(
      args: SelectSubset<T, Game_onlinenumUpsertArgs>
    ): Prisma__Game_onlinenumClient<Game_onlinenumGetPayload<T>>

    /**
     * Count the number of Game_onlinenums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumCountArgs} args - Arguments to filter Game_onlinenums to count.
     * @example
     * // Count the number of Game_onlinenums
     * const count = await prisma.game_onlinenum.count({
     *   where: {
     *     // ... the filter for the Game_onlinenums we want to count
     *   }
     * })
    **/
    count<T extends Game_onlinenumCountArgs>(
      args?: Subset<T, Game_onlinenumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_onlinenumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_onlinenum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_onlinenumAggregateArgs>(args: Subset<T, Game_onlinenumAggregateArgs>): Prisma.PrismaPromise<GetGame_onlinenumAggregateType<T>>

    /**
     * Group by Game_onlinenum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_onlinenumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Game_onlinenumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Game_onlinenumGroupByArgs['orderBy'] }
        : { orderBy?: Game_onlinenumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Game_onlinenumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_onlinenumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Game_onlinenum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Game_onlinenumClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Game_onlinenum base type for findUnique actions
   */
  export type Game_onlinenumFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter, which Game_onlinenum to fetch.
     */
    where: Game_onlinenumWhereUniqueInput
  }

  /**
   * Game_onlinenum findUnique
   */
  export interface Game_onlinenumFindUniqueArgs extends Game_onlinenumFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game_onlinenum findUniqueOrThrow
   */
  export type Game_onlinenumFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter, which Game_onlinenum to fetch.
     */
    where: Game_onlinenumWhereUniqueInput
  }


  /**
   * Game_onlinenum base type for findFirst actions
   */
  export type Game_onlinenumFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter, which Game_onlinenum to fetch.
     */
    where?: Game_onlinenumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_onlinenums to fetch.
     */
    orderBy?: Enumerable<Game_onlinenumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Game_onlinenums.
     */
    cursor?: Game_onlinenumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_onlinenums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_onlinenums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Game_onlinenums.
     */
    distinct?: Enumerable<Game_onlinenumScalarFieldEnum>
  }

  /**
   * Game_onlinenum findFirst
   */
  export interface Game_onlinenumFindFirstArgs extends Game_onlinenumFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game_onlinenum findFirstOrThrow
   */
  export type Game_onlinenumFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter, which Game_onlinenum to fetch.
     */
    where?: Game_onlinenumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_onlinenums to fetch.
     */
    orderBy?: Enumerable<Game_onlinenumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Game_onlinenums.
     */
    cursor?: Game_onlinenumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_onlinenums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_onlinenums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Game_onlinenums.
     */
    distinct?: Enumerable<Game_onlinenumScalarFieldEnum>
  }


  /**
   * Game_onlinenum findMany
   */
  export type Game_onlinenumFindManyArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter, which Game_onlinenums to fetch.
     */
    where?: Game_onlinenumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Game_onlinenums to fetch.
     */
    orderBy?: Enumerable<Game_onlinenumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Game_onlinenums.
     */
    cursor?: Game_onlinenumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Game_onlinenums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Game_onlinenums.
     */
    skip?: number
    distinct?: Enumerable<Game_onlinenumScalarFieldEnum>
  }


  /**
   * Game_onlinenum create
   */
  export type Game_onlinenumCreateArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * The data needed to create a Game_onlinenum.
     */
    data: XOR<Game_onlinenumCreateInput, Game_onlinenumUncheckedCreateInput>
  }


  /**
   * Game_onlinenum createMany
   */
  export type Game_onlinenumCreateManyArgs = {
    /**
     * The data used to create many Game_onlinenums.
     */
    data: Enumerable<Game_onlinenumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Game_onlinenum update
   */
  export type Game_onlinenumUpdateArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * The data needed to update a Game_onlinenum.
     */
    data: XOR<Game_onlinenumUpdateInput, Game_onlinenumUncheckedUpdateInput>
    /**
     * Choose, which Game_onlinenum to update.
     */
    where: Game_onlinenumWhereUniqueInput
  }


  /**
   * Game_onlinenum updateMany
   */
  export type Game_onlinenumUpdateManyArgs = {
    /**
     * The data used to update Game_onlinenums.
     */
    data: XOR<Game_onlinenumUpdateManyMutationInput, Game_onlinenumUncheckedUpdateManyInput>
    /**
     * Filter which Game_onlinenums to update
     */
    where?: Game_onlinenumWhereInput
  }


  /**
   * Game_onlinenum upsert
   */
  export type Game_onlinenumUpsertArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * The filter to search for the Game_onlinenum to update in case it exists.
     */
    where: Game_onlinenumWhereUniqueInput
    /**
     * In case the Game_onlinenum found by the `where` argument doesn't exist, create a new Game_onlinenum with this data.
     */
    create: XOR<Game_onlinenumCreateInput, Game_onlinenumUncheckedCreateInput>
    /**
     * In case the Game_onlinenum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Game_onlinenumUpdateInput, Game_onlinenumUncheckedUpdateInput>
  }


  /**
   * Game_onlinenum delete
   */
  export type Game_onlinenumDeleteArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
    /**
     * Filter which Game_onlinenum to delete.
     */
    where: Game_onlinenumWhereUniqueInput
  }


  /**
   * Game_onlinenum deleteMany
   */
  export type Game_onlinenumDeleteManyArgs = {
    /**
     * Filter which Game_onlinenums to delete
     */
    where?: Game_onlinenumWhereInput
  }


  /**
   * Game_onlinenum without action
   */
  export type Game_onlinenumArgs = {
    /**
     * Select specific fields to fetch from the Game_onlinenum
     */
    select?: Game_onlinenumSelect | null
  }



  /**
   * Model Lineout
   */


  export type AggregateLineout = {
    _count: LineoutCountAggregateOutputType | null
    _avg: LineoutAvgAggregateOutputType | null
    _sum: LineoutSumAggregateOutputType | null
    _min: LineoutMinAggregateOutputType | null
    _max: LineoutMaxAggregateOutputType | null
  }

  export type LineoutAvgAggregateOutputType = {
    userId: number | null
  }

  export type LineoutSumAggregateOutputType = {
    userId: number | null
  }

  export type LineoutMinAggregateOutputType = {
    userId: number | null
  }

  export type LineoutMaxAggregateOutputType = {
    userId: number | null
  }

  export type LineoutCountAggregateOutputType = {
    userId: number
    _all: number
  }


  export type LineoutAvgAggregateInputType = {
    userId?: true
  }

  export type LineoutSumAggregateInputType = {
    userId?: true
  }

  export type LineoutMinAggregateInputType = {
    userId?: true
  }

  export type LineoutMaxAggregateInputType = {
    userId?: true
  }

  export type LineoutCountAggregateInputType = {
    userId?: true
    _all?: true
  }

  export type LineoutAggregateArgs = {
    /**
     * Filter which Lineout to aggregate.
     */
    where?: LineoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineouts to fetch.
     */
    orderBy?: Enumerable<LineoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lineouts
    **/
    _count?: true | LineoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineoutMaxAggregateInputType
  }

  export type GetLineoutAggregateType<T extends LineoutAggregateArgs> = {
        [P in keyof T & keyof AggregateLineout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineout[P]>
      : GetScalarType<T[P], AggregateLineout[P]>
  }




  export type LineoutGroupByArgs = {
    where?: LineoutWhereInput
    orderBy?: Enumerable<LineoutOrderByWithAggregationInput>
    by: LineoutScalarFieldEnum[]
    having?: LineoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineoutCountAggregateInputType | true
    _avg?: LineoutAvgAggregateInputType
    _sum?: LineoutSumAggregateInputType
    _min?: LineoutMinAggregateInputType
    _max?: LineoutMaxAggregateInputType
  }


  export type LineoutGroupByOutputType = {
    userId: number
    _count: LineoutCountAggregateOutputType | null
    _avg: LineoutAvgAggregateOutputType | null
    _sum: LineoutSumAggregateOutputType | null
    _min: LineoutMinAggregateOutputType | null
    _max: LineoutMaxAggregateOutputType | null
  }

  type GetLineoutGroupByPayload<T extends LineoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LineoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineoutGroupByOutputType[P]>
            : GetScalarType<T[P], LineoutGroupByOutputType[P]>
        }
      >
    >


  export type LineoutSelect = {
    userId?: boolean
  }


  export type LineoutGetPayload<S extends boolean | null | undefined | LineoutArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Lineout :
    S extends undefined ? never :
    S extends { include: any } & (LineoutArgs | LineoutFindManyArgs)
    ? Lineout 
    : S extends { select: any } & (LineoutArgs | LineoutFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Lineout ? Lineout[P] : never
  } 
      : Lineout


  type LineoutCountArgs = 
    Omit<LineoutFindManyArgs, 'select' | 'include'> & {
      select?: LineoutCountAggregateInputType | true
    }

  export interface LineoutDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Lineout that matches the filter.
     * @param {LineoutFindUniqueArgs} args - Arguments to find a Lineout
     * @example
     * // Get one Lineout
     * const lineout = await prisma.lineout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LineoutFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LineoutFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lineout'> extends True ? Prisma__LineoutClient<LineoutGetPayload<T>> : Prisma__LineoutClient<LineoutGetPayload<T> | null, null>

    /**
     * Find one Lineout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LineoutFindUniqueOrThrowArgs} args - Arguments to find a Lineout
     * @example
     * // Get one Lineout
     * const lineout = await prisma.lineout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LineoutFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LineoutFindUniqueOrThrowArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Find the first Lineout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutFindFirstArgs} args - Arguments to find a Lineout
     * @example
     * // Get one Lineout
     * const lineout = await prisma.lineout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LineoutFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LineoutFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lineout'> extends True ? Prisma__LineoutClient<LineoutGetPayload<T>> : Prisma__LineoutClient<LineoutGetPayload<T> | null, null>

    /**
     * Find the first Lineout that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutFindFirstOrThrowArgs} args - Arguments to find a Lineout
     * @example
     * // Get one Lineout
     * const lineout = await prisma.lineout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LineoutFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LineoutFindFirstOrThrowArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Find zero or more Lineouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lineouts
     * const lineouts = await prisma.lineout.findMany()
     * 
     * // Get first 10 Lineouts
     * const lineouts = await prisma.lineout.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const lineoutWithUserIdOnly = await prisma.lineout.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends LineoutFindManyArgs>(
      args?: SelectSubset<T, LineoutFindManyArgs>
    ): Prisma.PrismaPromise<Array<LineoutGetPayload<T>>>

    /**
     * Create a Lineout.
     * @param {LineoutCreateArgs} args - Arguments to create a Lineout.
     * @example
     * // Create one Lineout
     * const Lineout = await prisma.lineout.create({
     *   data: {
     *     // ... data to create a Lineout
     *   }
     * })
     * 
    **/
    create<T extends LineoutCreateArgs>(
      args: SelectSubset<T, LineoutCreateArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Create many Lineouts.
     *     @param {LineoutCreateManyArgs} args - Arguments to create many Lineouts.
     *     @example
     *     // Create many Lineouts
     *     const lineout = await prisma.lineout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LineoutCreateManyArgs>(
      args?: SelectSubset<T, LineoutCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lineout.
     * @param {LineoutDeleteArgs} args - Arguments to delete one Lineout.
     * @example
     * // Delete one Lineout
     * const Lineout = await prisma.lineout.delete({
     *   where: {
     *     // ... filter to delete one Lineout
     *   }
     * })
     * 
    **/
    delete<T extends LineoutDeleteArgs>(
      args: SelectSubset<T, LineoutDeleteArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Update one Lineout.
     * @param {LineoutUpdateArgs} args - Arguments to update one Lineout.
     * @example
     * // Update one Lineout
     * const lineout = await prisma.lineout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LineoutUpdateArgs>(
      args: SelectSubset<T, LineoutUpdateArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Delete zero or more Lineouts.
     * @param {LineoutDeleteManyArgs} args - Arguments to filter Lineouts to delete.
     * @example
     * // Delete a few Lineouts
     * const { count } = await prisma.lineout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LineoutDeleteManyArgs>(
      args?: SelectSubset<T, LineoutDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lineouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lineouts
     * const lineout = await prisma.lineout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LineoutUpdateManyArgs>(
      args: SelectSubset<T, LineoutUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lineout.
     * @param {LineoutUpsertArgs} args - Arguments to update or create a Lineout.
     * @example
     * // Update or create a Lineout
     * const lineout = await prisma.lineout.upsert({
     *   create: {
     *     // ... data to create a Lineout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lineout we want to update
     *   }
     * })
    **/
    upsert<T extends LineoutUpsertArgs>(
      args: SelectSubset<T, LineoutUpsertArgs>
    ): Prisma__LineoutClient<LineoutGetPayload<T>>

    /**
     * Count the number of Lineouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutCountArgs} args - Arguments to filter Lineouts to count.
     * @example
     * // Count the number of Lineouts
     * const count = await prisma.lineout.count({
     *   where: {
     *     // ... the filter for the Lineouts we want to count
     *   }
     * })
    **/
    count<T extends LineoutCountArgs>(
      args?: Subset<T, LineoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lineout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineoutAggregateArgs>(args: Subset<T, LineoutAggregateArgs>): Prisma.PrismaPromise<GetLineoutAggregateType<T>>

    /**
     * Group by Lineout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineoutGroupByArgs['orderBy'] }
        : { orderBy?: LineoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Lineout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LineoutClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Lineout base type for findUnique actions
   */
  export type LineoutFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter, which Lineout to fetch.
     */
    where: LineoutWhereUniqueInput
  }

  /**
   * Lineout findUnique
   */
  export interface LineoutFindUniqueArgs extends LineoutFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lineout findUniqueOrThrow
   */
  export type LineoutFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter, which Lineout to fetch.
     */
    where: LineoutWhereUniqueInput
  }


  /**
   * Lineout base type for findFirst actions
   */
  export type LineoutFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter, which Lineout to fetch.
     */
    where?: LineoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineouts to fetch.
     */
    orderBy?: Enumerable<LineoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineouts.
     */
    cursor?: LineoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineouts.
     */
    distinct?: Enumerable<LineoutScalarFieldEnum>
  }

  /**
   * Lineout findFirst
   */
  export interface LineoutFindFirstArgs extends LineoutFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lineout findFirstOrThrow
   */
  export type LineoutFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter, which Lineout to fetch.
     */
    where?: LineoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineouts to fetch.
     */
    orderBy?: Enumerable<LineoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineouts.
     */
    cursor?: LineoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineouts.
     */
    distinct?: Enumerable<LineoutScalarFieldEnum>
  }


  /**
   * Lineout findMany
   */
  export type LineoutFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter, which Lineouts to fetch.
     */
    where?: LineoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineouts to fetch.
     */
    orderBy?: Enumerable<LineoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lineouts.
     */
    cursor?: LineoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineouts.
     */
    skip?: number
    distinct?: Enumerable<LineoutScalarFieldEnum>
  }


  /**
   * Lineout create
   */
  export type LineoutCreateArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * The data needed to create a Lineout.
     */
    data: XOR<LineoutCreateInput, LineoutUncheckedCreateInput>
  }


  /**
   * Lineout createMany
   */
  export type LineoutCreateManyArgs = {
    /**
     * The data used to create many Lineouts.
     */
    data: Enumerable<LineoutCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Lineout update
   */
  export type LineoutUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * The data needed to update a Lineout.
     */
    data: XOR<LineoutUpdateInput, LineoutUncheckedUpdateInput>
    /**
     * Choose, which Lineout to update.
     */
    where: LineoutWhereUniqueInput
  }


  /**
   * Lineout updateMany
   */
  export type LineoutUpdateManyArgs = {
    /**
     * The data used to update Lineouts.
     */
    data: XOR<LineoutUpdateManyMutationInput, LineoutUncheckedUpdateManyInput>
    /**
     * Filter which Lineouts to update
     */
    where?: LineoutWhereInput
  }


  /**
   * Lineout upsert
   */
  export type LineoutUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * The filter to search for the Lineout to update in case it exists.
     */
    where: LineoutWhereUniqueInput
    /**
     * In case the Lineout found by the `where` argument doesn't exist, create a new Lineout with this data.
     */
    create: XOR<LineoutCreateInput, LineoutUncheckedCreateInput>
    /**
     * In case the Lineout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineoutUpdateInput, LineoutUncheckedUpdateInput>
  }


  /**
   * Lineout delete
   */
  export type LineoutDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
    /**
     * Filter which Lineout to delete.
     */
    where: LineoutWhereUniqueInput
  }


  /**
   * Lineout deleteMany
   */
  export type LineoutDeleteManyArgs = {
    /**
     * Filter which Lineouts to delete
     */
    where?: LineoutWhereInput
  }


  /**
   * Lineout without action
   */
  export type LineoutArgs = {
    /**
     * Select specific fields to fetch from the Lineout
     */
    select?: LineoutSelect | null
  }



  /**
   * Model Login_history
   */


  export type AggregateLogin_history = {
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  export type Login_historyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    passwordToken: number | null
    score: number | null
  }

  export type Login_historySumAggregateOutputType = {
    id: number | null
    userId: number | null
    passwordToken: number | null
    score: number | null
  }

  export type Login_historyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    loginType: string | null
    loginToken: string | null
    passwordToken: number | null
    score: number | null
    loginDate: Date | null
    loginIp: string | null
  }

  export type Login_historyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    loginType: string | null
    loginToken: string | null
    passwordToken: number | null
    score: number | null
    loginDate: Date | null
    loginIp: string | null
  }

  export type Login_historyCountAggregateOutputType = {
    id: number
    userId: number
    loginType: number
    loginToken: number
    passwordToken: number
    score: number
    loginDate: number
    loginIp: number
    _all: number
  }


  export type Login_historyAvgAggregateInputType = {
    id?: true
    userId?: true
    passwordToken?: true
    score?: true
  }

  export type Login_historySumAggregateInputType = {
    id?: true
    userId?: true
    passwordToken?: true
    score?: true
  }

  export type Login_historyMinAggregateInputType = {
    id?: true
    userId?: true
    loginType?: true
    loginToken?: true
    passwordToken?: true
    score?: true
    loginDate?: true
    loginIp?: true
  }

  export type Login_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    loginType?: true
    loginToken?: true
    passwordToken?: true
    score?: true
    loginDate?: true
    loginIp?: true
  }

  export type Login_historyCountAggregateInputType = {
    id?: true
    userId?: true
    loginType?: true
    loginToken?: true
    passwordToken?: true
    score?: true
    loginDate?: true
    loginIp?: true
    _all?: true
  }

  export type Login_historyAggregateArgs = {
    /**
     * Filter which Login_history to aggregate.
     */
    where?: Login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Login_histories to fetch.
     */
    orderBy?: Enumerable<Login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Login_histories
    **/
    _count?: true | Login_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Login_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Login_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Login_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Login_historyMaxAggregateInputType
  }

  export type GetLogin_historyAggregateType<T extends Login_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin_history[P]>
      : GetScalarType<T[P], AggregateLogin_history[P]>
  }




  export type Login_historyGroupByArgs = {
    where?: Login_historyWhereInput
    orderBy?: Enumerable<Login_historyOrderByWithAggregationInput>
    by: Login_historyScalarFieldEnum[]
    having?: Login_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Login_historyCountAggregateInputType | true
    _avg?: Login_historyAvgAggregateInputType
    _sum?: Login_historySumAggregateInputType
    _min?: Login_historyMinAggregateInputType
    _max?: Login_historyMaxAggregateInputType
  }


  export type Login_historyGroupByOutputType = {
    id: number
    userId: number
    loginType: string
    loginToken: string
    passwordToken: number
    score: number
    loginDate: Date
    loginIp: string
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  type GetLogin_historyGroupByPayload<T extends Login_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Login_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Login_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
        }
      >
    >


  export type Login_historySelect = {
    id?: boolean
    userId?: boolean
    loginType?: boolean
    loginToken?: boolean
    passwordToken?: boolean
    score?: boolean
    loginDate?: boolean
    loginIp?: boolean
  }


  export type Login_historyGetPayload<S extends boolean | null | undefined | Login_historyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Login_history :
    S extends undefined ? never :
    S extends { include: any } & (Login_historyArgs | Login_historyFindManyArgs)
    ? Login_history 
    : S extends { select: any } & (Login_historyArgs | Login_historyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Login_history ? Login_history[P] : never
  } 
      : Login_history


  type Login_historyCountArgs = 
    Omit<Login_historyFindManyArgs, 'select' | 'include'> & {
      select?: Login_historyCountAggregateInputType | true
    }

  export interface Login_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Login_history that matches the filter.
     * @param {Login_historyFindUniqueArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Login_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Login_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Login_history'> extends True ? Prisma__Login_historyClient<Login_historyGetPayload<T>> : Prisma__Login_historyClient<Login_historyGetPayload<T> | null, null>

    /**
     * Find one Login_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Login_historyFindUniqueOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Login_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Login_historyFindUniqueOrThrowArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Find the first Login_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyFindFirstArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Login_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Login_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Login_history'> extends True ? Prisma__Login_historyClient<Login_historyGetPayload<T>> : Prisma__Login_historyClient<Login_historyGetPayload<T> | null, null>

    /**
     * Find the first Login_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyFindFirstOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Login_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Login_historyFindFirstOrThrowArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Find zero or more Login_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Login_histories
     * const login_histories = await prisma.login_history.findMany()
     * 
     * // Get first 10 Login_histories
     * const login_histories = await prisma.login_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const login_historyWithIdOnly = await prisma.login_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Login_historyFindManyArgs>(
      args?: SelectSubset<T, Login_historyFindManyArgs>
    ): Prisma.PrismaPromise<Array<Login_historyGetPayload<T>>>

    /**
     * Create a Login_history.
     * @param {Login_historyCreateArgs} args - Arguments to create a Login_history.
     * @example
     * // Create one Login_history
     * const Login_history = await prisma.login_history.create({
     *   data: {
     *     // ... data to create a Login_history
     *   }
     * })
     * 
    **/
    create<T extends Login_historyCreateArgs>(
      args: SelectSubset<T, Login_historyCreateArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Create many Login_histories.
     *     @param {Login_historyCreateManyArgs} args - Arguments to create many Login_histories.
     *     @example
     *     // Create many Login_histories
     *     const login_history = await prisma.login_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Login_historyCreateManyArgs>(
      args?: SelectSubset<T, Login_historyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Login_history.
     * @param {Login_historyDeleteArgs} args - Arguments to delete one Login_history.
     * @example
     * // Delete one Login_history
     * const Login_history = await prisma.login_history.delete({
     *   where: {
     *     // ... filter to delete one Login_history
     *   }
     * })
     * 
    **/
    delete<T extends Login_historyDeleteArgs>(
      args: SelectSubset<T, Login_historyDeleteArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Update one Login_history.
     * @param {Login_historyUpdateArgs} args - Arguments to update one Login_history.
     * @example
     * // Update one Login_history
     * const login_history = await prisma.login_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Login_historyUpdateArgs>(
      args: SelectSubset<T, Login_historyUpdateArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Delete zero or more Login_histories.
     * @param {Login_historyDeleteManyArgs} args - Arguments to filter Login_histories to delete.
     * @example
     * // Delete a few Login_histories
     * const { count } = await prisma.login_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Login_historyDeleteManyArgs>(
      args?: SelectSubset<T, Login_historyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Login_histories
     * const login_history = await prisma.login_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Login_historyUpdateManyArgs>(
      args: SelectSubset<T, Login_historyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login_history.
     * @param {Login_historyUpsertArgs} args - Arguments to update or create a Login_history.
     * @example
     * // Update or create a Login_history
     * const login_history = await prisma.login_history.upsert({
     *   create: {
     *     // ... data to create a Login_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login_history we want to update
     *   }
     * })
    **/
    upsert<T extends Login_historyUpsertArgs>(
      args: SelectSubset<T, Login_historyUpsertArgs>
    ): Prisma__Login_historyClient<Login_historyGetPayload<T>>

    /**
     * Count the number of Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyCountArgs} args - Arguments to filter Login_histories to count.
     * @example
     * // Count the number of Login_histories
     * const count = await prisma.login_history.count({
     *   where: {
     *     // ... the filter for the Login_histories we want to count
     *   }
     * })
    **/
    count<T extends Login_historyCountArgs>(
      args?: Subset<T, Login_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Login_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Login_historyAggregateArgs>(args: Subset<T, Login_historyAggregateArgs>): Prisma.PrismaPromise<GetLogin_historyAggregateType<T>>

    /**
     * Group by Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Login_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Login_historyGroupByArgs['orderBy'] }
        : { orderBy?: Login_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Login_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogin_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Login_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Login_historyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Login_history base type for findUnique actions
   */
  export type Login_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter, which Login_history to fetch.
     */
    where: Login_historyWhereUniqueInput
  }

  /**
   * Login_history findUnique
   */
  export interface Login_historyFindUniqueArgs extends Login_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Login_history findUniqueOrThrow
   */
  export type Login_historyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter, which Login_history to fetch.
     */
    where: Login_historyWhereUniqueInput
  }


  /**
   * Login_history base type for findFirst actions
   */
  export type Login_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter, which Login_history to fetch.
     */
    where?: Login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Login_histories to fetch.
     */
    orderBy?: Enumerable<Login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Login_histories.
     */
    cursor?: Login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Login_histories.
     */
    distinct?: Enumerable<Login_historyScalarFieldEnum>
  }

  /**
   * Login_history findFirst
   */
  export interface Login_historyFindFirstArgs extends Login_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Login_history findFirstOrThrow
   */
  export type Login_historyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter, which Login_history to fetch.
     */
    where?: Login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Login_histories to fetch.
     */
    orderBy?: Enumerable<Login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Login_histories.
     */
    cursor?: Login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Login_histories.
     */
    distinct?: Enumerable<Login_historyScalarFieldEnum>
  }


  /**
   * Login_history findMany
   */
  export type Login_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter, which Login_histories to fetch.
     */
    where?: Login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Login_histories to fetch.
     */
    orderBy?: Enumerable<Login_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Login_histories.
     */
    cursor?: Login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Login_histories.
     */
    skip?: number
    distinct?: Enumerable<Login_historyScalarFieldEnum>
  }


  /**
   * Login_history create
   */
  export type Login_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * The data needed to create a Login_history.
     */
    data: XOR<Login_historyCreateInput, Login_historyUncheckedCreateInput>
  }


  /**
   * Login_history createMany
   */
  export type Login_historyCreateManyArgs = {
    /**
     * The data used to create many Login_histories.
     */
    data: Enumerable<Login_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Login_history update
   */
  export type Login_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * The data needed to update a Login_history.
     */
    data: XOR<Login_historyUpdateInput, Login_historyUncheckedUpdateInput>
    /**
     * Choose, which Login_history to update.
     */
    where: Login_historyWhereUniqueInput
  }


  /**
   * Login_history updateMany
   */
  export type Login_historyUpdateManyArgs = {
    /**
     * The data used to update Login_histories.
     */
    data: XOR<Login_historyUpdateManyMutationInput, Login_historyUncheckedUpdateManyInput>
    /**
     * Filter which Login_histories to update
     */
    where?: Login_historyWhereInput
  }


  /**
   * Login_history upsert
   */
  export type Login_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * The filter to search for the Login_history to update in case it exists.
     */
    where: Login_historyWhereUniqueInput
    /**
     * In case the Login_history found by the `where` argument doesn't exist, create a new Login_history with this data.
     */
    create: XOR<Login_historyCreateInput, Login_historyUncheckedCreateInput>
    /**
     * In case the Login_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Login_historyUpdateInput, Login_historyUncheckedUpdateInput>
  }


  /**
   * Login_history delete
   */
  export type Login_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
    /**
     * Filter which Login_history to delete.
     */
    where: Login_historyWhereUniqueInput
  }


  /**
   * Login_history deleteMany
   */
  export type Login_historyDeleteManyArgs = {
    /**
     * Filter which Login_histories to delete
     */
    where?: Login_historyWhereInput
  }


  /**
   * Login_history without action
   */
  export type Login_historyArgs = {
    /**
     * Select specific fields to fetch from the Login_history
     */
    select?: Login_historySelect | null
  }



  /**
   * Model Logintemp
   */


  export type AggregateLogintemp = {
    _count: LogintempCountAggregateOutputType | null
    _avg: LogintempAvgAggregateOutputType | null
    _sum: LogintempSumAggregateOutputType | null
    _min: LogintempMinAggregateOutputType | null
    _max: LogintempMaxAggregateOutputType | null
  }

  export type LogintempAvgAggregateOutputType = {
    id: number | null
    loginid: number | null
  }

  export type LogintempSumAggregateOutputType = {
    id: number | null
    loginid: number | null
  }

  export type LogintempMinAggregateOutputType = {
    id: number | null
    loginid: number | null
    logincode: string | null
    loginDate: Date | null
  }

  export type LogintempMaxAggregateOutputType = {
    id: number | null
    loginid: number | null
    logincode: string | null
    loginDate: Date | null
  }

  export type LogintempCountAggregateOutputType = {
    id: number
    loginid: number
    logincode: number
    loginDate: number
    _all: number
  }


  export type LogintempAvgAggregateInputType = {
    id?: true
    loginid?: true
  }

  export type LogintempSumAggregateInputType = {
    id?: true
    loginid?: true
  }

  export type LogintempMinAggregateInputType = {
    id?: true
    loginid?: true
    logincode?: true
    loginDate?: true
  }

  export type LogintempMaxAggregateInputType = {
    id?: true
    loginid?: true
    logincode?: true
    loginDate?: true
  }

  export type LogintempCountAggregateInputType = {
    id?: true
    loginid?: true
    logincode?: true
    loginDate?: true
    _all?: true
  }

  export type LogintempAggregateArgs = {
    /**
     * Filter which Logintemp to aggregate.
     */
    where?: LogintempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logintemps to fetch.
     */
    orderBy?: Enumerable<LogintempOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogintempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logintemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logintemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logintemps
    **/
    _count?: true | LogintempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogintempAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogintempSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogintempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogintempMaxAggregateInputType
  }

  export type GetLogintempAggregateType<T extends LogintempAggregateArgs> = {
        [P in keyof T & keyof AggregateLogintemp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogintemp[P]>
      : GetScalarType<T[P], AggregateLogintemp[P]>
  }




  export type LogintempGroupByArgs = {
    where?: LogintempWhereInput
    orderBy?: Enumerable<LogintempOrderByWithAggregationInput>
    by: LogintempScalarFieldEnum[]
    having?: LogintempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogintempCountAggregateInputType | true
    _avg?: LogintempAvgAggregateInputType
    _sum?: LogintempSumAggregateInputType
    _min?: LogintempMinAggregateInputType
    _max?: LogintempMaxAggregateInputType
  }


  export type LogintempGroupByOutputType = {
    id: number
    loginid: number
    logincode: string
    loginDate: Date
    _count: LogintempCountAggregateOutputType | null
    _avg: LogintempAvgAggregateOutputType | null
    _sum: LogintempSumAggregateOutputType | null
    _min: LogintempMinAggregateOutputType | null
    _max: LogintempMaxAggregateOutputType | null
  }

  type GetLogintempGroupByPayload<T extends LogintempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LogintempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogintempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogintempGroupByOutputType[P]>
            : GetScalarType<T[P], LogintempGroupByOutputType[P]>
        }
      >
    >


  export type LogintempSelect = {
    id?: boolean
    loginid?: boolean
    logincode?: boolean
    loginDate?: boolean
  }


  export type LogintempGetPayload<S extends boolean | null | undefined | LogintempArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Logintemp :
    S extends undefined ? never :
    S extends { include: any } & (LogintempArgs | LogintempFindManyArgs)
    ? Logintemp 
    : S extends { select: any } & (LogintempArgs | LogintempFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Logintemp ? Logintemp[P] : never
  } 
      : Logintemp


  type LogintempCountArgs = 
    Omit<LogintempFindManyArgs, 'select' | 'include'> & {
      select?: LogintempCountAggregateInputType | true
    }

  export interface LogintempDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Logintemp that matches the filter.
     * @param {LogintempFindUniqueArgs} args - Arguments to find a Logintemp
     * @example
     * // Get one Logintemp
     * const logintemp = await prisma.logintemp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogintempFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogintempFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Logintemp'> extends True ? Prisma__LogintempClient<LogintempGetPayload<T>> : Prisma__LogintempClient<LogintempGetPayload<T> | null, null>

    /**
     * Find one Logintemp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogintempFindUniqueOrThrowArgs} args - Arguments to find a Logintemp
     * @example
     * // Get one Logintemp
     * const logintemp = await prisma.logintemp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogintempFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LogintempFindUniqueOrThrowArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Find the first Logintemp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempFindFirstArgs} args - Arguments to find a Logintemp
     * @example
     * // Get one Logintemp
     * const logintemp = await prisma.logintemp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogintempFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogintempFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Logintemp'> extends True ? Prisma__LogintempClient<LogintempGetPayload<T>> : Prisma__LogintempClient<LogintempGetPayload<T> | null, null>

    /**
     * Find the first Logintemp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempFindFirstOrThrowArgs} args - Arguments to find a Logintemp
     * @example
     * // Get one Logintemp
     * const logintemp = await prisma.logintemp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogintempFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LogintempFindFirstOrThrowArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Find zero or more Logintemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logintemps
     * const logintemps = await prisma.logintemp.findMany()
     * 
     * // Get first 10 Logintemps
     * const logintemps = await prisma.logintemp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logintempWithIdOnly = await prisma.logintemp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogintempFindManyArgs>(
      args?: SelectSubset<T, LogintempFindManyArgs>
    ): Prisma.PrismaPromise<Array<LogintempGetPayload<T>>>

    /**
     * Create a Logintemp.
     * @param {LogintempCreateArgs} args - Arguments to create a Logintemp.
     * @example
     * // Create one Logintemp
     * const Logintemp = await prisma.logintemp.create({
     *   data: {
     *     // ... data to create a Logintemp
     *   }
     * })
     * 
    **/
    create<T extends LogintempCreateArgs>(
      args: SelectSubset<T, LogintempCreateArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Create many Logintemps.
     *     @param {LogintempCreateManyArgs} args - Arguments to create many Logintemps.
     *     @example
     *     // Create many Logintemps
     *     const logintemp = await prisma.logintemp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogintempCreateManyArgs>(
      args?: SelectSubset<T, LogintempCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logintemp.
     * @param {LogintempDeleteArgs} args - Arguments to delete one Logintemp.
     * @example
     * // Delete one Logintemp
     * const Logintemp = await prisma.logintemp.delete({
     *   where: {
     *     // ... filter to delete one Logintemp
     *   }
     * })
     * 
    **/
    delete<T extends LogintempDeleteArgs>(
      args: SelectSubset<T, LogintempDeleteArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Update one Logintemp.
     * @param {LogintempUpdateArgs} args - Arguments to update one Logintemp.
     * @example
     * // Update one Logintemp
     * const logintemp = await prisma.logintemp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogintempUpdateArgs>(
      args: SelectSubset<T, LogintempUpdateArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Delete zero or more Logintemps.
     * @param {LogintempDeleteManyArgs} args - Arguments to filter Logintemps to delete.
     * @example
     * // Delete a few Logintemps
     * const { count } = await prisma.logintemp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogintempDeleteManyArgs>(
      args?: SelectSubset<T, LogintempDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logintemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logintemps
     * const logintemp = await prisma.logintemp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogintempUpdateManyArgs>(
      args: SelectSubset<T, LogintempUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logintemp.
     * @param {LogintempUpsertArgs} args - Arguments to update or create a Logintemp.
     * @example
     * // Update or create a Logintemp
     * const logintemp = await prisma.logintemp.upsert({
     *   create: {
     *     // ... data to create a Logintemp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logintemp we want to update
     *   }
     * })
    **/
    upsert<T extends LogintempUpsertArgs>(
      args: SelectSubset<T, LogintempUpsertArgs>
    ): Prisma__LogintempClient<LogintempGetPayload<T>>

    /**
     * Count the number of Logintemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempCountArgs} args - Arguments to filter Logintemps to count.
     * @example
     * // Count the number of Logintemps
     * const count = await prisma.logintemp.count({
     *   where: {
     *     // ... the filter for the Logintemps we want to count
     *   }
     * })
    **/
    count<T extends LogintempCountArgs>(
      args?: Subset<T, LogintempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogintempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logintemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogintempAggregateArgs>(args: Subset<T, LogintempAggregateArgs>): Prisma.PrismaPromise<GetLogintempAggregateType<T>>

    /**
     * Group by Logintemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogintempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogintempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogintempGroupByArgs['orderBy'] }
        : { orderBy?: LogintempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogintempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogintempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Logintemp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogintempClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Logintemp base type for findUnique actions
   */
  export type LogintempFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter, which Logintemp to fetch.
     */
    where: LogintempWhereUniqueInput
  }

  /**
   * Logintemp findUnique
   */
  export interface LogintempFindUniqueArgs extends LogintempFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logintemp findUniqueOrThrow
   */
  export type LogintempFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter, which Logintemp to fetch.
     */
    where: LogintempWhereUniqueInput
  }


  /**
   * Logintemp base type for findFirst actions
   */
  export type LogintempFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter, which Logintemp to fetch.
     */
    where?: LogintempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logintemps to fetch.
     */
    orderBy?: Enumerable<LogintempOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logintemps.
     */
    cursor?: LogintempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logintemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logintemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logintemps.
     */
    distinct?: Enumerable<LogintempScalarFieldEnum>
  }

  /**
   * Logintemp findFirst
   */
  export interface LogintempFindFirstArgs extends LogintempFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logintemp findFirstOrThrow
   */
  export type LogintempFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter, which Logintemp to fetch.
     */
    where?: LogintempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logintemps to fetch.
     */
    orderBy?: Enumerable<LogintempOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logintemps.
     */
    cursor?: LogintempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logintemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logintemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logintemps.
     */
    distinct?: Enumerable<LogintempScalarFieldEnum>
  }


  /**
   * Logintemp findMany
   */
  export type LogintempFindManyArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter, which Logintemps to fetch.
     */
    where?: LogintempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logintemps to fetch.
     */
    orderBy?: Enumerable<LogintempOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logintemps.
     */
    cursor?: LogintempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logintemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logintemps.
     */
    skip?: number
    distinct?: Enumerable<LogintempScalarFieldEnum>
  }


  /**
   * Logintemp create
   */
  export type LogintempCreateArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * The data needed to create a Logintemp.
     */
    data: XOR<LogintempCreateInput, LogintempUncheckedCreateInput>
  }


  /**
   * Logintemp createMany
   */
  export type LogintempCreateManyArgs = {
    /**
     * The data used to create many Logintemps.
     */
    data: Enumerable<LogintempCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Logintemp update
   */
  export type LogintempUpdateArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * The data needed to update a Logintemp.
     */
    data: XOR<LogintempUpdateInput, LogintempUncheckedUpdateInput>
    /**
     * Choose, which Logintemp to update.
     */
    where: LogintempWhereUniqueInput
  }


  /**
   * Logintemp updateMany
   */
  export type LogintempUpdateManyArgs = {
    /**
     * The data used to update Logintemps.
     */
    data: XOR<LogintempUpdateManyMutationInput, LogintempUncheckedUpdateManyInput>
    /**
     * Filter which Logintemps to update
     */
    where?: LogintempWhereInput
  }


  /**
   * Logintemp upsert
   */
  export type LogintempUpsertArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * The filter to search for the Logintemp to update in case it exists.
     */
    where: LogintempWhereUniqueInput
    /**
     * In case the Logintemp found by the `where` argument doesn't exist, create a new Logintemp with this data.
     */
    create: XOR<LogintempCreateInput, LogintempUncheckedCreateInput>
    /**
     * In case the Logintemp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogintempUpdateInput, LogintempUncheckedUpdateInput>
  }


  /**
   * Logintemp delete
   */
  export type LogintempDeleteArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
    /**
     * Filter which Logintemp to delete.
     */
    where: LogintempWhereUniqueInput
  }


  /**
   * Logintemp deleteMany
   */
  export type LogintempDeleteManyArgs = {
    /**
     * Filter which Logintemps to delete
     */
    where?: LogintempWhereInput
  }


  /**
   * Logintemp without action
   */
  export type LogintempArgs = {
    /**
     * Select specific fields to fetch from the Logintemp
     */
    select?: LogintempSelect | null
  }



  /**
   * Model Logout_history
   */


  export type AggregateLogout_history = {
    _count: Logout_historyCountAggregateOutputType | null
    _avg: Logout_historyAvgAggregateOutputType | null
    _sum: Logout_historySumAggregateOutputType | null
    _min: Logout_historyMinAggregateOutputType | null
    _max: Logout_historyMaxAggregateOutputType | null
  }

  export type Logout_historyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    logoutType: number | null
    score: number | null
  }

  export type Logout_historySumAggregateOutputType = {
    id: number | null
    userId: number | null
    logoutType: number | null
    score: number | null
  }

  export type Logout_historyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    logoutType: number | null
    score: number | null
    logoutDate: Date | null
    logoutIp: string | null
  }

  export type Logout_historyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    logoutType: number | null
    score: number | null
    logoutDate: Date | null
    logoutIp: string | null
  }

  export type Logout_historyCountAggregateOutputType = {
    id: number
    userId: number
    logoutType: number
    score: number
    logoutDate: number
    logoutIp: number
    _all: number
  }


  export type Logout_historyAvgAggregateInputType = {
    id?: true
    userId?: true
    logoutType?: true
    score?: true
  }

  export type Logout_historySumAggregateInputType = {
    id?: true
    userId?: true
    logoutType?: true
    score?: true
  }

  export type Logout_historyMinAggregateInputType = {
    id?: true
    userId?: true
    logoutType?: true
    score?: true
    logoutDate?: true
    logoutIp?: true
  }

  export type Logout_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    logoutType?: true
    score?: true
    logoutDate?: true
    logoutIp?: true
  }

  export type Logout_historyCountAggregateInputType = {
    id?: true
    userId?: true
    logoutType?: true
    score?: true
    logoutDate?: true
    logoutIp?: true
    _all?: true
  }

  export type Logout_historyAggregateArgs = {
    /**
     * Filter which Logout_history to aggregate.
     */
    where?: Logout_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logout_histories to fetch.
     */
    orderBy?: Enumerable<Logout_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Logout_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logout_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logout_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logout_histories
    **/
    _count?: true | Logout_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logout_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logout_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logout_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logout_historyMaxAggregateInputType
  }

  export type GetLogout_historyAggregateType<T extends Logout_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateLogout_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogout_history[P]>
      : GetScalarType<T[P], AggregateLogout_history[P]>
  }




  export type Logout_historyGroupByArgs = {
    where?: Logout_historyWhereInput
    orderBy?: Enumerable<Logout_historyOrderByWithAggregationInput>
    by: Logout_historyScalarFieldEnum[]
    having?: Logout_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logout_historyCountAggregateInputType | true
    _avg?: Logout_historyAvgAggregateInputType
    _sum?: Logout_historySumAggregateInputType
    _min?: Logout_historyMinAggregateInputType
    _max?: Logout_historyMaxAggregateInputType
  }


  export type Logout_historyGroupByOutputType = {
    id: number
    userId: number
    logoutType: number
    score: number
    logoutDate: Date
    logoutIp: string
    _count: Logout_historyCountAggregateOutputType | null
    _avg: Logout_historyAvgAggregateOutputType | null
    _sum: Logout_historySumAggregateOutputType | null
    _min: Logout_historyMinAggregateOutputType | null
    _max: Logout_historyMaxAggregateOutputType | null
  }

  type GetLogout_historyGroupByPayload<T extends Logout_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Logout_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logout_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logout_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Logout_historyGroupByOutputType[P]>
        }
      >
    >


  export type Logout_historySelect = {
    id?: boolean
    userId?: boolean
    logoutType?: boolean
    score?: boolean
    logoutDate?: boolean
    logoutIp?: boolean
  }


  export type Logout_historyGetPayload<S extends boolean | null | undefined | Logout_historyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Logout_history :
    S extends undefined ? never :
    S extends { include: any } & (Logout_historyArgs | Logout_historyFindManyArgs)
    ? Logout_history 
    : S extends { select: any } & (Logout_historyArgs | Logout_historyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Logout_history ? Logout_history[P] : never
  } 
      : Logout_history


  type Logout_historyCountArgs = 
    Omit<Logout_historyFindManyArgs, 'select' | 'include'> & {
      select?: Logout_historyCountAggregateInputType | true
    }

  export interface Logout_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Logout_history that matches the filter.
     * @param {Logout_historyFindUniqueArgs} args - Arguments to find a Logout_history
     * @example
     * // Get one Logout_history
     * const logout_history = await prisma.logout_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Logout_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Logout_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Logout_history'> extends True ? Prisma__Logout_historyClient<Logout_historyGetPayload<T>> : Prisma__Logout_historyClient<Logout_historyGetPayload<T> | null, null>

    /**
     * Find one Logout_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Logout_historyFindUniqueOrThrowArgs} args - Arguments to find a Logout_history
     * @example
     * // Get one Logout_history
     * const logout_history = await prisma.logout_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Logout_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Logout_historyFindUniqueOrThrowArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Find the first Logout_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyFindFirstArgs} args - Arguments to find a Logout_history
     * @example
     * // Get one Logout_history
     * const logout_history = await prisma.logout_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Logout_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Logout_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Logout_history'> extends True ? Prisma__Logout_historyClient<Logout_historyGetPayload<T>> : Prisma__Logout_historyClient<Logout_historyGetPayload<T> | null, null>

    /**
     * Find the first Logout_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyFindFirstOrThrowArgs} args - Arguments to find a Logout_history
     * @example
     * // Get one Logout_history
     * const logout_history = await prisma.logout_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Logout_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Logout_historyFindFirstOrThrowArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Find zero or more Logout_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logout_histories
     * const logout_histories = await prisma.logout_history.findMany()
     * 
     * // Get first 10 Logout_histories
     * const logout_histories = await prisma.logout_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logout_historyWithIdOnly = await prisma.logout_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Logout_historyFindManyArgs>(
      args?: SelectSubset<T, Logout_historyFindManyArgs>
    ): Prisma.PrismaPromise<Array<Logout_historyGetPayload<T>>>

    /**
     * Create a Logout_history.
     * @param {Logout_historyCreateArgs} args - Arguments to create a Logout_history.
     * @example
     * // Create one Logout_history
     * const Logout_history = await prisma.logout_history.create({
     *   data: {
     *     // ... data to create a Logout_history
     *   }
     * })
     * 
    **/
    create<T extends Logout_historyCreateArgs>(
      args: SelectSubset<T, Logout_historyCreateArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Create many Logout_histories.
     *     @param {Logout_historyCreateManyArgs} args - Arguments to create many Logout_histories.
     *     @example
     *     // Create many Logout_histories
     *     const logout_history = await prisma.logout_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Logout_historyCreateManyArgs>(
      args?: SelectSubset<T, Logout_historyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logout_history.
     * @param {Logout_historyDeleteArgs} args - Arguments to delete one Logout_history.
     * @example
     * // Delete one Logout_history
     * const Logout_history = await prisma.logout_history.delete({
     *   where: {
     *     // ... filter to delete one Logout_history
     *   }
     * })
     * 
    **/
    delete<T extends Logout_historyDeleteArgs>(
      args: SelectSubset<T, Logout_historyDeleteArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Update one Logout_history.
     * @param {Logout_historyUpdateArgs} args - Arguments to update one Logout_history.
     * @example
     * // Update one Logout_history
     * const logout_history = await prisma.logout_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Logout_historyUpdateArgs>(
      args: SelectSubset<T, Logout_historyUpdateArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Delete zero or more Logout_histories.
     * @param {Logout_historyDeleteManyArgs} args - Arguments to filter Logout_histories to delete.
     * @example
     * // Delete a few Logout_histories
     * const { count } = await prisma.logout_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Logout_historyDeleteManyArgs>(
      args?: SelectSubset<T, Logout_historyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logout_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logout_histories
     * const logout_history = await prisma.logout_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Logout_historyUpdateManyArgs>(
      args: SelectSubset<T, Logout_historyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logout_history.
     * @param {Logout_historyUpsertArgs} args - Arguments to update or create a Logout_history.
     * @example
     * // Update or create a Logout_history
     * const logout_history = await prisma.logout_history.upsert({
     *   create: {
     *     // ... data to create a Logout_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logout_history we want to update
     *   }
     * })
    **/
    upsert<T extends Logout_historyUpsertArgs>(
      args: SelectSubset<T, Logout_historyUpsertArgs>
    ): Prisma__Logout_historyClient<Logout_historyGetPayload<T>>

    /**
     * Count the number of Logout_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyCountArgs} args - Arguments to filter Logout_histories to count.
     * @example
     * // Count the number of Logout_histories
     * const count = await prisma.logout_history.count({
     *   where: {
     *     // ... the filter for the Logout_histories we want to count
     *   }
     * })
    **/
    count<T extends Logout_historyCountArgs>(
      args?: Subset<T, Logout_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logout_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logout_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logout_historyAggregateArgs>(args: Subset<T, Logout_historyAggregateArgs>): Prisma.PrismaPromise<GetLogout_historyAggregateType<T>>

    /**
     * Group by Logout_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logout_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Logout_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Logout_historyGroupByArgs['orderBy'] }
        : { orderBy?: Logout_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Logout_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogout_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Logout_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Logout_historyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Logout_history base type for findUnique actions
   */
  export type Logout_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter, which Logout_history to fetch.
     */
    where: Logout_historyWhereUniqueInput
  }

  /**
   * Logout_history findUnique
   */
  export interface Logout_historyFindUniqueArgs extends Logout_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logout_history findUniqueOrThrow
   */
  export type Logout_historyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter, which Logout_history to fetch.
     */
    where: Logout_historyWhereUniqueInput
  }


  /**
   * Logout_history base type for findFirst actions
   */
  export type Logout_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter, which Logout_history to fetch.
     */
    where?: Logout_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logout_histories to fetch.
     */
    orderBy?: Enumerable<Logout_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logout_histories.
     */
    cursor?: Logout_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logout_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logout_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logout_histories.
     */
    distinct?: Enumerable<Logout_historyScalarFieldEnum>
  }

  /**
   * Logout_history findFirst
   */
  export interface Logout_historyFindFirstArgs extends Logout_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logout_history findFirstOrThrow
   */
  export type Logout_historyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter, which Logout_history to fetch.
     */
    where?: Logout_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logout_histories to fetch.
     */
    orderBy?: Enumerable<Logout_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logout_histories.
     */
    cursor?: Logout_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logout_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logout_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logout_histories.
     */
    distinct?: Enumerable<Logout_historyScalarFieldEnum>
  }


  /**
   * Logout_history findMany
   */
  export type Logout_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter, which Logout_histories to fetch.
     */
    where?: Logout_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logout_histories to fetch.
     */
    orderBy?: Enumerable<Logout_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logout_histories.
     */
    cursor?: Logout_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logout_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logout_histories.
     */
    skip?: number
    distinct?: Enumerable<Logout_historyScalarFieldEnum>
  }


  /**
   * Logout_history create
   */
  export type Logout_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * The data needed to create a Logout_history.
     */
    data: XOR<Logout_historyCreateInput, Logout_historyUncheckedCreateInput>
  }


  /**
   * Logout_history createMany
   */
  export type Logout_historyCreateManyArgs = {
    /**
     * The data used to create many Logout_histories.
     */
    data: Enumerable<Logout_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Logout_history update
   */
  export type Logout_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * The data needed to update a Logout_history.
     */
    data: XOR<Logout_historyUpdateInput, Logout_historyUncheckedUpdateInput>
    /**
     * Choose, which Logout_history to update.
     */
    where: Logout_historyWhereUniqueInput
  }


  /**
   * Logout_history updateMany
   */
  export type Logout_historyUpdateManyArgs = {
    /**
     * The data used to update Logout_histories.
     */
    data: XOR<Logout_historyUpdateManyMutationInput, Logout_historyUncheckedUpdateManyInput>
    /**
     * Filter which Logout_histories to update
     */
    where?: Logout_historyWhereInput
  }


  /**
   * Logout_history upsert
   */
  export type Logout_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * The filter to search for the Logout_history to update in case it exists.
     */
    where: Logout_historyWhereUniqueInput
    /**
     * In case the Logout_history found by the `where` argument doesn't exist, create a new Logout_history with this data.
     */
    create: XOR<Logout_historyCreateInput, Logout_historyUncheckedCreateInput>
    /**
     * In case the Logout_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Logout_historyUpdateInput, Logout_historyUncheckedUpdateInput>
  }


  /**
   * Logout_history delete
   */
  export type Logout_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
    /**
     * Filter which Logout_history to delete.
     */
    where: Logout_historyWhereUniqueInput
  }


  /**
   * Logout_history deleteMany
   */
  export type Logout_historyDeleteManyArgs = {
    /**
     * Filter which Logout_histories to delete
     */
    where?: Logout_historyWhereInput
  }


  /**
   * Logout_history without action
   */
  export type Logout_historyArgs = {
    /**
     * Select specific fields to fetch from the Logout_history
     */
    select?: Logout_historySelect | null
  }



  /**
   * Model Mark
   */


  export type AggregateMark = {
    _count: MarkCountAggregateOutputType | null
    _avg: MarkAvgAggregateOutputType | null
    _sum: MarkSumAggregateOutputType | null
    _min: MarkMinAggregateOutputType | null
    _max: MarkMaxAggregateOutputType | null
  }

  export type MarkAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    useCoin: number | null
    winCoin: number | null
    tax: number | null
    gameId: number | null
    serverId: number | null
    mark: number | null
  }

  export type MarkSumAggregateOutputType = {
    id: number | null
    userId: number | null
    useCoin: number | null
    winCoin: number | null
    tax: number | null
    gameId: number | null
    serverId: number | null
    mark: number | null
  }

  export type MarkMinAggregateOutputType = {
    id: number | null
    userId: number | null
    useCoin: number | null
    winCoin: number | null
    tax: number | null
    gameId: number | null
    serverId: number | null
    balanceTime: Date | null
    mark: number | null
  }

  export type MarkMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    useCoin: number | null
    winCoin: number | null
    tax: number | null
    gameId: number | null
    serverId: number | null
    balanceTime: Date | null
    mark: number | null
  }

  export type MarkCountAggregateOutputType = {
    id: number
    userId: number
    useCoin: number
    winCoin: number
    tax: number
    gameId: number
    serverId: number
    balanceTime: number
    mark: number
    _all: number
  }


  export type MarkAvgAggregateInputType = {
    id?: true
    userId?: true
    useCoin?: true
    winCoin?: true
    tax?: true
    gameId?: true
    serverId?: true
    mark?: true
  }

  export type MarkSumAggregateInputType = {
    id?: true
    userId?: true
    useCoin?: true
    winCoin?: true
    tax?: true
    gameId?: true
    serverId?: true
    mark?: true
  }

  export type MarkMinAggregateInputType = {
    id?: true
    userId?: true
    useCoin?: true
    winCoin?: true
    tax?: true
    gameId?: true
    serverId?: true
    balanceTime?: true
    mark?: true
  }

  export type MarkMaxAggregateInputType = {
    id?: true
    userId?: true
    useCoin?: true
    winCoin?: true
    tax?: true
    gameId?: true
    serverId?: true
    balanceTime?: true
    mark?: true
  }

  export type MarkCountAggregateInputType = {
    id?: true
    userId?: true
    useCoin?: true
    winCoin?: true
    tax?: true
    gameId?: true
    serverId?: true
    balanceTime?: true
    mark?: true
    _all?: true
  }

  export type MarkAggregateArgs = {
    /**
     * Filter which Mark to aggregate.
     */
    where?: MarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marks to fetch.
     */
    orderBy?: Enumerable<MarkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marks
    **/
    _count?: true | MarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarkMaxAggregateInputType
  }

  export type GetMarkAggregateType<T extends MarkAggregateArgs> = {
        [P in keyof T & keyof AggregateMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMark[P]>
      : GetScalarType<T[P], AggregateMark[P]>
  }




  export type MarkGroupByArgs = {
    where?: MarkWhereInput
    orderBy?: Enumerable<MarkOrderByWithAggregationInput>
    by: MarkScalarFieldEnum[]
    having?: MarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarkCountAggregateInputType | true
    _avg?: MarkAvgAggregateInputType
    _sum?: MarkSumAggregateInputType
    _min?: MarkMinAggregateInputType
    _max?: MarkMaxAggregateInputType
  }


  export type MarkGroupByOutputType = {
    id: number
    userId: number
    useCoin: number
    winCoin: number
    tax: number
    gameId: number
    serverId: number
    balanceTime: Date
    mark: number
    _count: MarkCountAggregateOutputType | null
    _avg: MarkAvgAggregateOutputType | null
    _sum: MarkSumAggregateOutputType | null
    _min: MarkMinAggregateOutputType | null
    _max: MarkMaxAggregateOutputType | null
  }

  type GetMarkGroupByPayload<T extends MarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarkGroupByOutputType[P]>
            : GetScalarType<T[P], MarkGroupByOutputType[P]>
        }
      >
    >


  export type MarkSelect = {
    id?: boolean
    userId?: boolean
    useCoin?: boolean
    winCoin?: boolean
    tax?: boolean
    gameId?: boolean
    serverId?: boolean
    balanceTime?: boolean
    mark?: boolean
  }


  export type MarkGetPayload<S extends boolean | null | undefined | MarkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Mark :
    S extends undefined ? never :
    S extends { include: any } & (MarkArgs | MarkFindManyArgs)
    ? Mark 
    : S extends { select: any } & (MarkArgs | MarkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Mark ? Mark[P] : never
  } 
      : Mark


  type MarkCountArgs = 
    Omit<MarkFindManyArgs, 'select' | 'include'> & {
      select?: MarkCountAggregateInputType | true
    }

  export interface MarkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Mark that matches the filter.
     * @param {MarkFindUniqueArgs} args - Arguments to find a Mark
     * @example
     * // Get one Mark
     * const mark = await prisma.mark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Mark'> extends True ? Prisma__MarkClient<MarkGetPayload<T>> : Prisma__MarkClient<MarkGetPayload<T> | null, null>

    /**
     * Find one Mark that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarkFindUniqueOrThrowArgs} args - Arguments to find a Mark
     * @example
     * // Get one Mark
     * const mark = await prisma.mark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarkFindUniqueOrThrowArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Find the first Mark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkFindFirstArgs} args - Arguments to find a Mark
     * @example
     * // Get one Mark
     * const mark = await prisma.mark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Mark'> extends True ? Prisma__MarkClient<MarkGetPayload<T>> : Prisma__MarkClient<MarkGetPayload<T> | null, null>

    /**
     * Find the first Mark that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkFindFirstOrThrowArgs} args - Arguments to find a Mark
     * @example
     * // Get one Mark
     * const mark = await prisma.mark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarkFindFirstOrThrowArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Find zero or more Marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marks
     * const marks = await prisma.mark.findMany()
     * 
     * // Get first 10 Marks
     * const marks = await prisma.mark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const markWithIdOnly = await prisma.mark.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarkFindManyArgs>(
      args?: SelectSubset<T, MarkFindManyArgs>
    ): Prisma.PrismaPromise<Array<MarkGetPayload<T>>>

    /**
     * Create a Mark.
     * @param {MarkCreateArgs} args - Arguments to create a Mark.
     * @example
     * // Create one Mark
     * const Mark = await prisma.mark.create({
     *   data: {
     *     // ... data to create a Mark
     *   }
     * })
     * 
    **/
    create<T extends MarkCreateArgs>(
      args: SelectSubset<T, MarkCreateArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Create many Marks.
     *     @param {MarkCreateManyArgs} args - Arguments to create many Marks.
     *     @example
     *     // Create many Marks
     *     const mark = await prisma.mark.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarkCreateManyArgs>(
      args?: SelectSubset<T, MarkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mark.
     * @param {MarkDeleteArgs} args - Arguments to delete one Mark.
     * @example
     * // Delete one Mark
     * const Mark = await prisma.mark.delete({
     *   where: {
     *     // ... filter to delete one Mark
     *   }
     * })
     * 
    **/
    delete<T extends MarkDeleteArgs>(
      args: SelectSubset<T, MarkDeleteArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Update one Mark.
     * @param {MarkUpdateArgs} args - Arguments to update one Mark.
     * @example
     * // Update one Mark
     * const mark = await prisma.mark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarkUpdateArgs>(
      args: SelectSubset<T, MarkUpdateArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Delete zero or more Marks.
     * @param {MarkDeleteManyArgs} args - Arguments to filter Marks to delete.
     * @example
     * // Delete a few Marks
     * const { count } = await prisma.mark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarkDeleteManyArgs>(
      args?: SelectSubset<T, MarkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marks
     * const mark = await prisma.mark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarkUpdateManyArgs>(
      args: SelectSubset<T, MarkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mark.
     * @param {MarkUpsertArgs} args - Arguments to update or create a Mark.
     * @example
     * // Update or create a Mark
     * const mark = await prisma.mark.upsert({
     *   create: {
     *     // ... data to create a Mark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mark we want to update
     *   }
     * })
    **/
    upsert<T extends MarkUpsertArgs>(
      args: SelectSubset<T, MarkUpsertArgs>
    ): Prisma__MarkClient<MarkGetPayload<T>>

    /**
     * Count the number of Marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkCountArgs} args - Arguments to filter Marks to count.
     * @example
     * // Count the number of Marks
     * const count = await prisma.mark.count({
     *   where: {
     *     // ... the filter for the Marks we want to count
     *   }
     * })
    **/
    count<T extends MarkCountArgs>(
      args?: Subset<T, MarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarkAggregateArgs>(args: Subset<T, MarkAggregateArgs>): Prisma.PrismaPromise<GetMarkAggregateType<T>>

    /**
     * Group by Mark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarkGroupByArgs['orderBy'] }
        : { orderBy?: MarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Mark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Mark base type for findUnique actions
   */
  export type MarkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter, which Mark to fetch.
     */
    where: MarkWhereUniqueInput
  }

  /**
   * Mark findUnique
   */
  export interface MarkFindUniqueArgs extends MarkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mark findUniqueOrThrow
   */
  export type MarkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter, which Mark to fetch.
     */
    where: MarkWhereUniqueInput
  }


  /**
   * Mark base type for findFirst actions
   */
  export type MarkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter, which Mark to fetch.
     */
    where?: MarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marks to fetch.
     */
    orderBy?: Enumerable<MarkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marks.
     */
    cursor?: MarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marks.
     */
    distinct?: Enumerable<MarkScalarFieldEnum>
  }

  /**
   * Mark findFirst
   */
  export interface MarkFindFirstArgs extends MarkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mark findFirstOrThrow
   */
  export type MarkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter, which Mark to fetch.
     */
    where?: MarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marks to fetch.
     */
    orderBy?: Enumerable<MarkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marks.
     */
    cursor?: MarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marks.
     */
    distinct?: Enumerable<MarkScalarFieldEnum>
  }


  /**
   * Mark findMany
   */
  export type MarkFindManyArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter, which Marks to fetch.
     */
    where?: MarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marks to fetch.
     */
    orderBy?: Enumerable<MarkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marks.
     */
    cursor?: MarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marks.
     */
    skip?: number
    distinct?: Enumerable<MarkScalarFieldEnum>
  }


  /**
   * Mark create
   */
  export type MarkCreateArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * The data needed to create a Mark.
     */
    data: XOR<MarkCreateInput, MarkUncheckedCreateInput>
  }


  /**
   * Mark createMany
   */
  export type MarkCreateManyArgs = {
    /**
     * The data used to create many Marks.
     */
    data: Enumerable<MarkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Mark update
   */
  export type MarkUpdateArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * The data needed to update a Mark.
     */
    data: XOR<MarkUpdateInput, MarkUncheckedUpdateInput>
    /**
     * Choose, which Mark to update.
     */
    where: MarkWhereUniqueInput
  }


  /**
   * Mark updateMany
   */
  export type MarkUpdateManyArgs = {
    /**
     * The data used to update Marks.
     */
    data: XOR<MarkUpdateManyMutationInput, MarkUncheckedUpdateManyInput>
    /**
     * Filter which Marks to update
     */
    where?: MarkWhereInput
  }


  /**
   * Mark upsert
   */
  export type MarkUpsertArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * The filter to search for the Mark to update in case it exists.
     */
    where: MarkWhereUniqueInput
    /**
     * In case the Mark found by the `where` argument doesn't exist, create a new Mark with this data.
     */
    create: XOR<MarkCreateInput, MarkUncheckedCreateInput>
    /**
     * In case the Mark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarkUpdateInput, MarkUncheckedUpdateInput>
  }


  /**
   * Mark delete
   */
  export type MarkDeleteArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
    /**
     * Filter which Mark to delete.
     */
    where: MarkWhereUniqueInput
  }


  /**
   * Mark deleteMany
   */
  export type MarkDeleteManyArgs = {
    /**
     * Filter which Marks to delete
     */
    where?: MarkWhereInput
  }


  /**
   * Mark without action
   */
  export type MarkArgs = {
    /**
     * Select specific fields to fetch from the Mark
     */
    select?: MarkSelect | null
  }



  /**
   * Model Msg
   */


  export type AggregateMsg = {
    _count: MsgCountAggregateOutputType | null
    _avg: MsgAvgAggregateOutputType | null
    _sum: MsgSumAggregateOutputType | null
    _min: MsgMinAggregateOutputType | null
    _max: MsgMaxAggregateOutputType | null
  }

  export type MsgAvgAggregateOutputType = {
    msgId: number | null
    userId: number | null
    winPropId: number | null
    winPropCount: number | null
    winScore: number | null
    matchlogId: number | null
    isGetPrize: number | null
    type: number | null
    sendCoinUserId: number | null
  }

  export type MsgSumAggregateOutputType = {
    msgId: number | null
    userId: number | null
    winPropId: number | null
    winPropCount: number | null
    winScore: number | null
    matchlogId: number | null
    isGetPrize: number | null
    type: number | null
    sendCoinUserId: number | null
  }

  export type MsgMinAggregateOutputType = {
    msgId: number | null
    userId: number | null
    winPropId: number | null
    winPropCount: number | null
    winScore: number | null
    matchlogId: number | null
    isGetPrize: number | null
    type: number | null
    AddDate: Date | null
    sendCoinUserId: number | null
    nickName: string | null
  }

  export type MsgMaxAggregateOutputType = {
    msgId: number | null
    userId: number | null
    winPropId: number | null
    winPropCount: number | null
    winScore: number | null
    matchlogId: number | null
    isGetPrize: number | null
    type: number | null
    AddDate: Date | null
    sendCoinUserId: number | null
    nickName: string | null
  }

  export type MsgCountAggregateOutputType = {
    msgId: number
    userId: number
    winPropId: number
    winPropCount: number
    winScore: number
    matchlogId: number
    isGetPrize: number
    type: number
    AddDate: number
    sendCoinUserId: number
    nickName: number
    _all: number
  }


  export type MsgAvgAggregateInputType = {
    msgId?: true
    userId?: true
    winPropId?: true
    winPropCount?: true
    winScore?: true
    matchlogId?: true
    isGetPrize?: true
    type?: true
    sendCoinUserId?: true
  }

  export type MsgSumAggregateInputType = {
    msgId?: true
    userId?: true
    winPropId?: true
    winPropCount?: true
    winScore?: true
    matchlogId?: true
    isGetPrize?: true
    type?: true
    sendCoinUserId?: true
  }

  export type MsgMinAggregateInputType = {
    msgId?: true
    userId?: true
    winPropId?: true
    winPropCount?: true
    winScore?: true
    matchlogId?: true
    isGetPrize?: true
    type?: true
    AddDate?: true
    sendCoinUserId?: true
    nickName?: true
  }

  export type MsgMaxAggregateInputType = {
    msgId?: true
    userId?: true
    winPropId?: true
    winPropCount?: true
    winScore?: true
    matchlogId?: true
    isGetPrize?: true
    type?: true
    AddDate?: true
    sendCoinUserId?: true
    nickName?: true
  }

  export type MsgCountAggregateInputType = {
    msgId?: true
    userId?: true
    winPropId?: true
    winPropCount?: true
    winScore?: true
    matchlogId?: true
    isGetPrize?: true
    type?: true
    AddDate?: true
    sendCoinUserId?: true
    nickName?: true
    _all?: true
  }

  export type MsgAggregateArgs = {
    /**
     * Filter which Msg to aggregate.
     */
    where?: MsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Msgs to fetch.
     */
    orderBy?: Enumerable<MsgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Msgs
    **/
    _count?: true | MsgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MsgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MsgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MsgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MsgMaxAggregateInputType
  }

  export type GetMsgAggregateType<T extends MsgAggregateArgs> = {
        [P in keyof T & keyof AggregateMsg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMsg[P]>
      : GetScalarType<T[P], AggregateMsg[P]>
  }




  export type MsgGroupByArgs = {
    where?: MsgWhereInput
    orderBy?: Enumerable<MsgOrderByWithAggregationInput>
    by: MsgScalarFieldEnum[]
    having?: MsgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MsgCountAggregateInputType | true
    _avg?: MsgAvgAggregateInputType
    _sum?: MsgSumAggregateInputType
    _min?: MsgMinAggregateInputType
    _max?: MsgMaxAggregateInputType
  }


  export type MsgGroupByOutputType = {
    msgId: number
    userId: number
    winPropId: number
    winPropCount: number
    winScore: number
    matchlogId: number
    isGetPrize: number
    type: number
    AddDate: Date
    sendCoinUserId: number
    nickName: string
    _count: MsgCountAggregateOutputType | null
    _avg: MsgAvgAggregateOutputType | null
    _sum: MsgSumAggregateOutputType | null
    _min: MsgMinAggregateOutputType | null
    _max: MsgMaxAggregateOutputType | null
  }

  type GetMsgGroupByPayload<T extends MsgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MsgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MsgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MsgGroupByOutputType[P]>
            : GetScalarType<T[P], MsgGroupByOutputType[P]>
        }
      >
    >


  export type MsgSelect = {
    msgId?: boolean
    userId?: boolean
    winPropId?: boolean
    winPropCount?: boolean
    winScore?: boolean
    matchlogId?: boolean
    isGetPrize?: boolean
    type?: boolean
    AddDate?: boolean
    sendCoinUserId?: boolean
    nickName?: boolean
  }


  export type MsgGetPayload<S extends boolean | null | undefined | MsgArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Msg :
    S extends undefined ? never :
    S extends { include: any } & (MsgArgs | MsgFindManyArgs)
    ? Msg 
    : S extends { select: any } & (MsgArgs | MsgFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Msg ? Msg[P] : never
  } 
      : Msg


  type MsgCountArgs = 
    Omit<MsgFindManyArgs, 'select' | 'include'> & {
      select?: MsgCountAggregateInputType | true
    }

  export interface MsgDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Msg that matches the filter.
     * @param {MsgFindUniqueArgs} args - Arguments to find a Msg
     * @example
     * // Get one Msg
     * const msg = await prisma.msg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MsgFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MsgFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Msg'> extends True ? Prisma__MsgClient<MsgGetPayload<T>> : Prisma__MsgClient<MsgGetPayload<T> | null, null>

    /**
     * Find one Msg that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MsgFindUniqueOrThrowArgs} args - Arguments to find a Msg
     * @example
     * // Get one Msg
     * const msg = await prisma.msg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MsgFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MsgFindUniqueOrThrowArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Find the first Msg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgFindFirstArgs} args - Arguments to find a Msg
     * @example
     * // Get one Msg
     * const msg = await prisma.msg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MsgFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MsgFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Msg'> extends True ? Prisma__MsgClient<MsgGetPayload<T>> : Prisma__MsgClient<MsgGetPayload<T> | null, null>

    /**
     * Find the first Msg that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgFindFirstOrThrowArgs} args - Arguments to find a Msg
     * @example
     * // Get one Msg
     * const msg = await prisma.msg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MsgFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MsgFindFirstOrThrowArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Find zero or more Msgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Msgs
     * const msgs = await prisma.msg.findMany()
     * 
     * // Get first 10 Msgs
     * const msgs = await prisma.msg.findMany({ take: 10 })
     * 
     * // Only select the `msgId`
     * const msgWithMsgIdOnly = await prisma.msg.findMany({ select: { msgId: true } })
     * 
    **/
    findMany<T extends MsgFindManyArgs>(
      args?: SelectSubset<T, MsgFindManyArgs>
    ): Prisma.PrismaPromise<Array<MsgGetPayload<T>>>

    /**
     * Create a Msg.
     * @param {MsgCreateArgs} args - Arguments to create a Msg.
     * @example
     * // Create one Msg
     * const Msg = await prisma.msg.create({
     *   data: {
     *     // ... data to create a Msg
     *   }
     * })
     * 
    **/
    create<T extends MsgCreateArgs>(
      args: SelectSubset<T, MsgCreateArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Create many Msgs.
     *     @param {MsgCreateManyArgs} args - Arguments to create many Msgs.
     *     @example
     *     // Create many Msgs
     *     const msg = await prisma.msg.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MsgCreateManyArgs>(
      args?: SelectSubset<T, MsgCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Msg.
     * @param {MsgDeleteArgs} args - Arguments to delete one Msg.
     * @example
     * // Delete one Msg
     * const Msg = await prisma.msg.delete({
     *   where: {
     *     // ... filter to delete one Msg
     *   }
     * })
     * 
    **/
    delete<T extends MsgDeleteArgs>(
      args: SelectSubset<T, MsgDeleteArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Update one Msg.
     * @param {MsgUpdateArgs} args - Arguments to update one Msg.
     * @example
     * // Update one Msg
     * const msg = await prisma.msg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MsgUpdateArgs>(
      args: SelectSubset<T, MsgUpdateArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Delete zero or more Msgs.
     * @param {MsgDeleteManyArgs} args - Arguments to filter Msgs to delete.
     * @example
     * // Delete a few Msgs
     * const { count } = await prisma.msg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MsgDeleteManyArgs>(
      args?: SelectSubset<T, MsgDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Msgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Msgs
     * const msg = await prisma.msg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MsgUpdateManyArgs>(
      args: SelectSubset<T, MsgUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Msg.
     * @param {MsgUpsertArgs} args - Arguments to update or create a Msg.
     * @example
     * // Update or create a Msg
     * const msg = await prisma.msg.upsert({
     *   create: {
     *     // ... data to create a Msg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Msg we want to update
     *   }
     * })
    **/
    upsert<T extends MsgUpsertArgs>(
      args: SelectSubset<T, MsgUpsertArgs>
    ): Prisma__MsgClient<MsgGetPayload<T>>

    /**
     * Count the number of Msgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgCountArgs} args - Arguments to filter Msgs to count.
     * @example
     * // Count the number of Msgs
     * const count = await prisma.msg.count({
     *   where: {
     *     // ... the filter for the Msgs we want to count
     *   }
     * })
    **/
    count<T extends MsgCountArgs>(
      args?: Subset<T, MsgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MsgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Msg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MsgAggregateArgs>(args: Subset<T, MsgAggregateArgs>): Prisma.PrismaPromise<GetMsgAggregateType<T>>

    /**
     * Group by Msg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MsgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MsgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MsgGroupByArgs['orderBy'] }
        : { orderBy?: MsgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MsgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMsgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Msg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MsgClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Msg base type for findUnique actions
   */
  export type MsgFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter, which Msg to fetch.
     */
    where: MsgWhereUniqueInput
  }

  /**
   * Msg findUnique
   */
  export interface MsgFindUniqueArgs extends MsgFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Msg findUniqueOrThrow
   */
  export type MsgFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter, which Msg to fetch.
     */
    where: MsgWhereUniqueInput
  }


  /**
   * Msg base type for findFirst actions
   */
  export type MsgFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter, which Msg to fetch.
     */
    where?: MsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Msgs to fetch.
     */
    orderBy?: Enumerable<MsgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Msgs.
     */
    cursor?: MsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Msgs.
     */
    distinct?: Enumerable<MsgScalarFieldEnum>
  }

  /**
   * Msg findFirst
   */
  export interface MsgFindFirstArgs extends MsgFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Msg findFirstOrThrow
   */
  export type MsgFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter, which Msg to fetch.
     */
    where?: MsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Msgs to fetch.
     */
    orderBy?: Enumerable<MsgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Msgs.
     */
    cursor?: MsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Msgs.
     */
    distinct?: Enumerable<MsgScalarFieldEnum>
  }


  /**
   * Msg findMany
   */
  export type MsgFindManyArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter, which Msgs to fetch.
     */
    where?: MsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Msgs to fetch.
     */
    orderBy?: Enumerable<MsgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Msgs.
     */
    cursor?: MsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Msgs.
     */
    skip?: number
    distinct?: Enumerable<MsgScalarFieldEnum>
  }


  /**
   * Msg create
   */
  export type MsgCreateArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * The data needed to create a Msg.
     */
    data: XOR<MsgCreateInput, MsgUncheckedCreateInput>
  }


  /**
   * Msg createMany
   */
  export type MsgCreateManyArgs = {
    /**
     * The data used to create many Msgs.
     */
    data: Enumerable<MsgCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Msg update
   */
  export type MsgUpdateArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * The data needed to update a Msg.
     */
    data: XOR<MsgUpdateInput, MsgUncheckedUpdateInput>
    /**
     * Choose, which Msg to update.
     */
    where: MsgWhereUniqueInput
  }


  /**
   * Msg updateMany
   */
  export type MsgUpdateManyArgs = {
    /**
     * The data used to update Msgs.
     */
    data: XOR<MsgUpdateManyMutationInput, MsgUncheckedUpdateManyInput>
    /**
     * Filter which Msgs to update
     */
    where?: MsgWhereInput
  }


  /**
   * Msg upsert
   */
  export type MsgUpsertArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * The filter to search for the Msg to update in case it exists.
     */
    where: MsgWhereUniqueInput
    /**
     * In case the Msg found by the `where` argument doesn't exist, create a new Msg with this data.
     */
    create: XOR<MsgCreateInput, MsgUncheckedCreateInput>
    /**
     * In case the Msg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MsgUpdateInput, MsgUncheckedUpdateInput>
  }


  /**
   * Msg delete
   */
  export type MsgDeleteArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
    /**
     * Filter which Msg to delete.
     */
    where: MsgWhereUniqueInput
  }


  /**
   * Msg deleteMany
   */
  export type MsgDeleteManyArgs = {
    /**
     * Filter which Msgs to delete
     */
    where?: MsgWhereInput
  }


  /**
   * Msg without action
   */
  export type MsgArgs = {
    /**
     * Select specific fields to fetch from the Msg
     */
    select?: MsgSelect | null
  }



  /**
   * Model Newuseraccounts
   */


  export type AggregateNewuseraccounts = {
    _count: NewuseraccountsCountAggregateOutputType | null
    _avg: NewuseraccountsAvgAggregateOutputType | null
    _sum: NewuseraccountsSumAggregateOutputType | null
    _min: NewuseraccountsMinAggregateOutputType | null
    _max: NewuseraccountsMaxAggregateOutputType | null
  }

  export type NewuseraccountsAvgAggregateOutputType = {
    Id: number | null
    score: number | null
    LoginCount: number | null
    diamond: number | null
    giftTicket: number | null
    sex: number | null
    Robot: number | null
    official: number | null
    qdid: number | null
    housecard: number | null
    totalRecharge: Decimal | null
    iscanlogin: number | null
    diansha_score: number | null
    is_vip: number | null
    account_using: number | null
    bankScore: number | null
  }

  export type NewuseraccountsSumAggregateOutputType = {
    Id: number | null
    score: number | null
    LoginCount: number | null
    diamond: number | null
    giftTicket: number | null
    sex: number | null
    Robot: number | null
    official: number | null
    qdid: number | null
    housecard: number | null
    totalRecharge: Decimal | null
    iscanlogin: number | null
    diansha_score: number | null
    is_vip: number | null
    account_using: number | null
    bankScore: number | null
  }

  export type NewuseraccountsMinAggregateOutputType = {
    Id: number | null
    Account: string | null
    Password: string | null
    nickname: string | null
    score: number | null
    AddDate: Date | null
    LoginCount: number | null
    p: string | null
    diamond: number | null
    giftTicket: number | null
    phoneNo: string | null
    email: string | null
    sex: number | null
    city: string | null
    province: string | null
    country: string | null
    headimgurl: string | null
    language: string | null
    Robot: number | null
    ChannelType: string | null
    official: number | null
    gametoken: string | null
    qdid: number | null
    housecard: number | null
    totalRecharge: Decimal | null
    loginip: string | null
    iscanlogin: number | null
    diansha_score: number | null
    diansha_gameids: string | null
    is_vip: number | null
    g4_uid: string | null
    account_using: number | null
    bankPwd: string | null
    bankScore: number | null
  }

  export type NewuseraccountsMaxAggregateOutputType = {
    Id: number | null
    Account: string | null
    Password: string | null
    nickname: string | null
    score: number | null
    AddDate: Date | null
    LoginCount: number | null
    p: string | null
    diamond: number | null
    giftTicket: number | null
    phoneNo: string | null
    email: string | null
    sex: number | null
    city: string | null
    province: string | null
    country: string | null
    headimgurl: string | null
    language: string | null
    Robot: number | null
    ChannelType: string | null
    official: number | null
    gametoken: string | null
    qdid: number | null
    housecard: number | null
    totalRecharge: Decimal | null
    loginip: string | null
    iscanlogin: number | null
    diansha_score: number | null
    diansha_gameids: string | null
    is_vip: number | null
    g4_uid: string | null
    account_using: number | null
    bankPwd: string | null
    bankScore: number | null
  }

  export type NewuseraccountsCountAggregateOutputType = {
    Id: number
    Account: number
    Password: number
    nickname: number
    score: number
    AddDate: number
    LoginCount: number
    p: number
    diamond: number
    giftTicket: number
    phoneNo: number
    email: number
    sex: number
    city: number
    province: number
    country: number
    headimgurl: number
    language: number
    Robot: number
    ChannelType: number
    official: number
    gametoken: number
    qdid: number
    housecard: number
    totalRecharge: number
    loginip: number
    iscanlogin: number
    diansha_score: number
    diansha_gameids: number
    is_vip: number
    g4_uid: number
    account_using: number
    bankPwd: number
    bankScore: number
    _all: number
  }


  export type NewuseraccountsAvgAggregateInputType = {
    Id?: true
    score?: true
    LoginCount?: true
    diamond?: true
    giftTicket?: true
    sex?: true
    Robot?: true
    official?: true
    qdid?: true
    housecard?: true
    totalRecharge?: true
    iscanlogin?: true
    diansha_score?: true
    is_vip?: true
    account_using?: true
    bankScore?: true
  }

  export type NewuseraccountsSumAggregateInputType = {
    Id?: true
    score?: true
    LoginCount?: true
    diamond?: true
    giftTicket?: true
    sex?: true
    Robot?: true
    official?: true
    qdid?: true
    housecard?: true
    totalRecharge?: true
    iscanlogin?: true
    diansha_score?: true
    is_vip?: true
    account_using?: true
    bankScore?: true
  }

  export type NewuseraccountsMinAggregateInputType = {
    Id?: true
    Account?: true
    Password?: true
    nickname?: true
    score?: true
    AddDate?: true
    LoginCount?: true
    p?: true
    diamond?: true
    giftTicket?: true
    phoneNo?: true
    email?: true
    sex?: true
    city?: true
    province?: true
    country?: true
    headimgurl?: true
    language?: true
    Robot?: true
    ChannelType?: true
    official?: true
    gametoken?: true
    qdid?: true
    housecard?: true
    totalRecharge?: true
    loginip?: true
    iscanlogin?: true
    diansha_score?: true
    diansha_gameids?: true
    is_vip?: true
    g4_uid?: true
    account_using?: true
    bankPwd?: true
    bankScore?: true
  }

  export type NewuseraccountsMaxAggregateInputType = {
    Id?: true
    Account?: true
    Password?: true
    nickname?: true
    score?: true
    AddDate?: true
    LoginCount?: true
    p?: true
    diamond?: true
    giftTicket?: true
    phoneNo?: true
    email?: true
    sex?: true
    city?: true
    province?: true
    country?: true
    headimgurl?: true
    language?: true
    Robot?: true
    ChannelType?: true
    official?: true
    gametoken?: true
    qdid?: true
    housecard?: true
    totalRecharge?: true
    loginip?: true
    iscanlogin?: true
    diansha_score?: true
    diansha_gameids?: true
    is_vip?: true
    g4_uid?: true
    account_using?: true
    bankPwd?: true
    bankScore?: true
  }

  export type NewuseraccountsCountAggregateInputType = {
    Id?: true
    Account?: true
    Password?: true
    nickname?: true
    score?: true
    AddDate?: true
    LoginCount?: true
    p?: true
    diamond?: true
    giftTicket?: true
    phoneNo?: true
    email?: true
    sex?: true
    city?: true
    province?: true
    country?: true
    headimgurl?: true
    language?: true
    Robot?: true
    ChannelType?: true
    official?: true
    gametoken?: true
    qdid?: true
    housecard?: true
    totalRecharge?: true
    loginip?: true
    iscanlogin?: true
    diansha_score?: true
    diansha_gameids?: true
    is_vip?: true
    g4_uid?: true
    account_using?: true
    bankPwd?: true
    bankScore?: true
    _all?: true
  }

  export type NewuseraccountsAggregateArgs = {
    /**
     * Filter which Newuseraccounts to aggregate.
     */
    where?: NewuseraccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newuseraccounts to fetch.
     */
    orderBy?: Enumerable<NewuseraccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewuseraccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newuseraccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newuseraccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Newuseraccounts
    **/
    _count?: true | NewuseraccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewuseraccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewuseraccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewuseraccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewuseraccountsMaxAggregateInputType
  }

  export type GetNewuseraccountsAggregateType<T extends NewuseraccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateNewuseraccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewuseraccounts[P]>
      : GetScalarType<T[P], AggregateNewuseraccounts[P]>
  }




  export type NewuseraccountsGroupByArgs = {
    where?: NewuseraccountsWhereInput
    orderBy?: Enumerable<NewuseraccountsOrderByWithAggregationInput>
    by: NewuseraccountsScalarFieldEnum[]
    having?: NewuseraccountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewuseraccountsCountAggregateInputType | true
    _avg?: NewuseraccountsAvgAggregateInputType
    _sum?: NewuseraccountsSumAggregateInputType
    _min?: NewuseraccountsMinAggregateInputType
    _max?: NewuseraccountsMaxAggregateInputType
  }


  export type NewuseraccountsGroupByOutputType = {
    Id: number
    Account: string
    Password: string
    nickname: string
    score: number
    AddDate: Date
    LoginCount: number
    p: string
    diamond: number
    giftTicket: number
    phoneNo: string
    email: string
    sex: number
    city: string
    province: string
    country: string
    headimgurl: string
    language: string
    Robot: number
    ChannelType: string
    official: number
    gametoken: string
    qdid: number
    housecard: number
    totalRecharge: Decimal
    loginip: string
    iscanlogin: number
    diansha_score: number
    diansha_gameids: string
    is_vip: number
    g4_uid: string
    account_using: number
    bankPwd: string
    bankScore: number
    _count: NewuseraccountsCountAggregateOutputType | null
    _avg: NewuseraccountsAvgAggregateOutputType | null
    _sum: NewuseraccountsSumAggregateOutputType | null
    _min: NewuseraccountsMinAggregateOutputType | null
    _max: NewuseraccountsMaxAggregateOutputType | null
  }

  type GetNewuseraccountsGroupByPayload<T extends NewuseraccountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NewuseraccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewuseraccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewuseraccountsGroupByOutputType[P]>
            : GetScalarType<T[P], NewuseraccountsGroupByOutputType[P]>
        }
      >
    >


  export type NewuseraccountsSelect = {
    Id?: boolean
    Account?: boolean
    Password?: boolean
    nickname?: boolean
    score?: boolean
    AddDate?: boolean
    LoginCount?: boolean
    p?: boolean
    diamond?: boolean
    giftTicket?: boolean
    phoneNo?: boolean
    email?: boolean
    sex?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    headimgurl?: boolean
    language?: boolean
    Robot?: boolean
    ChannelType?: boolean
    official?: boolean
    gametoken?: boolean
    qdid?: boolean
    housecard?: boolean
    totalRecharge?: boolean
    loginip?: boolean
    iscanlogin?: boolean
    diansha_score?: boolean
    diansha_gameids?: boolean
    is_vip?: boolean
    g4_uid?: boolean
    account_using?: boolean
    bankPwd?: boolean
    bankScore?: boolean
  }


  export type NewuseraccountsGetPayload<S extends boolean | null | undefined | NewuseraccountsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Newuseraccounts :
    S extends undefined ? never :
    S extends { include: any } & (NewuseraccountsArgs | NewuseraccountsFindManyArgs)
    ? Newuseraccounts 
    : S extends { select: any } & (NewuseraccountsArgs | NewuseraccountsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Newuseraccounts ? Newuseraccounts[P] : never
  } 
      : Newuseraccounts


  type NewuseraccountsCountArgs = 
    Omit<NewuseraccountsFindManyArgs, 'select' | 'include'> & {
      select?: NewuseraccountsCountAggregateInputType | true
    }

  export interface NewuseraccountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Newuseraccounts that matches the filter.
     * @param {NewuseraccountsFindUniqueArgs} args - Arguments to find a Newuseraccounts
     * @example
     * // Get one Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NewuseraccountsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NewuseraccountsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Newuseraccounts'> extends True ? Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>> : Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T> | null, null>

    /**
     * Find one Newuseraccounts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NewuseraccountsFindUniqueOrThrowArgs} args - Arguments to find a Newuseraccounts
     * @example
     * // Get one Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NewuseraccountsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NewuseraccountsFindUniqueOrThrowArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Find the first Newuseraccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsFindFirstArgs} args - Arguments to find a Newuseraccounts
     * @example
     * // Get one Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NewuseraccountsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NewuseraccountsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Newuseraccounts'> extends True ? Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>> : Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T> | null, null>

    /**
     * Find the first Newuseraccounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsFindFirstOrThrowArgs} args - Arguments to find a Newuseraccounts
     * @example
     * // Get one Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NewuseraccountsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NewuseraccountsFindFirstOrThrowArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Find zero or more Newuseraccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findMany()
     * 
     * // Get first 10 Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const newuseraccountsWithIdOnly = await prisma.newuseraccounts.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends NewuseraccountsFindManyArgs>(
      args?: SelectSubset<T, NewuseraccountsFindManyArgs>
    ): Prisma.PrismaPromise<Array<NewuseraccountsGetPayload<T>>>

    /**
     * Create a Newuseraccounts.
     * @param {NewuseraccountsCreateArgs} args - Arguments to create a Newuseraccounts.
     * @example
     * // Create one Newuseraccounts
     * const Newuseraccounts = await prisma.newuseraccounts.create({
     *   data: {
     *     // ... data to create a Newuseraccounts
     *   }
     * })
     * 
    **/
    create<T extends NewuseraccountsCreateArgs>(
      args: SelectSubset<T, NewuseraccountsCreateArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Create many Newuseraccounts.
     *     @param {NewuseraccountsCreateManyArgs} args - Arguments to create many Newuseraccounts.
     *     @example
     *     // Create many Newuseraccounts
     *     const newuseraccounts = await prisma.newuseraccounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NewuseraccountsCreateManyArgs>(
      args?: SelectSubset<T, NewuseraccountsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newuseraccounts.
     * @param {NewuseraccountsDeleteArgs} args - Arguments to delete one Newuseraccounts.
     * @example
     * // Delete one Newuseraccounts
     * const Newuseraccounts = await prisma.newuseraccounts.delete({
     *   where: {
     *     // ... filter to delete one Newuseraccounts
     *   }
     * })
     * 
    **/
    delete<T extends NewuseraccountsDeleteArgs>(
      args: SelectSubset<T, NewuseraccountsDeleteArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Update one Newuseraccounts.
     * @param {NewuseraccountsUpdateArgs} args - Arguments to update one Newuseraccounts.
     * @example
     * // Update one Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NewuseraccountsUpdateArgs>(
      args: SelectSubset<T, NewuseraccountsUpdateArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Delete zero or more Newuseraccounts.
     * @param {NewuseraccountsDeleteManyArgs} args - Arguments to filter Newuseraccounts to delete.
     * @example
     * // Delete a few Newuseraccounts
     * const { count } = await prisma.newuseraccounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NewuseraccountsDeleteManyArgs>(
      args?: SelectSubset<T, NewuseraccountsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newuseraccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NewuseraccountsUpdateManyArgs>(
      args: SelectSubset<T, NewuseraccountsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newuseraccounts.
     * @param {NewuseraccountsUpsertArgs} args - Arguments to update or create a Newuseraccounts.
     * @example
     * // Update or create a Newuseraccounts
     * const newuseraccounts = await prisma.newuseraccounts.upsert({
     *   create: {
     *     // ... data to create a Newuseraccounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newuseraccounts we want to update
     *   }
     * })
    **/
    upsert<T extends NewuseraccountsUpsertArgs>(
      args: SelectSubset<T, NewuseraccountsUpsertArgs>
    ): Prisma__NewuseraccountsClient<NewuseraccountsGetPayload<T>>

    /**
     * Count the number of Newuseraccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsCountArgs} args - Arguments to filter Newuseraccounts to count.
     * @example
     * // Count the number of Newuseraccounts
     * const count = await prisma.newuseraccounts.count({
     *   where: {
     *     // ... the filter for the Newuseraccounts we want to count
     *   }
     * })
    **/
    count<T extends NewuseraccountsCountArgs>(
      args?: Subset<T, NewuseraccountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewuseraccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newuseraccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewuseraccountsAggregateArgs>(args: Subset<T, NewuseraccountsAggregateArgs>): Prisma.PrismaPromise<GetNewuseraccountsAggregateType<T>>

    /**
     * Group by Newuseraccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewuseraccountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewuseraccountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewuseraccountsGroupByArgs['orderBy'] }
        : { orderBy?: NewuseraccountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewuseraccountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewuseraccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Newuseraccounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NewuseraccountsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Newuseraccounts base type for findUnique actions
   */
  export type NewuseraccountsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter, which Newuseraccounts to fetch.
     */
    where: NewuseraccountsWhereUniqueInput
  }

  /**
   * Newuseraccounts findUnique
   */
  export interface NewuseraccountsFindUniqueArgs extends NewuseraccountsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Newuseraccounts findUniqueOrThrow
   */
  export type NewuseraccountsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter, which Newuseraccounts to fetch.
     */
    where: NewuseraccountsWhereUniqueInput
  }


  /**
   * Newuseraccounts base type for findFirst actions
   */
  export type NewuseraccountsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter, which Newuseraccounts to fetch.
     */
    where?: NewuseraccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newuseraccounts to fetch.
     */
    orderBy?: Enumerable<NewuseraccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newuseraccounts.
     */
    cursor?: NewuseraccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newuseraccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newuseraccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newuseraccounts.
     */
    distinct?: Enumerable<NewuseraccountsScalarFieldEnum>
  }

  /**
   * Newuseraccounts findFirst
   */
  export interface NewuseraccountsFindFirstArgs extends NewuseraccountsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Newuseraccounts findFirstOrThrow
   */
  export type NewuseraccountsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter, which Newuseraccounts to fetch.
     */
    where?: NewuseraccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newuseraccounts to fetch.
     */
    orderBy?: Enumerable<NewuseraccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newuseraccounts.
     */
    cursor?: NewuseraccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newuseraccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newuseraccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newuseraccounts.
     */
    distinct?: Enumerable<NewuseraccountsScalarFieldEnum>
  }


  /**
   * Newuseraccounts findMany
   */
  export type NewuseraccountsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter, which Newuseraccounts to fetch.
     */
    where?: NewuseraccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newuseraccounts to fetch.
     */
    orderBy?: Enumerable<NewuseraccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Newuseraccounts.
     */
    cursor?: NewuseraccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newuseraccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newuseraccounts.
     */
    skip?: number
    distinct?: Enumerable<NewuseraccountsScalarFieldEnum>
  }


  /**
   * Newuseraccounts create
   */
  export type NewuseraccountsCreateArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * The data needed to create a Newuseraccounts.
     */
    data: XOR<NewuseraccountsCreateInput, NewuseraccountsUncheckedCreateInput>
  }


  /**
   * Newuseraccounts createMany
   */
  export type NewuseraccountsCreateManyArgs = {
    /**
     * The data used to create many Newuseraccounts.
     */
    data: Enumerable<NewuseraccountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Newuseraccounts update
   */
  export type NewuseraccountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * The data needed to update a Newuseraccounts.
     */
    data: XOR<NewuseraccountsUpdateInput, NewuseraccountsUncheckedUpdateInput>
    /**
     * Choose, which Newuseraccounts to update.
     */
    where: NewuseraccountsWhereUniqueInput
  }


  /**
   * Newuseraccounts updateMany
   */
  export type NewuseraccountsUpdateManyArgs = {
    /**
     * The data used to update Newuseraccounts.
     */
    data: XOR<NewuseraccountsUpdateManyMutationInput, NewuseraccountsUncheckedUpdateManyInput>
    /**
     * Filter which Newuseraccounts to update
     */
    where?: NewuseraccountsWhereInput
  }


  /**
   * Newuseraccounts upsert
   */
  export type NewuseraccountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * The filter to search for the Newuseraccounts to update in case it exists.
     */
    where: NewuseraccountsWhereUniqueInput
    /**
     * In case the Newuseraccounts found by the `where` argument doesn't exist, create a new Newuseraccounts with this data.
     */
    create: XOR<NewuseraccountsCreateInput, NewuseraccountsUncheckedCreateInput>
    /**
     * In case the Newuseraccounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewuseraccountsUpdateInput, NewuseraccountsUncheckedUpdateInput>
  }


  /**
   * Newuseraccounts delete
   */
  export type NewuseraccountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
    /**
     * Filter which Newuseraccounts to delete.
     */
    where: NewuseraccountsWhereUniqueInput
  }


  /**
   * Newuseraccounts deleteMany
   */
  export type NewuseraccountsDeleteManyArgs = {
    /**
     * Filter which Newuseraccounts to delete
     */
    where?: NewuseraccountsWhereInput
  }


  /**
   * Newuseraccounts without action
   */
  export type NewuseraccountsArgs = {
    /**
     * Select specific fields to fetch from the Newuseraccounts
     */
    select?: NewuseraccountsSelect | null
  }



  /**
   * Model Pcdandan
   */


  export type AggregatePcdandan = {
    _count: PcdandanCountAggregateOutputType | null
    _avg: PcdandanAvgAggregateOutputType | null
    _sum: PcdandanSumAggregateOutputType | null
    _min: PcdandanMinAggregateOutputType | null
    _max: PcdandanMaxAggregateOutputType | null
  }

  export type PcdandanAvgAggregateOutputType = {
    userId: number | null
  }

  export type PcdandanSumAggregateOutputType = {
    userId: number | null
  }

  export type PcdandanMinAggregateOutputType = {
    userId: number | null
    pcdandanId: string | null
    Devid: string | null
  }

  export type PcdandanMaxAggregateOutputType = {
    userId: number | null
    pcdandanId: string | null
    Devid: string | null
  }

  export type PcdandanCountAggregateOutputType = {
    userId: number
    pcdandanId: number
    Devid: number
    _all: number
  }


  export type PcdandanAvgAggregateInputType = {
    userId?: true
  }

  export type PcdandanSumAggregateInputType = {
    userId?: true
  }

  export type PcdandanMinAggregateInputType = {
    userId?: true
    pcdandanId?: true
    Devid?: true
  }

  export type PcdandanMaxAggregateInputType = {
    userId?: true
    pcdandanId?: true
    Devid?: true
  }

  export type PcdandanCountAggregateInputType = {
    userId?: true
    pcdandanId?: true
    Devid?: true
    _all?: true
  }

  export type PcdandanAggregateArgs = {
    /**
     * Filter which Pcdandan to aggregate.
     */
    where?: PcdandanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pcdandans to fetch.
     */
    orderBy?: Enumerable<PcdandanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PcdandanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pcdandans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pcdandans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pcdandans
    **/
    _count?: true | PcdandanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PcdandanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PcdandanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PcdandanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PcdandanMaxAggregateInputType
  }

  export type GetPcdandanAggregateType<T extends PcdandanAggregateArgs> = {
        [P in keyof T & keyof AggregatePcdandan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePcdandan[P]>
      : GetScalarType<T[P], AggregatePcdandan[P]>
  }




  export type PcdandanGroupByArgs = {
    where?: PcdandanWhereInput
    orderBy?: Enumerable<PcdandanOrderByWithAggregationInput>
    by: PcdandanScalarFieldEnum[]
    having?: PcdandanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PcdandanCountAggregateInputType | true
    _avg?: PcdandanAvgAggregateInputType
    _sum?: PcdandanSumAggregateInputType
    _min?: PcdandanMinAggregateInputType
    _max?: PcdandanMaxAggregateInputType
  }


  export type PcdandanGroupByOutputType = {
    userId: number
    pcdandanId: string
    Devid: string
    _count: PcdandanCountAggregateOutputType | null
    _avg: PcdandanAvgAggregateOutputType | null
    _sum: PcdandanSumAggregateOutputType | null
    _min: PcdandanMinAggregateOutputType | null
    _max: PcdandanMaxAggregateOutputType | null
  }

  type GetPcdandanGroupByPayload<T extends PcdandanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PcdandanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PcdandanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PcdandanGroupByOutputType[P]>
            : GetScalarType<T[P], PcdandanGroupByOutputType[P]>
        }
      >
    >


  export type PcdandanSelect = {
    userId?: boolean
    pcdandanId?: boolean
    Devid?: boolean
  }


  export type PcdandanGetPayload<S extends boolean | null | undefined | PcdandanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pcdandan :
    S extends undefined ? never :
    S extends { include: any } & (PcdandanArgs | PcdandanFindManyArgs)
    ? Pcdandan 
    : S extends { select: any } & (PcdandanArgs | PcdandanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Pcdandan ? Pcdandan[P] : never
  } 
      : Pcdandan


  type PcdandanCountArgs = 
    Omit<PcdandanFindManyArgs, 'select' | 'include'> & {
      select?: PcdandanCountAggregateInputType | true
    }

  export interface PcdandanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pcdandan that matches the filter.
     * @param {PcdandanFindUniqueArgs} args - Arguments to find a Pcdandan
     * @example
     * // Get one Pcdandan
     * const pcdandan = await prisma.pcdandan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PcdandanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PcdandanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pcdandan'> extends True ? Prisma__PcdandanClient<PcdandanGetPayload<T>> : Prisma__PcdandanClient<PcdandanGetPayload<T> | null, null>

    /**
     * Find one Pcdandan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PcdandanFindUniqueOrThrowArgs} args - Arguments to find a Pcdandan
     * @example
     * // Get one Pcdandan
     * const pcdandan = await prisma.pcdandan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PcdandanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PcdandanFindUniqueOrThrowArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Find the first Pcdandan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanFindFirstArgs} args - Arguments to find a Pcdandan
     * @example
     * // Get one Pcdandan
     * const pcdandan = await prisma.pcdandan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PcdandanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PcdandanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pcdandan'> extends True ? Prisma__PcdandanClient<PcdandanGetPayload<T>> : Prisma__PcdandanClient<PcdandanGetPayload<T> | null, null>

    /**
     * Find the first Pcdandan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanFindFirstOrThrowArgs} args - Arguments to find a Pcdandan
     * @example
     * // Get one Pcdandan
     * const pcdandan = await prisma.pcdandan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PcdandanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PcdandanFindFirstOrThrowArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Find zero or more Pcdandans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pcdandans
     * const pcdandans = await prisma.pcdandan.findMany()
     * 
     * // Get first 10 Pcdandans
     * const pcdandans = await prisma.pcdandan.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const pcdandanWithUserIdOnly = await prisma.pcdandan.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends PcdandanFindManyArgs>(
      args?: SelectSubset<T, PcdandanFindManyArgs>
    ): Prisma.PrismaPromise<Array<PcdandanGetPayload<T>>>

    /**
     * Create a Pcdandan.
     * @param {PcdandanCreateArgs} args - Arguments to create a Pcdandan.
     * @example
     * // Create one Pcdandan
     * const Pcdandan = await prisma.pcdandan.create({
     *   data: {
     *     // ... data to create a Pcdandan
     *   }
     * })
     * 
    **/
    create<T extends PcdandanCreateArgs>(
      args: SelectSubset<T, PcdandanCreateArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Create many Pcdandans.
     *     @param {PcdandanCreateManyArgs} args - Arguments to create many Pcdandans.
     *     @example
     *     // Create many Pcdandans
     *     const pcdandan = await prisma.pcdandan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PcdandanCreateManyArgs>(
      args?: SelectSubset<T, PcdandanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pcdandan.
     * @param {PcdandanDeleteArgs} args - Arguments to delete one Pcdandan.
     * @example
     * // Delete one Pcdandan
     * const Pcdandan = await prisma.pcdandan.delete({
     *   where: {
     *     // ... filter to delete one Pcdandan
     *   }
     * })
     * 
    **/
    delete<T extends PcdandanDeleteArgs>(
      args: SelectSubset<T, PcdandanDeleteArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Update one Pcdandan.
     * @param {PcdandanUpdateArgs} args - Arguments to update one Pcdandan.
     * @example
     * // Update one Pcdandan
     * const pcdandan = await prisma.pcdandan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PcdandanUpdateArgs>(
      args: SelectSubset<T, PcdandanUpdateArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Delete zero or more Pcdandans.
     * @param {PcdandanDeleteManyArgs} args - Arguments to filter Pcdandans to delete.
     * @example
     * // Delete a few Pcdandans
     * const { count } = await prisma.pcdandan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PcdandanDeleteManyArgs>(
      args?: SelectSubset<T, PcdandanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pcdandans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pcdandans
     * const pcdandan = await prisma.pcdandan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PcdandanUpdateManyArgs>(
      args: SelectSubset<T, PcdandanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pcdandan.
     * @param {PcdandanUpsertArgs} args - Arguments to update or create a Pcdandan.
     * @example
     * // Update or create a Pcdandan
     * const pcdandan = await prisma.pcdandan.upsert({
     *   create: {
     *     // ... data to create a Pcdandan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pcdandan we want to update
     *   }
     * })
    **/
    upsert<T extends PcdandanUpsertArgs>(
      args: SelectSubset<T, PcdandanUpsertArgs>
    ): Prisma__PcdandanClient<PcdandanGetPayload<T>>

    /**
     * Count the number of Pcdandans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanCountArgs} args - Arguments to filter Pcdandans to count.
     * @example
     * // Count the number of Pcdandans
     * const count = await prisma.pcdandan.count({
     *   where: {
     *     // ... the filter for the Pcdandans we want to count
     *   }
     * })
    **/
    count<T extends PcdandanCountArgs>(
      args?: Subset<T, PcdandanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PcdandanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pcdandan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PcdandanAggregateArgs>(args: Subset<T, PcdandanAggregateArgs>): Prisma.PrismaPromise<GetPcdandanAggregateType<T>>

    /**
     * Group by Pcdandan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PcdandanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PcdandanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PcdandanGroupByArgs['orderBy'] }
        : { orderBy?: PcdandanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PcdandanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPcdandanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pcdandan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PcdandanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pcdandan base type for findUnique actions
   */
  export type PcdandanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter, which Pcdandan to fetch.
     */
    where: PcdandanWhereUniqueInput
  }

  /**
   * Pcdandan findUnique
   */
  export interface PcdandanFindUniqueArgs extends PcdandanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pcdandan findUniqueOrThrow
   */
  export type PcdandanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter, which Pcdandan to fetch.
     */
    where: PcdandanWhereUniqueInput
  }


  /**
   * Pcdandan base type for findFirst actions
   */
  export type PcdandanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter, which Pcdandan to fetch.
     */
    where?: PcdandanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pcdandans to fetch.
     */
    orderBy?: Enumerable<PcdandanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pcdandans.
     */
    cursor?: PcdandanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pcdandans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pcdandans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pcdandans.
     */
    distinct?: Enumerable<PcdandanScalarFieldEnum>
  }

  /**
   * Pcdandan findFirst
   */
  export interface PcdandanFindFirstArgs extends PcdandanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pcdandan findFirstOrThrow
   */
  export type PcdandanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter, which Pcdandan to fetch.
     */
    where?: PcdandanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pcdandans to fetch.
     */
    orderBy?: Enumerable<PcdandanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pcdandans.
     */
    cursor?: PcdandanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pcdandans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pcdandans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pcdandans.
     */
    distinct?: Enumerable<PcdandanScalarFieldEnum>
  }


  /**
   * Pcdandan findMany
   */
  export type PcdandanFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter, which Pcdandans to fetch.
     */
    where?: PcdandanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pcdandans to fetch.
     */
    orderBy?: Enumerable<PcdandanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pcdandans.
     */
    cursor?: PcdandanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pcdandans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pcdandans.
     */
    skip?: number
    distinct?: Enumerable<PcdandanScalarFieldEnum>
  }


  /**
   * Pcdandan create
   */
  export type PcdandanCreateArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * The data needed to create a Pcdandan.
     */
    data: XOR<PcdandanCreateInput, PcdandanUncheckedCreateInput>
  }


  /**
   * Pcdandan createMany
   */
  export type PcdandanCreateManyArgs = {
    /**
     * The data used to create many Pcdandans.
     */
    data: Enumerable<PcdandanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pcdandan update
   */
  export type PcdandanUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * The data needed to update a Pcdandan.
     */
    data: XOR<PcdandanUpdateInput, PcdandanUncheckedUpdateInput>
    /**
     * Choose, which Pcdandan to update.
     */
    where: PcdandanWhereUniqueInput
  }


  /**
   * Pcdandan updateMany
   */
  export type PcdandanUpdateManyArgs = {
    /**
     * The data used to update Pcdandans.
     */
    data: XOR<PcdandanUpdateManyMutationInput, PcdandanUncheckedUpdateManyInput>
    /**
     * Filter which Pcdandans to update
     */
    where?: PcdandanWhereInput
  }


  /**
   * Pcdandan upsert
   */
  export type PcdandanUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * The filter to search for the Pcdandan to update in case it exists.
     */
    where: PcdandanWhereUniqueInput
    /**
     * In case the Pcdandan found by the `where` argument doesn't exist, create a new Pcdandan with this data.
     */
    create: XOR<PcdandanCreateInput, PcdandanUncheckedCreateInput>
    /**
     * In case the Pcdandan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PcdandanUpdateInput, PcdandanUncheckedUpdateInput>
  }


  /**
   * Pcdandan delete
   */
  export type PcdandanDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
    /**
     * Filter which Pcdandan to delete.
     */
    where: PcdandanWhereUniqueInput
  }


  /**
   * Pcdandan deleteMany
   */
  export type PcdandanDeleteManyArgs = {
    /**
     * Filter which Pcdandans to delete
     */
    where?: PcdandanWhereInput
  }


  /**
   * Pcdandan without action
   */
  export type PcdandanArgs = {
    /**
     * Select specific fields to fetch from the Pcdandan
     */
    select?: PcdandanSelect | null
  }



  /**
   * Model Prop_changelog
   */


  export type AggregateProp_changelog = {
    _count: Prop_changelogCountAggregateOutputType | null
    _avg: Prop_changelogAvgAggregateOutputType | null
    _sum: Prop_changelogSumAggregateOutputType | null
    _min: Prop_changelogMinAggregateOutputType | null
    _max: Prop_changelogMaxAggregateOutputType | null
  }

  export type Prop_changelogAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    change_before: number | null
    change_count: number | null
    change_after: number | null
    gameid: number | null
    codeid: number | null
  }

  export type Prop_changelogSumAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    change_before: number | null
    change_count: number | null
    change_after: number | null
    gameid: number | null
    codeid: number | null
  }

  export type Prop_changelogMinAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    change_before: number | null
    change_count: number | null
    change_after: number | null
    insertTime: Date | null
    gameid: number | null
    codeid: number | null
  }

  export type Prop_changelogMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    change_before: number | null
    change_count: number | null
    change_after: number | null
    insertTime: Date | null
    gameid: number | null
    codeid: number | null
  }

  export type Prop_changelogCountAggregateOutputType = {
    id: number
    userid: number
    propid: number
    change_before: number
    change_count: number
    change_after: number
    insertTime: number
    gameid: number
    codeid: number
    _all: number
  }


  export type Prop_changelogAvgAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    change_before?: true
    change_count?: true
    change_after?: true
    gameid?: true
    codeid?: true
  }

  export type Prop_changelogSumAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    change_before?: true
    change_count?: true
    change_after?: true
    gameid?: true
    codeid?: true
  }

  export type Prop_changelogMinAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    change_before?: true
    change_count?: true
    change_after?: true
    insertTime?: true
    gameid?: true
    codeid?: true
  }

  export type Prop_changelogMaxAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    change_before?: true
    change_count?: true
    change_after?: true
    insertTime?: true
    gameid?: true
    codeid?: true
  }

  export type Prop_changelogCountAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    change_before?: true
    change_count?: true
    change_after?: true
    insertTime?: true
    gameid?: true
    codeid?: true
    _all?: true
  }

  export type Prop_changelogAggregateArgs = {
    /**
     * Filter which Prop_changelog to aggregate.
     */
    where?: Prop_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_changelogs to fetch.
     */
    orderBy?: Enumerable<Prop_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Prop_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prop_changelogs
    **/
    _count?: true | Prop_changelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prop_changelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prop_changelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prop_changelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prop_changelogMaxAggregateInputType
  }

  export type GetProp_changelogAggregateType<T extends Prop_changelogAggregateArgs> = {
        [P in keyof T & keyof AggregateProp_changelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProp_changelog[P]>
      : GetScalarType<T[P], AggregateProp_changelog[P]>
  }




  export type Prop_changelogGroupByArgs = {
    where?: Prop_changelogWhereInput
    orderBy?: Enumerable<Prop_changelogOrderByWithAggregationInput>
    by: Prop_changelogScalarFieldEnum[]
    having?: Prop_changelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prop_changelogCountAggregateInputType | true
    _avg?: Prop_changelogAvgAggregateInputType
    _sum?: Prop_changelogSumAggregateInputType
    _min?: Prop_changelogMinAggregateInputType
    _max?: Prop_changelogMaxAggregateInputType
  }


  export type Prop_changelogGroupByOutputType = {
    id: number
    userid: number
    propid: number
    change_before: number
    change_count: number
    change_after: number
    insertTime: Date
    gameid: number
    codeid: number
    _count: Prop_changelogCountAggregateOutputType | null
    _avg: Prop_changelogAvgAggregateOutputType | null
    _sum: Prop_changelogSumAggregateOutputType | null
    _min: Prop_changelogMinAggregateOutputType | null
    _max: Prop_changelogMaxAggregateOutputType | null
  }

  type GetProp_changelogGroupByPayload<T extends Prop_changelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Prop_changelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prop_changelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prop_changelogGroupByOutputType[P]>
            : GetScalarType<T[P], Prop_changelogGroupByOutputType[P]>
        }
      >
    >


  export type Prop_changelogSelect = {
    id?: boolean
    userid?: boolean
    propid?: boolean
    change_before?: boolean
    change_count?: boolean
    change_after?: boolean
    insertTime?: boolean
    gameid?: boolean
    codeid?: boolean
  }


  export type Prop_changelogGetPayload<S extends boolean | null | undefined | Prop_changelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Prop_changelog :
    S extends undefined ? never :
    S extends { include: any } & (Prop_changelogArgs | Prop_changelogFindManyArgs)
    ? Prop_changelog 
    : S extends { select: any } & (Prop_changelogArgs | Prop_changelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Prop_changelog ? Prop_changelog[P] : never
  } 
      : Prop_changelog


  type Prop_changelogCountArgs = 
    Omit<Prop_changelogFindManyArgs, 'select' | 'include'> & {
      select?: Prop_changelogCountAggregateInputType | true
    }

  export interface Prop_changelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Prop_changelog that matches the filter.
     * @param {Prop_changelogFindUniqueArgs} args - Arguments to find a Prop_changelog
     * @example
     * // Get one Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Prop_changelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Prop_changelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prop_changelog'> extends True ? Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>> : Prisma__Prop_changelogClient<Prop_changelogGetPayload<T> | null, null>

    /**
     * Find one Prop_changelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Prop_changelogFindUniqueOrThrowArgs} args - Arguments to find a Prop_changelog
     * @example
     * // Get one Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Prop_changelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Prop_changelogFindUniqueOrThrowArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Find the first Prop_changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogFindFirstArgs} args - Arguments to find a Prop_changelog
     * @example
     * // Get one Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Prop_changelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Prop_changelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prop_changelog'> extends True ? Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>> : Prisma__Prop_changelogClient<Prop_changelogGetPayload<T> | null, null>

    /**
     * Find the first Prop_changelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogFindFirstOrThrowArgs} args - Arguments to find a Prop_changelog
     * @example
     * // Get one Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Prop_changelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Prop_changelogFindFirstOrThrowArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Find zero or more Prop_changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prop_changelogs
     * const prop_changelogs = await prisma.prop_changelog.findMany()
     * 
     * // Get first 10 Prop_changelogs
     * const prop_changelogs = await prisma.prop_changelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prop_changelogWithIdOnly = await prisma.prop_changelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Prop_changelogFindManyArgs>(
      args?: SelectSubset<T, Prop_changelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<Prop_changelogGetPayload<T>>>

    /**
     * Create a Prop_changelog.
     * @param {Prop_changelogCreateArgs} args - Arguments to create a Prop_changelog.
     * @example
     * // Create one Prop_changelog
     * const Prop_changelog = await prisma.prop_changelog.create({
     *   data: {
     *     // ... data to create a Prop_changelog
     *   }
     * })
     * 
    **/
    create<T extends Prop_changelogCreateArgs>(
      args: SelectSubset<T, Prop_changelogCreateArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Create many Prop_changelogs.
     *     @param {Prop_changelogCreateManyArgs} args - Arguments to create many Prop_changelogs.
     *     @example
     *     // Create many Prop_changelogs
     *     const prop_changelog = await prisma.prop_changelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Prop_changelogCreateManyArgs>(
      args?: SelectSubset<T, Prop_changelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prop_changelog.
     * @param {Prop_changelogDeleteArgs} args - Arguments to delete one Prop_changelog.
     * @example
     * // Delete one Prop_changelog
     * const Prop_changelog = await prisma.prop_changelog.delete({
     *   where: {
     *     // ... filter to delete one Prop_changelog
     *   }
     * })
     * 
    **/
    delete<T extends Prop_changelogDeleteArgs>(
      args: SelectSubset<T, Prop_changelogDeleteArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Update one Prop_changelog.
     * @param {Prop_changelogUpdateArgs} args - Arguments to update one Prop_changelog.
     * @example
     * // Update one Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Prop_changelogUpdateArgs>(
      args: SelectSubset<T, Prop_changelogUpdateArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Delete zero or more Prop_changelogs.
     * @param {Prop_changelogDeleteManyArgs} args - Arguments to filter Prop_changelogs to delete.
     * @example
     * // Delete a few Prop_changelogs
     * const { count } = await prisma.prop_changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Prop_changelogDeleteManyArgs>(
      args?: SelectSubset<T, Prop_changelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prop_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prop_changelogs
     * const prop_changelog = await prisma.prop_changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Prop_changelogUpdateManyArgs>(
      args: SelectSubset<T, Prop_changelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prop_changelog.
     * @param {Prop_changelogUpsertArgs} args - Arguments to update or create a Prop_changelog.
     * @example
     * // Update or create a Prop_changelog
     * const prop_changelog = await prisma.prop_changelog.upsert({
     *   create: {
     *     // ... data to create a Prop_changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prop_changelog we want to update
     *   }
     * })
    **/
    upsert<T extends Prop_changelogUpsertArgs>(
      args: SelectSubset<T, Prop_changelogUpsertArgs>
    ): Prisma__Prop_changelogClient<Prop_changelogGetPayload<T>>

    /**
     * Count the number of Prop_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogCountArgs} args - Arguments to filter Prop_changelogs to count.
     * @example
     * // Count the number of Prop_changelogs
     * const count = await prisma.prop_changelog.count({
     *   where: {
     *     // ... the filter for the Prop_changelogs we want to count
     *   }
     * })
    **/
    count<T extends Prop_changelogCountArgs>(
      args?: Subset<T, Prop_changelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prop_changelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prop_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prop_changelogAggregateArgs>(args: Subset<T, Prop_changelogAggregateArgs>): Prisma.PrismaPromise<GetProp_changelogAggregateType<T>>

    /**
     * Group by Prop_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_changelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Prop_changelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Prop_changelogGroupByArgs['orderBy'] }
        : { orderBy?: Prop_changelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Prop_changelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProp_changelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Prop_changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Prop_changelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Prop_changelog base type for findUnique actions
   */
  export type Prop_changelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter, which Prop_changelog to fetch.
     */
    where: Prop_changelogWhereUniqueInput
  }

  /**
   * Prop_changelog findUnique
   */
  export interface Prop_changelogFindUniqueArgs extends Prop_changelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prop_changelog findUniqueOrThrow
   */
  export type Prop_changelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter, which Prop_changelog to fetch.
     */
    where: Prop_changelogWhereUniqueInput
  }


  /**
   * Prop_changelog base type for findFirst actions
   */
  export type Prop_changelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter, which Prop_changelog to fetch.
     */
    where?: Prop_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_changelogs to fetch.
     */
    orderBy?: Enumerable<Prop_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prop_changelogs.
     */
    cursor?: Prop_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prop_changelogs.
     */
    distinct?: Enumerable<Prop_changelogScalarFieldEnum>
  }

  /**
   * Prop_changelog findFirst
   */
  export interface Prop_changelogFindFirstArgs extends Prop_changelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prop_changelog findFirstOrThrow
   */
  export type Prop_changelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter, which Prop_changelog to fetch.
     */
    where?: Prop_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_changelogs to fetch.
     */
    orderBy?: Enumerable<Prop_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prop_changelogs.
     */
    cursor?: Prop_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prop_changelogs.
     */
    distinct?: Enumerable<Prop_changelogScalarFieldEnum>
  }


  /**
   * Prop_changelog findMany
   */
  export type Prop_changelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter, which Prop_changelogs to fetch.
     */
    where?: Prop_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_changelogs to fetch.
     */
    orderBy?: Enumerable<Prop_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prop_changelogs.
     */
    cursor?: Prop_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_changelogs.
     */
    skip?: number
    distinct?: Enumerable<Prop_changelogScalarFieldEnum>
  }


  /**
   * Prop_changelog create
   */
  export type Prop_changelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * The data needed to create a Prop_changelog.
     */
    data: XOR<Prop_changelogCreateInput, Prop_changelogUncheckedCreateInput>
  }


  /**
   * Prop_changelog createMany
   */
  export type Prop_changelogCreateManyArgs = {
    /**
     * The data used to create many Prop_changelogs.
     */
    data: Enumerable<Prop_changelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prop_changelog update
   */
  export type Prop_changelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * The data needed to update a Prop_changelog.
     */
    data: XOR<Prop_changelogUpdateInput, Prop_changelogUncheckedUpdateInput>
    /**
     * Choose, which Prop_changelog to update.
     */
    where: Prop_changelogWhereUniqueInput
  }


  /**
   * Prop_changelog updateMany
   */
  export type Prop_changelogUpdateManyArgs = {
    /**
     * The data used to update Prop_changelogs.
     */
    data: XOR<Prop_changelogUpdateManyMutationInput, Prop_changelogUncheckedUpdateManyInput>
    /**
     * Filter which Prop_changelogs to update
     */
    where?: Prop_changelogWhereInput
  }


  /**
   * Prop_changelog upsert
   */
  export type Prop_changelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * The filter to search for the Prop_changelog to update in case it exists.
     */
    where: Prop_changelogWhereUniqueInput
    /**
     * In case the Prop_changelog found by the `where` argument doesn't exist, create a new Prop_changelog with this data.
     */
    create: XOR<Prop_changelogCreateInput, Prop_changelogUncheckedCreateInput>
    /**
     * In case the Prop_changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Prop_changelogUpdateInput, Prop_changelogUncheckedUpdateInput>
  }


  /**
   * Prop_changelog delete
   */
  export type Prop_changelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
    /**
     * Filter which Prop_changelog to delete.
     */
    where: Prop_changelogWhereUniqueInput
  }


  /**
   * Prop_changelog deleteMany
   */
  export type Prop_changelogDeleteManyArgs = {
    /**
     * Filter which Prop_changelogs to delete
     */
    where?: Prop_changelogWhereInput
  }


  /**
   * Prop_changelog without action
   */
  export type Prop_changelogArgs = {
    /**
     * Select specific fields to fetch from the Prop_changelog
     */
    select?: Prop_changelogSelect | null
  }



  /**
   * Model Prop_item
   */


  export type AggregateProp_item = {
    _count: Prop_itemCountAggregateOutputType | null
    _avg: Prop_itemAvgAggregateOutputType | null
    _sum: Prop_itemSumAggregateOutputType | null
    _min: Prop_itemMinAggregateOutputType | null
    _max: Prop_itemMaxAggregateOutputType | null
  }

  export type Prop_itemAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    propcount: number | null
  }

  export type Prop_itemSumAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    propcount: number | null
  }

  export type Prop_itemMinAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    propcount: number | null
  }

  export type Prop_itemMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    propid: number | null
    propcount: number | null
  }

  export type Prop_itemCountAggregateOutputType = {
    id: number
    userid: number
    propid: number
    propcount: number
    _all: number
  }


  export type Prop_itemAvgAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    propcount?: true
  }

  export type Prop_itemSumAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    propcount?: true
  }

  export type Prop_itemMinAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    propcount?: true
  }

  export type Prop_itemMaxAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    propcount?: true
  }

  export type Prop_itemCountAggregateInputType = {
    id?: true
    userid?: true
    propid?: true
    propcount?: true
    _all?: true
  }

  export type Prop_itemAggregateArgs = {
    /**
     * Filter which Prop_item to aggregate.
     */
    where?: Prop_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_items to fetch.
     */
    orderBy?: Enumerable<Prop_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Prop_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prop_items
    **/
    _count?: true | Prop_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prop_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prop_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prop_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prop_itemMaxAggregateInputType
  }

  export type GetProp_itemAggregateType<T extends Prop_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateProp_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProp_item[P]>
      : GetScalarType<T[P], AggregateProp_item[P]>
  }




  export type Prop_itemGroupByArgs = {
    where?: Prop_itemWhereInput
    orderBy?: Enumerable<Prop_itemOrderByWithAggregationInput>
    by: Prop_itemScalarFieldEnum[]
    having?: Prop_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prop_itemCountAggregateInputType | true
    _avg?: Prop_itemAvgAggregateInputType
    _sum?: Prop_itemSumAggregateInputType
    _min?: Prop_itemMinAggregateInputType
    _max?: Prop_itemMaxAggregateInputType
  }


  export type Prop_itemGroupByOutputType = {
    id: number
    userid: number
    propid: number
    propcount: number
    _count: Prop_itemCountAggregateOutputType | null
    _avg: Prop_itemAvgAggregateOutputType | null
    _sum: Prop_itemSumAggregateOutputType | null
    _min: Prop_itemMinAggregateOutputType | null
    _max: Prop_itemMaxAggregateOutputType | null
  }

  type GetProp_itemGroupByPayload<T extends Prop_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Prop_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prop_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prop_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Prop_itemGroupByOutputType[P]>
        }
      >
    >


  export type Prop_itemSelect = {
    id?: boolean
    userid?: boolean
    propid?: boolean
    propcount?: boolean
  }


  export type Prop_itemGetPayload<S extends boolean | null | undefined | Prop_itemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Prop_item :
    S extends undefined ? never :
    S extends { include: any } & (Prop_itemArgs | Prop_itemFindManyArgs)
    ? Prop_item 
    : S extends { select: any } & (Prop_itemArgs | Prop_itemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Prop_item ? Prop_item[P] : never
  } 
      : Prop_item


  type Prop_itemCountArgs = 
    Omit<Prop_itemFindManyArgs, 'select' | 'include'> & {
      select?: Prop_itemCountAggregateInputType | true
    }

  export interface Prop_itemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Prop_item that matches the filter.
     * @param {Prop_itemFindUniqueArgs} args - Arguments to find a Prop_item
     * @example
     * // Get one Prop_item
     * const prop_item = await prisma.prop_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Prop_itemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Prop_itemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prop_item'> extends True ? Prisma__Prop_itemClient<Prop_itemGetPayload<T>> : Prisma__Prop_itemClient<Prop_itemGetPayload<T> | null, null>

    /**
     * Find one Prop_item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Prop_itemFindUniqueOrThrowArgs} args - Arguments to find a Prop_item
     * @example
     * // Get one Prop_item
     * const prop_item = await prisma.prop_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Prop_itemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Prop_itemFindUniqueOrThrowArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Find the first Prop_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemFindFirstArgs} args - Arguments to find a Prop_item
     * @example
     * // Get one Prop_item
     * const prop_item = await prisma.prop_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Prop_itemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Prop_itemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prop_item'> extends True ? Prisma__Prop_itemClient<Prop_itemGetPayload<T>> : Prisma__Prop_itemClient<Prop_itemGetPayload<T> | null, null>

    /**
     * Find the first Prop_item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemFindFirstOrThrowArgs} args - Arguments to find a Prop_item
     * @example
     * // Get one Prop_item
     * const prop_item = await prisma.prop_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Prop_itemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Prop_itemFindFirstOrThrowArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Find zero or more Prop_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prop_items
     * const prop_items = await prisma.prop_item.findMany()
     * 
     * // Get first 10 Prop_items
     * const prop_items = await prisma.prop_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prop_itemWithIdOnly = await prisma.prop_item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Prop_itemFindManyArgs>(
      args?: SelectSubset<T, Prop_itemFindManyArgs>
    ): Prisma.PrismaPromise<Array<Prop_itemGetPayload<T>>>

    /**
     * Create a Prop_item.
     * @param {Prop_itemCreateArgs} args - Arguments to create a Prop_item.
     * @example
     * // Create one Prop_item
     * const Prop_item = await prisma.prop_item.create({
     *   data: {
     *     // ... data to create a Prop_item
     *   }
     * })
     * 
    **/
    create<T extends Prop_itemCreateArgs>(
      args: SelectSubset<T, Prop_itemCreateArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Create many Prop_items.
     *     @param {Prop_itemCreateManyArgs} args - Arguments to create many Prop_items.
     *     @example
     *     // Create many Prop_items
     *     const prop_item = await prisma.prop_item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Prop_itemCreateManyArgs>(
      args?: SelectSubset<T, Prop_itemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prop_item.
     * @param {Prop_itemDeleteArgs} args - Arguments to delete one Prop_item.
     * @example
     * // Delete one Prop_item
     * const Prop_item = await prisma.prop_item.delete({
     *   where: {
     *     // ... filter to delete one Prop_item
     *   }
     * })
     * 
    **/
    delete<T extends Prop_itemDeleteArgs>(
      args: SelectSubset<T, Prop_itemDeleteArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Update one Prop_item.
     * @param {Prop_itemUpdateArgs} args - Arguments to update one Prop_item.
     * @example
     * // Update one Prop_item
     * const prop_item = await prisma.prop_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Prop_itemUpdateArgs>(
      args: SelectSubset<T, Prop_itemUpdateArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Delete zero or more Prop_items.
     * @param {Prop_itemDeleteManyArgs} args - Arguments to filter Prop_items to delete.
     * @example
     * // Delete a few Prop_items
     * const { count } = await prisma.prop_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Prop_itemDeleteManyArgs>(
      args?: SelectSubset<T, Prop_itemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prop_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prop_items
     * const prop_item = await prisma.prop_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Prop_itemUpdateManyArgs>(
      args: SelectSubset<T, Prop_itemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prop_item.
     * @param {Prop_itemUpsertArgs} args - Arguments to update or create a Prop_item.
     * @example
     * // Update or create a Prop_item
     * const prop_item = await prisma.prop_item.upsert({
     *   create: {
     *     // ... data to create a Prop_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prop_item we want to update
     *   }
     * })
    **/
    upsert<T extends Prop_itemUpsertArgs>(
      args: SelectSubset<T, Prop_itemUpsertArgs>
    ): Prisma__Prop_itemClient<Prop_itemGetPayload<T>>

    /**
     * Count the number of Prop_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemCountArgs} args - Arguments to filter Prop_items to count.
     * @example
     * // Count the number of Prop_items
     * const count = await prisma.prop_item.count({
     *   where: {
     *     // ... the filter for the Prop_items we want to count
     *   }
     * })
    **/
    count<T extends Prop_itemCountArgs>(
      args?: Subset<T, Prop_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prop_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prop_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prop_itemAggregateArgs>(args: Subset<T, Prop_itemAggregateArgs>): Prisma.PrismaPromise<GetProp_itemAggregateType<T>>

    /**
     * Group by Prop_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prop_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Prop_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Prop_itemGroupByArgs['orderBy'] }
        : { orderBy?: Prop_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Prop_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProp_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Prop_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Prop_itemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Prop_item base type for findUnique actions
   */
  export type Prop_itemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter, which Prop_item to fetch.
     */
    where: Prop_itemWhereUniqueInput
  }

  /**
   * Prop_item findUnique
   */
  export interface Prop_itemFindUniqueArgs extends Prop_itemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prop_item findUniqueOrThrow
   */
  export type Prop_itemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter, which Prop_item to fetch.
     */
    where: Prop_itemWhereUniqueInput
  }


  /**
   * Prop_item base type for findFirst actions
   */
  export type Prop_itemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter, which Prop_item to fetch.
     */
    where?: Prop_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_items to fetch.
     */
    orderBy?: Enumerable<Prop_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prop_items.
     */
    cursor?: Prop_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prop_items.
     */
    distinct?: Enumerable<Prop_itemScalarFieldEnum>
  }

  /**
   * Prop_item findFirst
   */
  export interface Prop_itemFindFirstArgs extends Prop_itemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prop_item findFirstOrThrow
   */
  export type Prop_itemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter, which Prop_item to fetch.
     */
    where?: Prop_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_items to fetch.
     */
    orderBy?: Enumerable<Prop_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prop_items.
     */
    cursor?: Prop_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prop_items.
     */
    distinct?: Enumerable<Prop_itemScalarFieldEnum>
  }


  /**
   * Prop_item findMany
   */
  export type Prop_itemFindManyArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter, which Prop_items to fetch.
     */
    where?: Prop_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prop_items to fetch.
     */
    orderBy?: Enumerable<Prop_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prop_items.
     */
    cursor?: Prop_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prop_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prop_items.
     */
    skip?: number
    distinct?: Enumerable<Prop_itemScalarFieldEnum>
  }


  /**
   * Prop_item create
   */
  export type Prop_itemCreateArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * The data needed to create a Prop_item.
     */
    data: XOR<Prop_itemCreateInput, Prop_itemUncheckedCreateInput>
  }


  /**
   * Prop_item createMany
   */
  export type Prop_itemCreateManyArgs = {
    /**
     * The data used to create many Prop_items.
     */
    data: Enumerable<Prop_itemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prop_item update
   */
  export type Prop_itemUpdateArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * The data needed to update a Prop_item.
     */
    data: XOR<Prop_itemUpdateInput, Prop_itemUncheckedUpdateInput>
    /**
     * Choose, which Prop_item to update.
     */
    where: Prop_itemWhereUniqueInput
  }


  /**
   * Prop_item updateMany
   */
  export type Prop_itemUpdateManyArgs = {
    /**
     * The data used to update Prop_items.
     */
    data: XOR<Prop_itemUpdateManyMutationInput, Prop_itemUncheckedUpdateManyInput>
    /**
     * Filter which Prop_items to update
     */
    where?: Prop_itemWhereInput
  }


  /**
   * Prop_item upsert
   */
  export type Prop_itemUpsertArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * The filter to search for the Prop_item to update in case it exists.
     */
    where: Prop_itemWhereUniqueInput
    /**
     * In case the Prop_item found by the `where` argument doesn't exist, create a new Prop_item with this data.
     */
    create: XOR<Prop_itemCreateInput, Prop_itemUncheckedCreateInput>
    /**
     * In case the Prop_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Prop_itemUpdateInput, Prop_itemUncheckedUpdateInput>
  }


  /**
   * Prop_item delete
   */
  export type Prop_itemDeleteArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
    /**
     * Filter which Prop_item to delete.
     */
    where: Prop_itemWhereUniqueInput
  }


  /**
   * Prop_item deleteMany
   */
  export type Prop_itemDeleteManyArgs = {
    /**
     * Filter which Prop_items to delete
     */
    where?: Prop_itemWhereInput
  }


  /**
   * Prop_item without action
   */
  export type Prop_itemArgs = {
    /**
     * Select specific fields to fetch from the Prop_item
     */
    select?: Prop_itemSelect | null
  }



  /**
   * Model Recharge
   */


  export type AggregateRecharge = {
    _count: RechargeCountAggregateOutputType | null
    _avg: RechargeAvgAggregateOutputType | null
    _sum: RechargeSumAggregateOutputType | null
    _min: RechargeMinAggregateOutputType | null
    _max: RechargeMaxAggregateOutputType | null
  }

  export type RechargeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    total_fee: number | null
    goodsid: number | null
    state: number | null
  }

  export type RechargeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    total_fee: number | null
    goodsid: number | null
    state: number | null
  }

  export type RechargeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    Account: string | null
    total_fee: number | null
    out_trade_no: string | null
    goodsid: number | null
    state: number | null
    createTime: Date | null
  }

  export type RechargeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    Account: string | null
    total_fee: number | null
    out_trade_no: string | null
    goodsid: number | null
    state: number | null
    createTime: Date | null
  }

  export type RechargeCountAggregateOutputType = {
    id: number
    userId: number
    Account: number
    total_fee: number
    out_trade_no: number
    goodsid: number
    state: number
    createTime: number
    _all: number
  }


  export type RechargeAvgAggregateInputType = {
    id?: true
    userId?: true
    total_fee?: true
    goodsid?: true
    state?: true
  }

  export type RechargeSumAggregateInputType = {
    id?: true
    userId?: true
    total_fee?: true
    goodsid?: true
    state?: true
  }

  export type RechargeMinAggregateInputType = {
    id?: true
    userId?: true
    Account?: true
    total_fee?: true
    out_trade_no?: true
    goodsid?: true
    state?: true
    createTime?: true
  }

  export type RechargeMaxAggregateInputType = {
    id?: true
    userId?: true
    Account?: true
    total_fee?: true
    out_trade_no?: true
    goodsid?: true
    state?: true
    createTime?: true
  }

  export type RechargeCountAggregateInputType = {
    id?: true
    userId?: true
    Account?: true
    total_fee?: true
    out_trade_no?: true
    goodsid?: true
    state?: true
    createTime?: true
    _all?: true
  }

  export type RechargeAggregateArgs = {
    /**
     * Filter which Recharge to aggregate.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: Enumerable<RechargeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recharges
    **/
    _count?: true | RechargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargeMaxAggregateInputType
  }

  export type GetRechargeAggregateType<T extends RechargeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecharge[P]>
      : GetScalarType<T[P], AggregateRecharge[P]>
  }




  export type RechargeGroupByArgs = {
    where?: RechargeWhereInput
    orderBy?: Enumerable<RechargeOrderByWithAggregationInput>
    by: RechargeScalarFieldEnum[]
    having?: RechargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargeCountAggregateInputType | true
    _avg?: RechargeAvgAggregateInputType
    _sum?: RechargeSumAggregateInputType
    _min?: RechargeMinAggregateInputType
    _max?: RechargeMaxAggregateInputType
  }


  export type RechargeGroupByOutputType = {
    id: number
    userId: number
    Account: string
    total_fee: number
    out_trade_no: string
    goodsid: number
    state: number
    createTime: Date
    _count: RechargeCountAggregateOutputType | null
    _avg: RechargeAvgAggregateOutputType | null
    _sum: RechargeSumAggregateOutputType | null
    _min: RechargeMinAggregateOutputType | null
    _max: RechargeMaxAggregateOutputType | null
  }

  type GetRechargeGroupByPayload<T extends RechargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RechargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargeGroupByOutputType[P]>
            : GetScalarType<T[P], RechargeGroupByOutputType[P]>
        }
      >
    >


  export type RechargeSelect = {
    id?: boolean
    userId?: boolean
    Account?: boolean
    total_fee?: boolean
    out_trade_no?: boolean
    goodsid?: boolean
    state?: boolean
    createTime?: boolean
  }


  export type RechargeGetPayload<S extends boolean | null | undefined | RechargeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Recharge :
    S extends undefined ? never :
    S extends { include: any } & (RechargeArgs | RechargeFindManyArgs)
    ? Recharge 
    : S extends { select: any } & (RechargeArgs | RechargeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Recharge ? Recharge[P] : never
  } 
      : Recharge


  type RechargeCountArgs = 
    Omit<RechargeFindManyArgs, 'select' | 'include'> & {
      select?: RechargeCountAggregateInputType | true
    }

  export interface RechargeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Recharge that matches the filter.
     * @param {RechargeFindUniqueArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RechargeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RechargeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recharge'> extends True ? Prisma__RechargeClient<RechargeGetPayload<T>> : Prisma__RechargeClient<RechargeGetPayload<T> | null, null>

    /**
     * Find one Recharge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RechargeFindUniqueOrThrowArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RechargeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RechargeFindUniqueOrThrowArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Find the first Recharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindFirstArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RechargeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RechargeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recharge'> extends True ? Prisma__RechargeClient<RechargeGetPayload<T>> : Prisma__RechargeClient<RechargeGetPayload<T> | null, null>

    /**
     * Find the first Recharge that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindFirstOrThrowArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RechargeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RechargeFindFirstOrThrowArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Find zero or more Recharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recharges
     * const recharges = await prisma.recharge.findMany()
     * 
     * // Get first 10 Recharges
     * const recharges = await prisma.recharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargeWithIdOnly = await prisma.recharge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RechargeFindManyArgs>(
      args?: SelectSubset<T, RechargeFindManyArgs>
    ): Prisma.PrismaPromise<Array<RechargeGetPayload<T>>>

    /**
     * Create a Recharge.
     * @param {RechargeCreateArgs} args - Arguments to create a Recharge.
     * @example
     * // Create one Recharge
     * const Recharge = await prisma.recharge.create({
     *   data: {
     *     // ... data to create a Recharge
     *   }
     * })
     * 
    **/
    create<T extends RechargeCreateArgs>(
      args: SelectSubset<T, RechargeCreateArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Create many Recharges.
     *     @param {RechargeCreateManyArgs} args - Arguments to create many Recharges.
     *     @example
     *     // Create many Recharges
     *     const recharge = await prisma.recharge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RechargeCreateManyArgs>(
      args?: SelectSubset<T, RechargeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recharge.
     * @param {RechargeDeleteArgs} args - Arguments to delete one Recharge.
     * @example
     * // Delete one Recharge
     * const Recharge = await prisma.recharge.delete({
     *   where: {
     *     // ... filter to delete one Recharge
     *   }
     * })
     * 
    **/
    delete<T extends RechargeDeleteArgs>(
      args: SelectSubset<T, RechargeDeleteArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Update one Recharge.
     * @param {RechargeUpdateArgs} args - Arguments to update one Recharge.
     * @example
     * // Update one Recharge
     * const recharge = await prisma.recharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RechargeUpdateArgs>(
      args: SelectSubset<T, RechargeUpdateArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Delete zero or more Recharges.
     * @param {RechargeDeleteManyArgs} args - Arguments to filter Recharges to delete.
     * @example
     * // Delete a few Recharges
     * const { count } = await prisma.recharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RechargeDeleteManyArgs>(
      args?: SelectSubset<T, RechargeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recharges
     * const recharge = await prisma.recharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RechargeUpdateManyArgs>(
      args: SelectSubset<T, RechargeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recharge.
     * @param {RechargeUpsertArgs} args - Arguments to update or create a Recharge.
     * @example
     * // Update or create a Recharge
     * const recharge = await prisma.recharge.upsert({
     *   create: {
     *     // ... data to create a Recharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recharge we want to update
     *   }
     * })
    **/
    upsert<T extends RechargeUpsertArgs>(
      args: SelectSubset<T, RechargeUpsertArgs>
    ): Prisma__RechargeClient<RechargeGetPayload<T>>

    /**
     * Count the number of Recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeCountArgs} args - Arguments to filter Recharges to count.
     * @example
     * // Count the number of Recharges
     * const count = await prisma.recharge.count({
     *   where: {
     *     // ... the filter for the Recharges we want to count
     *   }
     * })
    **/
    count<T extends RechargeCountArgs>(
      args?: Subset<T, RechargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargeAggregateArgs>(args: Subset<T, RechargeAggregateArgs>): Prisma.PrismaPromise<GetRechargeAggregateType<T>>

    /**
     * Group by Recharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargeGroupByArgs['orderBy'] }
        : { orderBy?: RechargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RechargeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recharge base type for findUnique actions
   */
  export type RechargeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter, which Recharge to fetch.
     */
    where: RechargeWhereUniqueInput
  }

  /**
   * Recharge findUnique
   */
  export interface RechargeFindUniqueArgs extends RechargeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recharge findUniqueOrThrow
   */
  export type RechargeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter, which Recharge to fetch.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge base type for findFirst actions
   */
  export type RechargeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter, which Recharge to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: Enumerable<RechargeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharges.
     */
    distinct?: Enumerable<RechargeScalarFieldEnum>
  }

  /**
   * Recharge findFirst
   */
  export interface RechargeFindFirstArgs extends RechargeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recharge findFirstOrThrow
   */
  export type RechargeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter, which Recharge to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: Enumerable<RechargeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharges.
     */
    distinct?: Enumerable<RechargeScalarFieldEnum>
  }


  /**
   * Recharge findMany
   */
  export type RechargeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter, which Recharges to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: Enumerable<RechargeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    distinct?: Enumerable<RechargeScalarFieldEnum>
  }


  /**
   * Recharge create
   */
  export type RechargeCreateArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * The data needed to create a Recharge.
     */
    data: XOR<RechargeCreateInput, RechargeUncheckedCreateInput>
  }


  /**
   * Recharge createMany
   */
  export type RechargeCreateManyArgs = {
    /**
     * The data used to create many Recharges.
     */
    data: Enumerable<RechargeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recharge update
   */
  export type RechargeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * The data needed to update a Recharge.
     */
    data: XOR<RechargeUpdateInput, RechargeUncheckedUpdateInput>
    /**
     * Choose, which Recharge to update.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge updateMany
   */
  export type RechargeUpdateManyArgs = {
    /**
     * The data used to update Recharges.
     */
    data: XOR<RechargeUpdateManyMutationInput, RechargeUncheckedUpdateManyInput>
    /**
     * Filter which Recharges to update
     */
    where?: RechargeWhereInput
  }


  /**
   * Recharge upsert
   */
  export type RechargeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * The filter to search for the Recharge to update in case it exists.
     */
    where: RechargeWhereUniqueInput
    /**
     * In case the Recharge found by the `where` argument doesn't exist, create a new Recharge with this data.
     */
    create: XOR<RechargeCreateInput, RechargeUncheckedCreateInput>
    /**
     * In case the Recharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargeUpdateInput, RechargeUncheckedUpdateInput>
  }


  /**
   * Recharge delete
   */
  export type RechargeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
    /**
     * Filter which Recharge to delete.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge deleteMany
   */
  export type RechargeDeleteManyArgs = {
    /**
     * Filter which Recharges to delete
     */
    where?: RechargeWhereInput
  }


  /**
   * Recharge without action
   */
  export type RechargeArgs = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect | null
  }



  /**
   * Model Recharge_first
   */


  export type AggregateRecharge_first = {
    _count: Recharge_firstCountAggregateOutputType | null
    _avg: Recharge_firstAvgAggregateOutputType | null
    _sum: Recharge_firstSumAggregateOutputType | null
    _min: Recharge_firstMinAggregateOutputType | null
    _max: Recharge_firstMaxAggregateOutputType | null
  }

  export type Recharge_firstAvgAggregateOutputType = {
    userId: number | null
    FIRST: number | null
    anyFirst: number | null
    goods1: number | null
    goods2: number | null
    goods3: number | null
    goods4: number | null
    goods5: number | null
  }

  export type Recharge_firstSumAggregateOutputType = {
    userId: number | null
    FIRST: number | null
    anyFirst: number | null
    goods1: number | null
    goods2: number | null
    goods3: number | null
    goods4: number | null
    goods5: number | null
  }

  export type Recharge_firstMinAggregateOutputType = {
    userId: number | null
    FIRST: number | null
    anyFirst: number | null
    goods1: number | null
    goods2: number | null
    goods3: number | null
    goods4: number | null
    goods5: number | null
    daytime: Date | null
  }

  export type Recharge_firstMaxAggregateOutputType = {
    userId: number | null
    FIRST: number | null
    anyFirst: number | null
    goods1: number | null
    goods2: number | null
    goods3: number | null
    goods4: number | null
    goods5: number | null
    daytime: Date | null
  }

  export type Recharge_firstCountAggregateOutputType = {
    userId: number
    FIRST: number
    anyFirst: number
    goods1: number
    goods2: number
    goods3: number
    goods4: number
    goods5: number
    daytime: number
    _all: number
  }


  export type Recharge_firstAvgAggregateInputType = {
    userId?: true
    FIRST?: true
    anyFirst?: true
    goods1?: true
    goods2?: true
    goods3?: true
    goods4?: true
    goods5?: true
  }

  export type Recharge_firstSumAggregateInputType = {
    userId?: true
    FIRST?: true
    anyFirst?: true
    goods1?: true
    goods2?: true
    goods3?: true
    goods4?: true
    goods5?: true
  }

  export type Recharge_firstMinAggregateInputType = {
    userId?: true
    FIRST?: true
    anyFirst?: true
    goods1?: true
    goods2?: true
    goods3?: true
    goods4?: true
    goods5?: true
    daytime?: true
  }

  export type Recharge_firstMaxAggregateInputType = {
    userId?: true
    FIRST?: true
    anyFirst?: true
    goods1?: true
    goods2?: true
    goods3?: true
    goods4?: true
    goods5?: true
    daytime?: true
  }

  export type Recharge_firstCountAggregateInputType = {
    userId?: true
    FIRST?: true
    anyFirst?: true
    goods1?: true
    goods2?: true
    goods3?: true
    goods4?: true
    goods5?: true
    daytime?: true
    _all?: true
  }

  export type Recharge_firstAggregateArgs = {
    /**
     * Filter which Recharge_first to aggregate.
     */
    where?: Recharge_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharge_firsts to fetch.
     */
    orderBy?: Enumerable<Recharge_firstOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Recharge_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharge_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharge_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recharge_firsts
    **/
    _count?: true | Recharge_firstCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Recharge_firstAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Recharge_firstSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Recharge_firstMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Recharge_firstMaxAggregateInputType
  }

  export type GetRecharge_firstAggregateType<T extends Recharge_firstAggregateArgs> = {
        [P in keyof T & keyof AggregateRecharge_first]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecharge_first[P]>
      : GetScalarType<T[P], AggregateRecharge_first[P]>
  }




  export type Recharge_firstGroupByArgs = {
    where?: Recharge_firstWhereInput
    orderBy?: Enumerable<Recharge_firstOrderByWithAggregationInput>
    by: Recharge_firstScalarFieldEnum[]
    having?: Recharge_firstScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Recharge_firstCountAggregateInputType | true
    _avg?: Recharge_firstAvgAggregateInputType
    _sum?: Recharge_firstSumAggregateInputType
    _min?: Recharge_firstMinAggregateInputType
    _max?: Recharge_firstMaxAggregateInputType
  }


  export type Recharge_firstGroupByOutputType = {
    userId: number
    FIRST: number
    anyFirst: number
    goods1: number
    goods2: number
    goods3: number
    goods4: number
    goods5: number
    daytime: Date
    _count: Recharge_firstCountAggregateOutputType | null
    _avg: Recharge_firstAvgAggregateOutputType | null
    _sum: Recharge_firstSumAggregateOutputType | null
    _min: Recharge_firstMinAggregateOutputType | null
    _max: Recharge_firstMaxAggregateOutputType | null
  }

  type GetRecharge_firstGroupByPayload<T extends Recharge_firstGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Recharge_firstGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Recharge_firstGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Recharge_firstGroupByOutputType[P]>
            : GetScalarType<T[P], Recharge_firstGroupByOutputType[P]>
        }
      >
    >


  export type Recharge_firstSelect = {
    userId?: boolean
    FIRST?: boolean
    anyFirst?: boolean
    goods1?: boolean
    goods2?: boolean
    goods3?: boolean
    goods4?: boolean
    goods5?: boolean
    daytime?: boolean
  }


  export type Recharge_firstGetPayload<S extends boolean | null | undefined | Recharge_firstArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Recharge_first :
    S extends undefined ? never :
    S extends { include: any } & (Recharge_firstArgs | Recharge_firstFindManyArgs)
    ? Recharge_first 
    : S extends { select: any } & (Recharge_firstArgs | Recharge_firstFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Recharge_first ? Recharge_first[P] : never
  } 
      : Recharge_first


  type Recharge_firstCountArgs = 
    Omit<Recharge_firstFindManyArgs, 'select' | 'include'> & {
      select?: Recharge_firstCountAggregateInputType | true
    }

  export interface Recharge_firstDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Recharge_first that matches the filter.
     * @param {Recharge_firstFindUniqueArgs} args - Arguments to find a Recharge_first
     * @example
     * // Get one Recharge_first
     * const recharge_first = await prisma.recharge_first.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Recharge_firstFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Recharge_firstFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recharge_first'> extends True ? Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>> : Prisma__Recharge_firstClient<Recharge_firstGetPayload<T> | null, null>

    /**
     * Find one Recharge_first that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Recharge_firstFindUniqueOrThrowArgs} args - Arguments to find a Recharge_first
     * @example
     * // Get one Recharge_first
     * const recharge_first = await prisma.recharge_first.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Recharge_firstFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Recharge_firstFindUniqueOrThrowArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Find the first Recharge_first that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstFindFirstArgs} args - Arguments to find a Recharge_first
     * @example
     * // Get one Recharge_first
     * const recharge_first = await prisma.recharge_first.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Recharge_firstFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Recharge_firstFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recharge_first'> extends True ? Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>> : Prisma__Recharge_firstClient<Recharge_firstGetPayload<T> | null, null>

    /**
     * Find the first Recharge_first that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstFindFirstOrThrowArgs} args - Arguments to find a Recharge_first
     * @example
     * // Get one Recharge_first
     * const recharge_first = await prisma.recharge_first.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Recharge_firstFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Recharge_firstFindFirstOrThrowArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Find zero or more Recharge_firsts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recharge_firsts
     * const recharge_firsts = await prisma.recharge_first.findMany()
     * 
     * // Get first 10 Recharge_firsts
     * const recharge_firsts = await prisma.recharge_first.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const recharge_firstWithUserIdOnly = await prisma.recharge_first.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends Recharge_firstFindManyArgs>(
      args?: SelectSubset<T, Recharge_firstFindManyArgs>
    ): Prisma.PrismaPromise<Array<Recharge_firstGetPayload<T>>>

    /**
     * Create a Recharge_first.
     * @param {Recharge_firstCreateArgs} args - Arguments to create a Recharge_first.
     * @example
     * // Create one Recharge_first
     * const Recharge_first = await prisma.recharge_first.create({
     *   data: {
     *     // ... data to create a Recharge_first
     *   }
     * })
     * 
    **/
    create<T extends Recharge_firstCreateArgs>(
      args: SelectSubset<T, Recharge_firstCreateArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Create many Recharge_firsts.
     *     @param {Recharge_firstCreateManyArgs} args - Arguments to create many Recharge_firsts.
     *     @example
     *     // Create many Recharge_firsts
     *     const recharge_first = await prisma.recharge_first.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Recharge_firstCreateManyArgs>(
      args?: SelectSubset<T, Recharge_firstCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recharge_first.
     * @param {Recharge_firstDeleteArgs} args - Arguments to delete one Recharge_first.
     * @example
     * // Delete one Recharge_first
     * const Recharge_first = await prisma.recharge_first.delete({
     *   where: {
     *     // ... filter to delete one Recharge_first
     *   }
     * })
     * 
    **/
    delete<T extends Recharge_firstDeleteArgs>(
      args: SelectSubset<T, Recharge_firstDeleteArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Update one Recharge_first.
     * @param {Recharge_firstUpdateArgs} args - Arguments to update one Recharge_first.
     * @example
     * // Update one Recharge_first
     * const recharge_first = await prisma.recharge_first.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Recharge_firstUpdateArgs>(
      args: SelectSubset<T, Recharge_firstUpdateArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Delete zero or more Recharge_firsts.
     * @param {Recharge_firstDeleteManyArgs} args - Arguments to filter Recharge_firsts to delete.
     * @example
     * // Delete a few Recharge_firsts
     * const { count } = await prisma.recharge_first.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Recharge_firstDeleteManyArgs>(
      args?: SelectSubset<T, Recharge_firstDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recharge_firsts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recharge_firsts
     * const recharge_first = await prisma.recharge_first.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Recharge_firstUpdateManyArgs>(
      args: SelectSubset<T, Recharge_firstUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recharge_first.
     * @param {Recharge_firstUpsertArgs} args - Arguments to update or create a Recharge_first.
     * @example
     * // Update or create a Recharge_first
     * const recharge_first = await prisma.recharge_first.upsert({
     *   create: {
     *     // ... data to create a Recharge_first
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recharge_first we want to update
     *   }
     * })
    **/
    upsert<T extends Recharge_firstUpsertArgs>(
      args: SelectSubset<T, Recharge_firstUpsertArgs>
    ): Prisma__Recharge_firstClient<Recharge_firstGetPayload<T>>

    /**
     * Count the number of Recharge_firsts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstCountArgs} args - Arguments to filter Recharge_firsts to count.
     * @example
     * // Count the number of Recharge_firsts
     * const count = await prisma.recharge_first.count({
     *   where: {
     *     // ... the filter for the Recharge_firsts we want to count
     *   }
     * })
    **/
    count<T extends Recharge_firstCountArgs>(
      args?: Subset<T, Recharge_firstCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recharge_firstCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recharge_first.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recharge_firstAggregateArgs>(args: Subset<T, Recharge_firstAggregateArgs>): Prisma.PrismaPromise<GetRecharge_firstAggregateType<T>>

    /**
     * Group by Recharge_first.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recharge_firstGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Recharge_firstGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Recharge_firstGroupByArgs['orderBy'] }
        : { orderBy?: Recharge_firstGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Recharge_firstGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecharge_firstGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recharge_first.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Recharge_firstClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recharge_first base type for findUnique actions
   */
  export type Recharge_firstFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter, which Recharge_first to fetch.
     */
    where: Recharge_firstWhereUniqueInput
  }

  /**
   * Recharge_first findUnique
   */
  export interface Recharge_firstFindUniqueArgs extends Recharge_firstFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recharge_first findUniqueOrThrow
   */
  export type Recharge_firstFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter, which Recharge_first to fetch.
     */
    where: Recharge_firstWhereUniqueInput
  }


  /**
   * Recharge_first base type for findFirst actions
   */
  export type Recharge_firstFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter, which Recharge_first to fetch.
     */
    where?: Recharge_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharge_firsts to fetch.
     */
    orderBy?: Enumerable<Recharge_firstOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharge_firsts.
     */
    cursor?: Recharge_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharge_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharge_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharge_firsts.
     */
    distinct?: Enumerable<Recharge_firstScalarFieldEnum>
  }

  /**
   * Recharge_first findFirst
   */
  export interface Recharge_firstFindFirstArgs extends Recharge_firstFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recharge_first findFirstOrThrow
   */
  export type Recharge_firstFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter, which Recharge_first to fetch.
     */
    where?: Recharge_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharge_firsts to fetch.
     */
    orderBy?: Enumerable<Recharge_firstOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharge_firsts.
     */
    cursor?: Recharge_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharge_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharge_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharge_firsts.
     */
    distinct?: Enumerable<Recharge_firstScalarFieldEnum>
  }


  /**
   * Recharge_first findMany
   */
  export type Recharge_firstFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter, which Recharge_firsts to fetch.
     */
    where?: Recharge_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharge_firsts to fetch.
     */
    orderBy?: Enumerable<Recharge_firstOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recharge_firsts.
     */
    cursor?: Recharge_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharge_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharge_firsts.
     */
    skip?: number
    distinct?: Enumerable<Recharge_firstScalarFieldEnum>
  }


  /**
   * Recharge_first create
   */
  export type Recharge_firstCreateArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * The data needed to create a Recharge_first.
     */
    data: XOR<Recharge_firstCreateInput, Recharge_firstUncheckedCreateInput>
  }


  /**
   * Recharge_first createMany
   */
  export type Recharge_firstCreateManyArgs = {
    /**
     * The data used to create many Recharge_firsts.
     */
    data: Enumerable<Recharge_firstCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recharge_first update
   */
  export type Recharge_firstUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * The data needed to update a Recharge_first.
     */
    data: XOR<Recharge_firstUpdateInput, Recharge_firstUncheckedUpdateInput>
    /**
     * Choose, which Recharge_first to update.
     */
    where: Recharge_firstWhereUniqueInput
  }


  /**
   * Recharge_first updateMany
   */
  export type Recharge_firstUpdateManyArgs = {
    /**
     * The data used to update Recharge_firsts.
     */
    data: XOR<Recharge_firstUpdateManyMutationInput, Recharge_firstUncheckedUpdateManyInput>
    /**
     * Filter which Recharge_firsts to update
     */
    where?: Recharge_firstWhereInput
  }


  /**
   * Recharge_first upsert
   */
  export type Recharge_firstUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * The filter to search for the Recharge_first to update in case it exists.
     */
    where: Recharge_firstWhereUniqueInput
    /**
     * In case the Recharge_first found by the `where` argument doesn't exist, create a new Recharge_first with this data.
     */
    create: XOR<Recharge_firstCreateInput, Recharge_firstUncheckedCreateInput>
    /**
     * In case the Recharge_first was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Recharge_firstUpdateInput, Recharge_firstUncheckedUpdateInput>
  }


  /**
   * Recharge_first delete
   */
  export type Recharge_firstDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
    /**
     * Filter which Recharge_first to delete.
     */
    where: Recharge_firstWhereUniqueInput
  }


  /**
   * Recharge_first deleteMany
   */
  export type Recharge_firstDeleteManyArgs = {
    /**
     * Filter which Recharge_firsts to delete
     */
    where?: Recharge_firstWhereInput
  }


  /**
   * Recharge_first without action
   */
  export type Recharge_firstArgs = {
    /**
     * Select specific fields to fetch from the Recharge_first
     */
    select?: Recharge_firstSelect | null
  }



  /**
   * Model Rechargelog
   */


  export type AggregateRechargelog = {
    _count: RechargelogCountAggregateOutputType | null
    _avg: RechargelogAvgAggregateOutputType | null
    _sum: RechargelogSumAggregateOutputType | null
    _min: RechargelogMinAggregateOutputType | null
    _max: RechargelogMaxAggregateOutputType | null
  }

  export type RechargelogAvgAggregateOutputType = {
    id: number | null
    adminid: number | null
    userid: number | null
    czfee: number | null
    oldfee: number | null
    newfee: number | null
    type: number | null
  }

  export type RechargelogSumAggregateOutputType = {
    id: number | null
    adminid: number | null
    userid: number | null
    czfee: number | null
    oldfee: number | null
    newfee: number | null
    type: number | null
  }

  export type RechargelogMinAggregateOutputType = {
    id: number | null
    adminid: number | null
    userid: number | null
    createtime: string | null
    czfee: number | null
    oldfee: number | null
    newfee: number | null
    type: number | null
  }

  export type RechargelogMaxAggregateOutputType = {
    id: number | null
    adminid: number | null
    userid: number | null
    createtime: string | null
    czfee: number | null
    oldfee: number | null
    newfee: number | null
    type: number | null
  }

  export type RechargelogCountAggregateOutputType = {
    id: number
    adminid: number
    userid: number
    createtime: number
    czfee: number
    oldfee: number
    newfee: number
    type: number
    _all: number
  }


  export type RechargelogAvgAggregateInputType = {
    id?: true
    adminid?: true
    userid?: true
    czfee?: true
    oldfee?: true
    newfee?: true
    type?: true
  }

  export type RechargelogSumAggregateInputType = {
    id?: true
    adminid?: true
    userid?: true
    czfee?: true
    oldfee?: true
    newfee?: true
    type?: true
  }

  export type RechargelogMinAggregateInputType = {
    id?: true
    adminid?: true
    userid?: true
    createtime?: true
    czfee?: true
    oldfee?: true
    newfee?: true
    type?: true
  }

  export type RechargelogMaxAggregateInputType = {
    id?: true
    adminid?: true
    userid?: true
    createtime?: true
    czfee?: true
    oldfee?: true
    newfee?: true
    type?: true
  }

  export type RechargelogCountAggregateInputType = {
    id?: true
    adminid?: true
    userid?: true
    createtime?: true
    czfee?: true
    oldfee?: true
    newfee?: true
    type?: true
    _all?: true
  }

  export type RechargelogAggregateArgs = {
    /**
     * Filter which Rechargelog to aggregate.
     */
    where?: RechargelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rechargelogs to fetch.
     */
    orderBy?: Enumerable<RechargelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rechargelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rechargelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rechargelogs
    **/
    _count?: true | RechargelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargelogMaxAggregateInputType
  }

  export type GetRechargelogAggregateType<T extends RechargelogAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargelog[P]>
      : GetScalarType<T[P], AggregateRechargelog[P]>
  }




  export type RechargelogGroupByArgs = {
    where?: RechargelogWhereInput
    orderBy?: Enumerable<RechargelogOrderByWithAggregationInput>
    by: RechargelogScalarFieldEnum[]
    having?: RechargelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargelogCountAggregateInputType | true
    _avg?: RechargelogAvgAggregateInputType
    _sum?: RechargelogSumAggregateInputType
    _min?: RechargelogMinAggregateInputType
    _max?: RechargelogMaxAggregateInputType
  }


  export type RechargelogGroupByOutputType = {
    id: number
    adminid: number
    userid: number
    createtime: string
    czfee: number
    oldfee: number
    newfee: number
    type: number
    _count: RechargelogCountAggregateOutputType | null
    _avg: RechargelogAvgAggregateOutputType | null
    _sum: RechargelogSumAggregateOutputType | null
    _min: RechargelogMinAggregateOutputType | null
    _max: RechargelogMaxAggregateOutputType | null
  }

  type GetRechargelogGroupByPayload<T extends RechargelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RechargelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargelogGroupByOutputType[P]>
            : GetScalarType<T[P], RechargelogGroupByOutputType[P]>
        }
      >
    >


  export type RechargelogSelect = {
    id?: boolean
    adminid?: boolean
    userid?: boolean
    createtime?: boolean
    czfee?: boolean
    oldfee?: boolean
    newfee?: boolean
    type?: boolean
  }


  export type RechargelogGetPayload<S extends boolean | null | undefined | RechargelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Rechargelog :
    S extends undefined ? never :
    S extends { include: any } & (RechargelogArgs | RechargelogFindManyArgs)
    ? Rechargelog 
    : S extends { select: any } & (RechargelogArgs | RechargelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Rechargelog ? Rechargelog[P] : never
  } 
      : Rechargelog


  type RechargelogCountArgs = 
    Omit<RechargelogFindManyArgs, 'select' | 'include'> & {
      select?: RechargelogCountAggregateInputType | true
    }

  export interface RechargelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Rechargelog that matches the filter.
     * @param {RechargelogFindUniqueArgs} args - Arguments to find a Rechargelog
     * @example
     * // Get one Rechargelog
     * const rechargelog = await prisma.rechargelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RechargelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RechargelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Rechargelog'> extends True ? Prisma__RechargelogClient<RechargelogGetPayload<T>> : Prisma__RechargelogClient<RechargelogGetPayload<T> | null, null>

    /**
     * Find one Rechargelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RechargelogFindUniqueOrThrowArgs} args - Arguments to find a Rechargelog
     * @example
     * // Get one Rechargelog
     * const rechargelog = await prisma.rechargelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RechargelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RechargelogFindUniqueOrThrowArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Find the first Rechargelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogFindFirstArgs} args - Arguments to find a Rechargelog
     * @example
     * // Get one Rechargelog
     * const rechargelog = await prisma.rechargelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RechargelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RechargelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Rechargelog'> extends True ? Prisma__RechargelogClient<RechargelogGetPayload<T>> : Prisma__RechargelogClient<RechargelogGetPayload<T> | null, null>

    /**
     * Find the first Rechargelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogFindFirstOrThrowArgs} args - Arguments to find a Rechargelog
     * @example
     * // Get one Rechargelog
     * const rechargelog = await prisma.rechargelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RechargelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RechargelogFindFirstOrThrowArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Find zero or more Rechargelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rechargelogs
     * const rechargelogs = await prisma.rechargelog.findMany()
     * 
     * // Get first 10 Rechargelogs
     * const rechargelogs = await prisma.rechargelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargelogWithIdOnly = await prisma.rechargelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RechargelogFindManyArgs>(
      args?: SelectSubset<T, RechargelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<RechargelogGetPayload<T>>>

    /**
     * Create a Rechargelog.
     * @param {RechargelogCreateArgs} args - Arguments to create a Rechargelog.
     * @example
     * // Create one Rechargelog
     * const Rechargelog = await prisma.rechargelog.create({
     *   data: {
     *     // ... data to create a Rechargelog
     *   }
     * })
     * 
    **/
    create<T extends RechargelogCreateArgs>(
      args: SelectSubset<T, RechargelogCreateArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Create many Rechargelogs.
     *     @param {RechargelogCreateManyArgs} args - Arguments to create many Rechargelogs.
     *     @example
     *     // Create many Rechargelogs
     *     const rechargelog = await prisma.rechargelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RechargelogCreateManyArgs>(
      args?: SelectSubset<T, RechargelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rechargelog.
     * @param {RechargelogDeleteArgs} args - Arguments to delete one Rechargelog.
     * @example
     * // Delete one Rechargelog
     * const Rechargelog = await prisma.rechargelog.delete({
     *   where: {
     *     // ... filter to delete one Rechargelog
     *   }
     * })
     * 
    **/
    delete<T extends RechargelogDeleteArgs>(
      args: SelectSubset<T, RechargelogDeleteArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Update one Rechargelog.
     * @param {RechargelogUpdateArgs} args - Arguments to update one Rechargelog.
     * @example
     * // Update one Rechargelog
     * const rechargelog = await prisma.rechargelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RechargelogUpdateArgs>(
      args: SelectSubset<T, RechargelogUpdateArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Delete zero or more Rechargelogs.
     * @param {RechargelogDeleteManyArgs} args - Arguments to filter Rechargelogs to delete.
     * @example
     * // Delete a few Rechargelogs
     * const { count } = await prisma.rechargelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RechargelogDeleteManyArgs>(
      args?: SelectSubset<T, RechargelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rechargelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rechargelogs
     * const rechargelog = await prisma.rechargelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RechargelogUpdateManyArgs>(
      args: SelectSubset<T, RechargelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rechargelog.
     * @param {RechargelogUpsertArgs} args - Arguments to update or create a Rechargelog.
     * @example
     * // Update or create a Rechargelog
     * const rechargelog = await prisma.rechargelog.upsert({
     *   create: {
     *     // ... data to create a Rechargelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rechargelog we want to update
     *   }
     * })
    **/
    upsert<T extends RechargelogUpsertArgs>(
      args: SelectSubset<T, RechargelogUpsertArgs>
    ): Prisma__RechargelogClient<RechargelogGetPayload<T>>

    /**
     * Count the number of Rechargelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogCountArgs} args - Arguments to filter Rechargelogs to count.
     * @example
     * // Count the number of Rechargelogs
     * const count = await prisma.rechargelog.count({
     *   where: {
     *     // ... the filter for the Rechargelogs we want to count
     *   }
     * })
    **/
    count<T extends RechargelogCountArgs>(
      args?: Subset<T, RechargelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rechargelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargelogAggregateArgs>(args: Subset<T, RechargelogAggregateArgs>): Prisma.PrismaPromise<GetRechargelogAggregateType<T>>

    /**
     * Group by Rechargelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargelogGroupByArgs['orderBy'] }
        : { orderBy?: RechargelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Rechargelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RechargelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Rechargelog base type for findUnique actions
   */
  export type RechargelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter, which Rechargelog to fetch.
     */
    where: RechargelogWhereUniqueInput
  }

  /**
   * Rechargelog findUnique
   */
  export interface RechargelogFindUniqueArgs extends RechargelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Rechargelog findUniqueOrThrow
   */
  export type RechargelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter, which Rechargelog to fetch.
     */
    where: RechargelogWhereUniqueInput
  }


  /**
   * Rechargelog base type for findFirst actions
   */
  export type RechargelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter, which Rechargelog to fetch.
     */
    where?: RechargelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rechargelogs to fetch.
     */
    orderBy?: Enumerable<RechargelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rechargelogs.
     */
    cursor?: RechargelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rechargelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rechargelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rechargelogs.
     */
    distinct?: Enumerable<RechargelogScalarFieldEnum>
  }

  /**
   * Rechargelog findFirst
   */
  export interface RechargelogFindFirstArgs extends RechargelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Rechargelog findFirstOrThrow
   */
  export type RechargelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter, which Rechargelog to fetch.
     */
    where?: RechargelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rechargelogs to fetch.
     */
    orderBy?: Enumerable<RechargelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rechargelogs.
     */
    cursor?: RechargelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rechargelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rechargelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rechargelogs.
     */
    distinct?: Enumerable<RechargelogScalarFieldEnum>
  }


  /**
   * Rechargelog findMany
   */
  export type RechargelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter, which Rechargelogs to fetch.
     */
    where?: RechargelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rechargelogs to fetch.
     */
    orderBy?: Enumerable<RechargelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rechargelogs.
     */
    cursor?: RechargelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rechargelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rechargelogs.
     */
    skip?: number
    distinct?: Enumerable<RechargelogScalarFieldEnum>
  }


  /**
   * Rechargelog create
   */
  export type RechargelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * The data needed to create a Rechargelog.
     */
    data: XOR<RechargelogCreateInput, RechargelogUncheckedCreateInput>
  }


  /**
   * Rechargelog createMany
   */
  export type RechargelogCreateManyArgs = {
    /**
     * The data used to create many Rechargelogs.
     */
    data: Enumerable<RechargelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Rechargelog update
   */
  export type RechargelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * The data needed to update a Rechargelog.
     */
    data: XOR<RechargelogUpdateInput, RechargelogUncheckedUpdateInput>
    /**
     * Choose, which Rechargelog to update.
     */
    where: RechargelogWhereUniqueInput
  }


  /**
   * Rechargelog updateMany
   */
  export type RechargelogUpdateManyArgs = {
    /**
     * The data used to update Rechargelogs.
     */
    data: XOR<RechargelogUpdateManyMutationInput, RechargelogUncheckedUpdateManyInput>
    /**
     * Filter which Rechargelogs to update
     */
    where?: RechargelogWhereInput
  }


  /**
   * Rechargelog upsert
   */
  export type RechargelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * The filter to search for the Rechargelog to update in case it exists.
     */
    where: RechargelogWhereUniqueInput
    /**
     * In case the Rechargelog found by the `where` argument doesn't exist, create a new Rechargelog with this data.
     */
    create: XOR<RechargelogCreateInput, RechargelogUncheckedCreateInput>
    /**
     * In case the Rechargelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargelogUpdateInput, RechargelogUncheckedUpdateInput>
  }


  /**
   * Rechargelog delete
   */
  export type RechargelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
    /**
     * Filter which Rechargelog to delete.
     */
    where: RechargelogWhereUniqueInput
  }


  /**
   * Rechargelog deleteMany
   */
  export type RechargelogDeleteManyArgs = {
    /**
     * Filter which Rechargelogs to delete
     */
    where?: RechargelogWhereInput
  }


  /**
   * Rechargelog without action
   */
  export type RechargelogArgs = {
    /**
     * Select specific fields to fetch from the Rechargelog
     */
    select?: RechargelogSelect | null
  }



  /**
   * Model Returnscorelog
   */


  export type AggregateReturnscorelog = {
    _count: ReturnscorelogCountAggregateOutputType | null
    _avg: ReturnscorelogAvgAggregateOutputType | null
    _sum: ReturnscorelogSumAggregateOutputType | null
    _min: ReturnscorelogMinAggregateOutputType | null
    _max: ReturnscorelogMaxAggregateOutputType | null
  }

  export type ReturnscorelogAvgAggregateOutputType = {
    id: number | null
  }

  export type ReturnscorelogSumAggregateOutputType = {
    id: number | null
  }

  export type ReturnscorelogMinAggregateOutputType = {
    id: number | null
    msg: string | null
    ret: string | null
    createtime: string | null
  }

  export type ReturnscorelogMaxAggregateOutputType = {
    id: number | null
    msg: string | null
    ret: string | null
    createtime: string | null
  }

  export type ReturnscorelogCountAggregateOutputType = {
    id: number
    msg: number
    ret: number
    createtime: number
    _all: number
  }


  export type ReturnscorelogAvgAggregateInputType = {
    id?: true
  }

  export type ReturnscorelogSumAggregateInputType = {
    id?: true
  }

  export type ReturnscorelogMinAggregateInputType = {
    id?: true
    msg?: true
    ret?: true
    createtime?: true
  }

  export type ReturnscorelogMaxAggregateInputType = {
    id?: true
    msg?: true
    ret?: true
    createtime?: true
  }

  export type ReturnscorelogCountAggregateInputType = {
    id?: true
    msg?: true
    ret?: true
    createtime?: true
    _all?: true
  }

  export type ReturnscorelogAggregateArgs = {
    /**
     * Filter which Returnscorelog to aggregate.
     */
    where?: ReturnscorelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returnscorelogs to fetch.
     */
    orderBy?: Enumerable<ReturnscorelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnscorelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returnscorelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returnscorelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Returnscorelogs
    **/
    _count?: true | ReturnscorelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnscorelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnscorelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnscorelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnscorelogMaxAggregateInputType
  }

  export type GetReturnscorelogAggregateType<T extends ReturnscorelogAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnscorelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnscorelog[P]>
      : GetScalarType<T[P], AggregateReturnscorelog[P]>
  }




  export type ReturnscorelogGroupByArgs = {
    where?: ReturnscorelogWhereInput
    orderBy?: Enumerable<ReturnscorelogOrderByWithAggregationInput>
    by: ReturnscorelogScalarFieldEnum[]
    having?: ReturnscorelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnscorelogCountAggregateInputType | true
    _avg?: ReturnscorelogAvgAggregateInputType
    _sum?: ReturnscorelogSumAggregateInputType
    _min?: ReturnscorelogMinAggregateInputType
    _max?: ReturnscorelogMaxAggregateInputType
  }


  export type ReturnscorelogGroupByOutputType = {
    id: number
    msg: string
    ret: string
    createtime: string
    _count: ReturnscorelogCountAggregateOutputType | null
    _avg: ReturnscorelogAvgAggregateOutputType | null
    _sum: ReturnscorelogSumAggregateOutputType | null
    _min: ReturnscorelogMinAggregateOutputType | null
    _max: ReturnscorelogMaxAggregateOutputType | null
  }

  type GetReturnscorelogGroupByPayload<T extends ReturnscorelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReturnscorelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnscorelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnscorelogGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnscorelogGroupByOutputType[P]>
        }
      >
    >


  export type ReturnscorelogSelect = {
    id?: boolean
    msg?: boolean
    ret?: boolean
    createtime?: boolean
  }


  export type ReturnscorelogGetPayload<S extends boolean | null | undefined | ReturnscorelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Returnscorelog :
    S extends undefined ? never :
    S extends { include: any } & (ReturnscorelogArgs | ReturnscorelogFindManyArgs)
    ? Returnscorelog 
    : S extends { select: any } & (ReturnscorelogArgs | ReturnscorelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Returnscorelog ? Returnscorelog[P] : never
  } 
      : Returnscorelog


  type ReturnscorelogCountArgs = 
    Omit<ReturnscorelogFindManyArgs, 'select' | 'include'> & {
      select?: ReturnscorelogCountAggregateInputType | true
    }

  export interface ReturnscorelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Returnscorelog that matches the filter.
     * @param {ReturnscorelogFindUniqueArgs} args - Arguments to find a Returnscorelog
     * @example
     * // Get one Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReturnscorelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReturnscorelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Returnscorelog'> extends True ? Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>> : Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T> | null, null>

    /**
     * Find one Returnscorelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReturnscorelogFindUniqueOrThrowArgs} args - Arguments to find a Returnscorelog
     * @example
     * // Get one Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReturnscorelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReturnscorelogFindUniqueOrThrowArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Find the first Returnscorelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogFindFirstArgs} args - Arguments to find a Returnscorelog
     * @example
     * // Get one Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReturnscorelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReturnscorelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Returnscorelog'> extends True ? Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>> : Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T> | null, null>

    /**
     * Find the first Returnscorelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogFindFirstOrThrowArgs} args - Arguments to find a Returnscorelog
     * @example
     * // Get one Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReturnscorelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReturnscorelogFindFirstOrThrowArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Find zero or more Returnscorelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Returnscorelogs
     * const returnscorelogs = await prisma.returnscorelog.findMany()
     * 
     * // Get first 10 Returnscorelogs
     * const returnscorelogs = await prisma.returnscorelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnscorelogWithIdOnly = await prisma.returnscorelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReturnscorelogFindManyArgs>(
      args?: SelectSubset<T, ReturnscorelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReturnscorelogGetPayload<T>>>

    /**
     * Create a Returnscorelog.
     * @param {ReturnscorelogCreateArgs} args - Arguments to create a Returnscorelog.
     * @example
     * // Create one Returnscorelog
     * const Returnscorelog = await prisma.returnscorelog.create({
     *   data: {
     *     // ... data to create a Returnscorelog
     *   }
     * })
     * 
    **/
    create<T extends ReturnscorelogCreateArgs>(
      args: SelectSubset<T, ReturnscorelogCreateArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Create many Returnscorelogs.
     *     @param {ReturnscorelogCreateManyArgs} args - Arguments to create many Returnscorelogs.
     *     @example
     *     // Create many Returnscorelogs
     *     const returnscorelog = await prisma.returnscorelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReturnscorelogCreateManyArgs>(
      args?: SelectSubset<T, ReturnscorelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Returnscorelog.
     * @param {ReturnscorelogDeleteArgs} args - Arguments to delete one Returnscorelog.
     * @example
     * // Delete one Returnscorelog
     * const Returnscorelog = await prisma.returnscorelog.delete({
     *   where: {
     *     // ... filter to delete one Returnscorelog
     *   }
     * })
     * 
    **/
    delete<T extends ReturnscorelogDeleteArgs>(
      args: SelectSubset<T, ReturnscorelogDeleteArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Update one Returnscorelog.
     * @param {ReturnscorelogUpdateArgs} args - Arguments to update one Returnscorelog.
     * @example
     * // Update one Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReturnscorelogUpdateArgs>(
      args: SelectSubset<T, ReturnscorelogUpdateArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Delete zero or more Returnscorelogs.
     * @param {ReturnscorelogDeleteManyArgs} args - Arguments to filter Returnscorelogs to delete.
     * @example
     * // Delete a few Returnscorelogs
     * const { count } = await prisma.returnscorelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReturnscorelogDeleteManyArgs>(
      args?: SelectSubset<T, ReturnscorelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Returnscorelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Returnscorelogs
     * const returnscorelog = await prisma.returnscorelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReturnscorelogUpdateManyArgs>(
      args: SelectSubset<T, ReturnscorelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Returnscorelog.
     * @param {ReturnscorelogUpsertArgs} args - Arguments to update or create a Returnscorelog.
     * @example
     * // Update or create a Returnscorelog
     * const returnscorelog = await prisma.returnscorelog.upsert({
     *   create: {
     *     // ... data to create a Returnscorelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Returnscorelog we want to update
     *   }
     * })
    **/
    upsert<T extends ReturnscorelogUpsertArgs>(
      args: SelectSubset<T, ReturnscorelogUpsertArgs>
    ): Prisma__ReturnscorelogClient<ReturnscorelogGetPayload<T>>

    /**
     * Count the number of Returnscorelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogCountArgs} args - Arguments to filter Returnscorelogs to count.
     * @example
     * // Count the number of Returnscorelogs
     * const count = await prisma.returnscorelog.count({
     *   where: {
     *     // ... the filter for the Returnscorelogs we want to count
     *   }
     * })
    **/
    count<T extends ReturnscorelogCountArgs>(
      args?: Subset<T, ReturnscorelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnscorelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Returnscorelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnscorelogAggregateArgs>(args: Subset<T, ReturnscorelogAggregateArgs>): Prisma.PrismaPromise<GetReturnscorelogAggregateType<T>>

    /**
     * Group by Returnscorelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnscorelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnscorelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnscorelogGroupByArgs['orderBy'] }
        : { orderBy?: ReturnscorelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnscorelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnscorelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Returnscorelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReturnscorelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Returnscorelog base type for findUnique actions
   */
  export type ReturnscorelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter, which Returnscorelog to fetch.
     */
    where: ReturnscorelogWhereUniqueInput
  }

  /**
   * Returnscorelog findUnique
   */
  export interface ReturnscorelogFindUniqueArgs extends ReturnscorelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Returnscorelog findUniqueOrThrow
   */
  export type ReturnscorelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter, which Returnscorelog to fetch.
     */
    where: ReturnscorelogWhereUniqueInput
  }


  /**
   * Returnscorelog base type for findFirst actions
   */
  export type ReturnscorelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter, which Returnscorelog to fetch.
     */
    where?: ReturnscorelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returnscorelogs to fetch.
     */
    orderBy?: Enumerable<ReturnscorelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Returnscorelogs.
     */
    cursor?: ReturnscorelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returnscorelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returnscorelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Returnscorelogs.
     */
    distinct?: Enumerable<ReturnscorelogScalarFieldEnum>
  }

  /**
   * Returnscorelog findFirst
   */
  export interface ReturnscorelogFindFirstArgs extends ReturnscorelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Returnscorelog findFirstOrThrow
   */
  export type ReturnscorelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter, which Returnscorelog to fetch.
     */
    where?: ReturnscorelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returnscorelogs to fetch.
     */
    orderBy?: Enumerable<ReturnscorelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Returnscorelogs.
     */
    cursor?: ReturnscorelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returnscorelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returnscorelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Returnscorelogs.
     */
    distinct?: Enumerable<ReturnscorelogScalarFieldEnum>
  }


  /**
   * Returnscorelog findMany
   */
  export type ReturnscorelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter, which Returnscorelogs to fetch.
     */
    where?: ReturnscorelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returnscorelogs to fetch.
     */
    orderBy?: Enumerable<ReturnscorelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Returnscorelogs.
     */
    cursor?: ReturnscorelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returnscorelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returnscorelogs.
     */
    skip?: number
    distinct?: Enumerable<ReturnscorelogScalarFieldEnum>
  }


  /**
   * Returnscorelog create
   */
  export type ReturnscorelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * The data needed to create a Returnscorelog.
     */
    data: XOR<ReturnscorelogCreateInput, ReturnscorelogUncheckedCreateInput>
  }


  /**
   * Returnscorelog createMany
   */
  export type ReturnscorelogCreateManyArgs = {
    /**
     * The data used to create many Returnscorelogs.
     */
    data: Enumerable<ReturnscorelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Returnscorelog update
   */
  export type ReturnscorelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * The data needed to update a Returnscorelog.
     */
    data: XOR<ReturnscorelogUpdateInput, ReturnscorelogUncheckedUpdateInput>
    /**
     * Choose, which Returnscorelog to update.
     */
    where: ReturnscorelogWhereUniqueInput
  }


  /**
   * Returnscorelog updateMany
   */
  export type ReturnscorelogUpdateManyArgs = {
    /**
     * The data used to update Returnscorelogs.
     */
    data: XOR<ReturnscorelogUpdateManyMutationInput, ReturnscorelogUncheckedUpdateManyInput>
    /**
     * Filter which Returnscorelogs to update
     */
    where?: ReturnscorelogWhereInput
  }


  /**
   * Returnscorelog upsert
   */
  export type ReturnscorelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * The filter to search for the Returnscorelog to update in case it exists.
     */
    where: ReturnscorelogWhereUniqueInput
    /**
     * In case the Returnscorelog found by the `where` argument doesn't exist, create a new Returnscorelog with this data.
     */
    create: XOR<ReturnscorelogCreateInput, ReturnscorelogUncheckedCreateInput>
    /**
     * In case the Returnscorelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnscorelogUpdateInput, ReturnscorelogUncheckedUpdateInput>
  }


  /**
   * Returnscorelog delete
   */
  export type ReturnscorelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
    /**
     * Filter which Returnscorelog to delete.
     */
    where: ReturnscorelogWhereUniqueInput
  }


  /**
   * Returnscorelog deleteMany
   */
  export type ReturnscorelogDeleteManyArgs = {
    /**
     * Filter which Returnscorelogs to delete
     */
    where?: ReturnscorelogWhereInput
  }


  /**
   * Returnscorelog without action
   */
  export type ReturnscorelogArgs = {
    /**
     * Select specific fields to fetch from the Returnscorelog
     */
    select?: ReturnscorelogSelect | null
  }



  /**
   * Model Score_changelog
   */


  export type AggregateScore_changelog = {
    _count: Score_changelogCountAggregateOutputType | null
    _avg: Score_changelogAvgAggregateOutputType | null
    _sum: Score_changelogSumAggregateOutputType | null
    _min: Score_changelogMinAggregateOutputType | null
    _max: Score_changelogMaxAggregateOutputType | null
  }

  export type Score_changelogAvgAggregateOutputType = {
    id: number | null
  }

  export type Score_changelogSumAggregateOutputType = {
    id: number | null
  }

  export type Score_changelogMinAggregateOutputType = {
    id: number | null
    userid: string | null
    ret: string | null
    createtime: string | null
  }

  export type Score_changelogMaxAggregateOutputType = {
    id: number | null
    userid: string | null
    ret: string | null
    createtime: string | null
  }

  export type Score_changelogCountAggregateOutputType = {
    id: number
    userid: number
    ret: number
    createtime: number
    _all: number
  }


  export type Score_changelogAvgAggregateInputType = {
    id?: true
  }

  export type Score_changelogSumAggregateInputType = {
    id?: true
  }

  export type Score_changelogMinAggregateInputType = {
    id?: true
    userid?: true
    ret?: true
    createtime?: true
  }

  export type Score_changelogMaxAggregateInputType = {
    id?: true
    userid?: true
    ret?: true
    createtime?: true
  }

  export type Score_changelogCountAggregateInputType = {
    id?: true
    userid?: true
    ret?: true
    createtime?: true
    _all?: true
  }

  export type Score_changelogAggregateArgs = {
    /**
     * Filter which Score_changelog to aggregate.
     */
    where?: Score_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Score_changelogs to fetch.
     */
    orderBy?: Enumerable<Score_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Score_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Score_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Score_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Score_changelogs
    **/
    _count?: true | Score_changelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Score_changelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Score_changelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Score_changelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Score_changelogMaxAggregateInputType
  }

  export type GetScore_changelogAggregateType<T extends Score_changelogAggregateArgs> = {
        [P in keyof T & keyof AggregateScore_changelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScore_changelog[P]>
      : GetScalarType<T[P], AggregateScore_changelog[P]>
  }




  export type Score_changelogGroupByArgs = {
    where?: Score_changelogWhereInput
    orderBy?: Enumerable<Score_changelogOrderByWithAggregationInput>
    by: Score_changelogScalarFieldEnum[]
    having?: Score_changelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Score_changelogCountAggregateInputType | true
    _avg?: Score_changelogAvgAggregateInputType
    _sum?: Score_changelogSumAggregateInputType
    _min?: Score_changelogMinAggregateInputType
    _max?: Score_changelogMaxAggregateInputType
  }


  export type Score_changelogGroupByOutputType = {
    id: number
    userid: string
    ret: string
    createtime: string
    _count: Score_changelogCountAggregateOutputType | null
    _avg: Score_changelogAvgAggregateOutputType | null
    _sum: Score_changelogSumAggregateOutputType | null
    _min: Score_changelogMinAggregateOutputType | null
    _max: Score_changelogMaxAggregateOutputType | null
  }

  type GetScore_changelogGroupByPayload<T extends Score_changelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Score_changelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Score_changelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Score_changelogGroupByOutputType[P]>
            : GetScalarType<T[P], Score_changelogGroupByOutputType[P]>
        }
      >
    >


  export type Score_changelogSelect = {
    id?: boolean
    userid?: boolean
    ret?: boolean
    createtime?: boolean
  }


  export type Score_changelogGetPayload<S extends boolean | null | undefined | Score_changelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Score_changelog :
    S extends undefined ? never :
    S extends { include: any } & (Score_changelogArgs | Score_changelogFindManyArgs)
    ? Score_changelog 
    : S extends { select: any } & (Score_changelogArgs | Score_changelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Score_changelog ? Score_changelog[P] : never
  } 
      : Score_changelog


  type Score_changelogCountArgs = 
    Omit<Score_changelogFindManyArgs, 'select' | 'include'> & {
      select?: Score_changelogCountAggregateInputType | true
    }

  export interface Score_changelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Score_changelog that matches the filter.
     * @param {Score_changelogFindUniqueArgs} args - Arguments to find a Score_changelog
     * @example
     * // Get one Score_changelog
     * const score_changelog = await prisma.score_changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Score_changelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Score_changelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Score_changelog'> extends True ? Prisma__Score_changelogClient<Score_changelogGetPayload<T>> : Prisma__Score_changelogClient<Score_changelogGetPayload<T> | null, null>

    /**
     * Find one Score_changelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Score_changelogFindUniqueOrThrowArgs} args - Arguments to find a Score_changelog
     * @example
     * // Get one Score_changelog
     * const score_changelog = await prisma.score_changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Score_changelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Score_changelogFindUniqueOrThrowArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Find the first Score_changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogFindFirstArgs} args - Arguments to find a Score_changelog
     * @example
     * // Get one Score_changelog
     * const score_changelog = await prisma.score_changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Score_changelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Score_changelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Score_changelog'> extends True ? Prisma__Score_changelogClient<Score_changelogGetPayload<T>> : Prisma__Score_changelogClient<Score_changelogGetPayload<T> | null, null>

    /**
     * Find the first Score_changelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogFindFirstOrThrowArgs} args - Arguments to find a Score_changelog
     * @example
     * // Get one Score_changelog
     * const score_changelog = await prisma.score_changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Score_changelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Score_changelogFindFirstOrThrowArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Find zero or more Score_changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Score_changelogs
     * const score_changelogs = await prisma.score_changelog.findMany()
     * 
     * // Get first 10 Score_changelogs
     * const score_changelogs = await prisma.score_changelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const score_changelogWithIdOnly = await prisma.score_changelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Score_changelogFindManyArgs>(
      args?: SelectSubset<T, Score_changelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<Score_changelogGetPayload<T>>>

    /**
     * Create a Score_changelog.
     * @param {Score_changelogCreateArgs} args - Arguments to create a Score_changelog.
     * @example
     * // Create one Score_changelog
     * const Score_changelog = await prisma.score_changelog.create({
     *   data: {
     *     // ... data to create a Score_changelog
     *   }
     * })
     * 
    **/
    create<T extends Score_changelogCreateArgs>(
      args: SelectSubset<T, Score_changelogCreateArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Create many Score_changelogs.
     *     @param {Score_changelogCreateManyArgs} args - Arguments to create many Score_changelogs.
     *     @example
     *     // Create many Score_changelogs
     *     const score_changelog = await prisma.score_changelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Score_changelogCreateManyArgs>(
      args?: SelectSubset<T, Score_changelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Score_changelog.
     * @param {Score_changelogDeleteArgs} args - Arguments to delete one Score_changelog.
     * @example
     * // Delete one Score_changelog
     * const Score_changelog = await prisma.score_changelog.delete({
     *   where: {
     *     // ... filter to delete one Score_changelog
     *   }
     * })
     * 
    **/
    delete<T extends Score_changelogDeleteArgs>(
      args: SelectSubset<T, Score_changelogDeleteArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Update one Score_changelog.
     * @param {Score_changelogUpdateArgs} args - Arguments to update one Score_changelog.
     * @example
     * // Update one Score_changelog
     * const score_changelog = await prisma.score_changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Score_changelogUpdateArgs>(
      args: SelectSubset<T, Score_changelogUpdateArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Delete zero or more Score_changelogs.
     * @param {Score_changelogDeleteManyArgs} args - Arguments to filter Score_changelogs to delete.
     * @example
     * // Delete a few Score_changelogs
     * const { count } = await prisma.score_changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Score_changelogDeleteManyArgs>(
      args?: SelectSubset<T, Score_changelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Score_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Score_changelogs
     * const score_changelog = await prisma.score_changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Score_changelogUpdateManyArgs>(
      args: SelectSubset<T, Score_changelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Score_changelog.
     * @param {Score_changelogUpsertArgs} args - Arguments to update or create a Score_changelog.
     * @example
     * // Update or create a Score_changelog
     * const score_changelog = await prisma.score_changelog.upsert({
     *   create: {
     *     // ... data to create a Score_changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Score_changelog we want to update
     *   }
     * })
    **/
    upsert<T extends Score_changelogUpsertArgs>(
      args: SelectSubset<T, Score_changelogUpsertArgs>
    ): Prisma__Score_changelogClient<Score_changelogGetPayload<T>>

    /**
     * Count the number of Score_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogCountArgs} args - Arguments to filter Score_changelogs to count.
     * @example
     * // Count the number of Score_changelogs
     * const count = await prisma.score_changelog.count({
     *   where: {
     *     // ... the filter for the Score_changelogs we want to count
     *   }
     * })
    **/
    count<T extends Score_changelogCountArgs>(
      args?: Subset<T, Score_changelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Score_changelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Score_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Score_changelogAggregateArgs>(args: Subset<T, Score_changelogAggregateArgs>): Prisma.PrismaPromise<GetScore_changelogAggregateType<T>>

    /**
     * Group by Score_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Score_changelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Score_changelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Score_changelogGroupByArgs['orderBy'] }
        : { orderBy?: Score_changelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Score_changelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScore_changelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Score_changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Score_changelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Score_changelog base type for findUnique actions
   */
  export type Score_changelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter, which Score_changelog to fetch.
     */
    where: Score_changelogWhereUniqueInput
  }

  /**
   * Score_changelog findUnique
   */
  export interface Score_changelogFindUniqueArgs extends Score_changelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Score_changelog findUniqueOrThrow
   */
  export type Score_changelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter, which Score_changelog to fetch.
     */
    where: Score_changelogWhereUniqueInput
  }


  /**
   * Score_changelog base type for findFirst actions
   */
  export type Score_changelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter, which Score_changelog to fetch.
     */
    where?: Score_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Score_changelogs to fetch.
     */
    orderBy?: Enumerable<Score_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Score_changelogs.
     */
    cursor?: Score_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Score_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Score_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Score_changelogs.
     */
    distinct?: Enumerable<Score_changelogScalarFieldEnum>
  }

  /**
   * Score_changelog findFirst
   */
  export interface Score_changelogFindFirstArgs extends Score_changelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Score_changelog findFirstOrThrow
   */
  export type Score_changelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter, which Score_changelog to fetch.
     */
    where?: Score_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Score_changelogs to fetch.
     */
    orderBy?: Enumerable<Score_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Score_changelogs.
     */
    cursor?: Score_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Score_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Score_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Score_changelogs.
     */
    distinct?: Enumerable<Score_changelogScalarFieldEnum>
  }


  /**
   * Score_changelog findMany
   */
  export type Score_changelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter, which Score_changelogs to fetch.
     */
    where?: Score_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Score_changelogs to fetch.
     */
    orderBy?: Enumerable<Score_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Score_changelogs.
     */
    cursor?: Score_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Score_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Score_changelogs.
     */
    skip?: number
    distinct?: Enumerable<Score_changelogScalarFieldEnum>
  }


  /**
   * Score_changelog create
   */
  export type Score_changelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * The data needed to create a Score_changelog.
     */
    data: XOR<Score_changelogCreateInput, Score_changelogUncheckedCreateInput>
  }


  /**
   * Score_changelog createMany
   */
  export type Score_changelogCreateManyArgs = {
    /**
     * The data used to create many Score_changelogs.
     */
    data: Enumerable<Score_changelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Score_changelog update
   */
  export type Score_changelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * The data needed to update a Score_changelog.
     */
    data: XOR<Score_changelogUpdateInput, Score_changelogUncheckedUpdateInput>
    /**
     * Choose, which Score_changelog to update.
     */
    where: Score_changelogWhereUniqueInput
  }


  /**
   * Score_changelog updateMany
   */
  export type Score_changelogUpdateManyArgs = {
    /**
     * The data used to update Score_changelogs.
     */
    data: XOR<Score_changelogUpdateManyMutationInput, Score_changelogUncheckedUpdateManyInput>
    /**
     * Filter which Score_changelogs to update
     */
    where?: Score_changelogWhereInput
  }


  /**
   * Score_changelog upsert
   */
  export type Score_changelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * The filter to search for the Score_changelog to update in case it exists.
     */
    where: Score_changelogWhereUniqueInput
    /**
     * In case the Score_changelog found by the `where` argument doesn't exist, create a new Score_changelog with this data.
     */
    create: XOR<Score_changelogCreateInput, Score_changelogUncheckedCreateInput>
    /**
     * In case the Score_changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Score_changelogUpdateInput, Score_changelogUncheckedUpdateInput>
  }


  /**
   * Score_changelog delete
   */
  export type Score_changelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
    /**
     * Filter which Score_changelog to delete.
     */
    where: Score_changelogWhereUniqueInput
  }


  /**
   * Score_changelog deleteMany
   */
  export type Score_changelogDeleteManyArgs = {
    /**
     * Filter which Score_changelogs to delete
     */
    where?: Score_changelogWhereInput
  }


  /**
   * Score_changelog without action
   */
  export type Score_changelogArgs = {
    /**
     * Select specific fields to fetch from the Score_changelog
     */
    select?: Score_changelogSelect | null
  }



  /**
   * Model Scoreout
   */


  export type AggregateScoreout = {
    _count: ScoreoutCountAggregateOutputType | null
    _avg: ScoreoutAvgAggregateOutputType | null
    _sum: ScoreoutSumAggregateOutputType | null
    _min: ScoreoutMinAggregateOutputType | null
    _max: ScoreoutMaxAggregateOutputType | null
  }

  export type ScoreoutAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    coin: number | null
    tax: number | null
    cardType: number | null
    cardId: number | null
  }

  export type ScoreoutSumAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    coin: number | null
    tax: number | null
    cardType: number | null
    cardId: number | null
  }

  export type ScoreoutMinAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    coin: number | null
    tax: number | null
    addDate: Date | null
    state: string | null
    outDate: Date | null
    cardType: number | null
    cardId: number | null
    out_trade_no: string | null
    zfb_account: string | null
    zfb_name: string | null
    remark: string | null
  }

  export type ScoreoutMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    score: number | null
    coin: number | null
    tax: number | null
    addDate: Date | null
    state: string | null
    outDate: Date | null
    cardType: number | null
    cardId: number | null
    out_trade_no: string | null
    zfb_account: string | null
    zfb_name: string | null
    remark: string | null
  }

  export type ScoreoutCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    coin: number
    tax: number
    addDate: number
    state: number
    outDate: number
    cardType: number
    cardId: number
    out_trade_no: number
    zfb_account: number
    zfb_name: number
    remark: number
    _all: number
  }


  export type ScoreoutAvgAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    coin?: true
    tax?: true
    cardType?: true
    cardId?: true
  }

  export type ScoreoutSumAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    coin?: true
    tax?: true
    cardType?: true
    cardId?: true
  }

  export type ScoreoutMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    coin?: true
    tax?: true
    addDate?: true
    state?: true
    outDate?: true
    cardType?: true
    cardId?: true
    out_trade_no?: true
    zfb_account?: true
    zfb_name?: true
    remark?: true
  }

  export type ScoreoutMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    coin?: true
    tax?: true
    addDate?: true
    state?: true
    outDate?: true
    cardType?: true
    cardId?: true
    out_trade_no?: true
    zfb_account?: true
    zfb_name?: true
    remark?: true
  }

  export type ScoreoutCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    coin?: true
    tax?: true
    addDate?: true
    state?: true
    outDate?: true
    cardType?: true
    cardId?: true
    out_trade_no?: true
    zfb_account?: true
    zfb_name?: true
    remark?: true
    _all?: true
  }

  export type ScoreoutAggregateArgs = {
    /**
     * Filter which Scoreout to aggregate.
     */
    where?: ScoreoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scoreouts to fetch.
     */
    orderBy?: Enumerable<ScoreoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoreoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scoreouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scoreouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scoreouts
    **/
    _count?: true | ScoreoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoreoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoreoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoreoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoreoutMaxAggregateInputType
  }

  export type GetScoreoutAggregateType<T extends ScoreoutAggregateArgs> = {
        [P in keyof T & keyof AggregateScoreout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoreout[P]>
      : GetScalarType<T[P], AggregateScoreout[P]>
  }




  export type ScoreoutGroupByArgs = {
    where?: ScoreoutWhereInput
    orderBy?: Enumerable<ScoreoutOrderByWithAggregationInput>
    by: ScoreoutScalarFieldEnum[]
    having?: ScoreoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoreoutCountAggregateInputType | true
    _avg?: ScoreoutAvgAggregateInputType
    _sum?: ScoreoutSumAggregateInputType
    _min?: ScoreoutMinAggregateInputType
    _max?: ScoreoutMaxAggregateInputType
  }


  export type ScoreoutGroupByOutputType = {
    id: number
    userId: number
    score: number
    coin: number
    tax: number
    addDate: Date
    state: string
    outDate: Date
    cardType: number
    cardId: number
    out_trade_no: string
    zfb_account: string
    zfb_name: string
    remark: string
    _count: ScoreoutCountAggregateOutputType | null
    _avg: ScoreoutAvgAggregateOutputType | null
    _sum: ScoreoutSumAggregateOutputType | null
    _min: ScoreoutMinAggregateOutputType | null
    _max: ScoreoutMaxAggregateOutputType | null
  }

  type GetScoreoutGroupByPayload<T extends ScoreoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ScoreoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoreoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoreoutGroupByOutputType[P]>
            : GetScalarType<T[P], ScoreoutGroupByOutputType[P]>
        }
      >
    >


  export type ScoreoutSelect = {
    id?: boolean
    userId?: boolean
    score?: boolean
    coin?: boolean
    tax?: boolean
    addDate?: boolean
    state?: boolean
    outDate?: boolean
    cardType?: boolean
    cardId?: boolean
    out_trade_no?: boolean
    zfb_account?: boolean
    zfb_name?: boolean
    remark?: boolean
  }


  export type ScoreoutGetPayload<S extends boolean | null | undefined | ScoreoutArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Scoreout :
    S extends undefined ? never :
    S extends { include: any } & (ScoreoutArgs | ScoreoutFindManyArgs)
    ? Scoreout 
    : S extends { select: any } & (ScoreoutArgs | ScoreoutFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Scoreout ? Scoreout[P] : never
  } 
      : Scoreout


  type ScoreoutCountArgs = 
    Omit<ScoreoutFindManyArgs, 'select' | 'include'> & {
      select?: ScoreoutCountAggregateInputType | true
    }

  export interface ScoreoutDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Scoreout that matches the filter.
     * @param {ScoreoutFindUniqueArgs} args - Arguments to find a Scoreout
     * @example
     * // Get one Scoreout
     * const scoreout = await prisma.scoreout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScoreoutFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScoreoutFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Scoreout'> extends True ? Prisma__ScoreoutClient<ScoreoutGetPayload<T>> : Prisma__ScoreoutClient<ScoreoutGetPayload<T> | null, null>

    /**
     * Find one Scoreout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ScoreoutFindUniqueOrThrowArgs} args - Arguments to find a Scoreout
     * @example
     * // Get one Scoreout
     * const scoreout = await prisma.scoreout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScoreoutFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ScoreoutFindUniqueOrThrowArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Find the first Scoreout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutFindFirstArgs} args - Arguments to find a Scoreout
     * @example
     * // Get one Scoreout
     * const scoreout = await prisma.scoreout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScoreoutFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScoreoutFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Scoreout'> extends True ? Prisma__ScoreoutClient<ScoreoutGetPayload<T>> : Prisma__ScoreoutClient<ScoreoutGetPayload<T> | null, null>

    /**
     * Find the first Scoreout that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutFindFirstOrThrowArgs} args - Arguments to find a Scoreout
     * @example
     * // Get one Scoreout
     * const scoreout = await prisma.scoreout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScoreoutFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScoreoutFindFirstOrThrowArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Find zero or more Scoreouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scoreouts
     * const scoreouts = await prisma.scoreout.findMany()
     * 
     * // Get first 10 Scoreouts
     * const scoreouts = await prisma.scoreout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoreoutWithIdOnly = await prisma.scoreout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScoreoutFindManyArgs>(
      args?: SelectSubset<T, ScoreoutFindManyArgs>
    ): Prisma.PrismaPromise<Array<ScoreoutGetPayload<T>>>

    /**
     * Create a Scoreout.
     * @param {ScoreoutCreateArgs} args - Arguments to create a Scoreout.
     * @example
     * // Create one Scoreout
     * const Scoreout = await prisma.scoreout.create({
     *   data: {
     *     // ... data to create a Scoreout
     *   }
     * })
     * 
    **/
    create<T extends ScoreoutCreateArgs>(
      args: SelectSubset<T, ScoreoutCreateArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Create many Scoreouts.
     *     @param {ScoreoutCreateManyArgs} args - Arguments to create many Scoreouts.
     *     @example
     *     // Create many Scoreouts
     *     const scoreout = await prisma.scoreout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScoreoutCreateManyArgs>(
      args?: SelectSubset<T, ScoreoutCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Scoreout.
     * @param {ScoreoutDeleteArgs} args - Arguments to delete one Scoreout.
     * @example
     * // Delete one Scoreout
     * const Scoreout = await prisma.scoreout.delete({
     *   where: {
     *     // ... filter to delete one Scoreout
     *   }
     * })
     * 
    **/
    delete<T extends ScoreoutDeleteArgs>(
      args: SelectSubset<T, ScoreoutDeleteArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Update one Scoreout.
     * @param {ScoreoutUpdateArgs} args - Arguments to update one Scoreout.
     * @example
     * // Update one Scoreout
     * const scoreout = await prisma.scoreout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScoreoutUpdateArgs>(
      args: SelectSubset<T, ScoreoutUpdateArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Delete zero or more Scoreouts.
     * @param {ScoreoutDeleteManyArgs} args - Arguments to filter Scoreouts to delete.
     * @example
     * // Delete a few Scoreouts
     * const { count } = await prisma.scoreout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScoreoutDeleteManyArgs>(
      args?: SelectSubset<T, ScoreoutDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scoreouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scoreouts
     * const scoreout = await prisma.scoreout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScoreoutUpdateManyArgs>(
      args: SelectSubset<T, ScoreoutUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scoreout.
     * @param {ScoreoutUpsertArgs} args - Arguments to update or create a Scoreout.
     * @example
     * // Update or create a Scoreout
     * const scoreout = await prisma.scoreout.upsert({
     *   create: {
     *     // ... data to create a Scoreout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scoreout we want to update
     *   }
     * })
    **/
    upsert<T extends ScoreoutUpsertArgs>(
      args: SelectSubset<T, ScoreoutUpsertArgs>
    ): Prisma__ScoreoutClient<ScoreoutGetPayload<T>>

    /**
     * Count the number of Scoreouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutCountArgs} args - Arguments to filter Scoreouts to count.
     * @example
     * // Count the number of Scoreouts
     * const count = await prisma.scoreout.count({
     *   where: {
     *     // ... the filter for the Scoreouts we want to count
     *   }
     * })
    **/
    count<T extends ScoreoutCountArgs>(
      args?: Subset<T, ScoreoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoreoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scoreout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoreoutAggregateArgs>(args: Subset<T, ScoreoutAggregateArgs>): Prisma.PrismaPromise<GetScoreoutAggregateType<T>>

    /**
     * Group by Scoreout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoreoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreoutGroupByArgs['orderBy'] }
        : { orderBy?: ScoreoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoreoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoreoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Scoreout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScoreoutClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Scoreout base type for findUnique actions
   */
  export type ScoreoutFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter, which Scoreout to fetch.
     */
    where: ScoreoutWhereUniqueInput
  }

  /**
   * Scoreout findUnique
   */
  export interface ScoreoutFindUniqueArgs extends ScoreoutFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Scoreout findUniqueOrThrow
   */
  export type ScoreoutFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter, which Scoreout to fetch.
     */
    where: ScoreoutWhereUniqueInput
  }


  /**
   * Scoreout base type for findFirst actions
   */
  export type ScoreoutFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter, which Scoreout to fetch.
     */
    where?: ScoreoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scoreouts to fetch.
     */
    orderBy?: Enumerable<ScoreoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scoreouts.
     */
    cursor?: ScoreoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scoreouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scoreouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scoreouts.
     */
    distinct?: Enumerable<ScoreoutScalarFieldEnum>
  }

  /**
   * Scoreout findFirst
   */
  export interface ScoreoutFindFirstArgs extends ScoreoutFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Scoreout findFirstOrThrow
   */
  export type ScoreoutFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter, which Scoreout to fetch.
     */
    where?: ScoreoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scoreouts to fetch.
     */
    orderBy?: Enumerable<ScoreoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scoreouts.
     */
    cursor?: ScoreoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scoreouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scoreouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scoreouts.
     */
    distinct?: Enumerable<ScoreoutScalarFieldEnum>
  }


  /**
   * Scoreout findMany
   */
  export type ScoreoutFindManyArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter, which Scoreouts to fetch.
     */
    where?: ScoreoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scoreouts to fetch.
     */
    orderBy?: Enumerable<ScoreoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scoreouts.
     */
    cursor?: ScoreoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scoreouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scoreouts.
     */
    skip?: number
    distinct?: Enumerable<ScoreoutScalarFieldEnum>
  }


  /**
   * Scoreout create
   */
  export type ScoreoutCreateArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * The data needed to create a Scoreout.
     */
    data: XOR<ScoreoutCreateInput, ScoreoutUncheckedCreateInput>
  }


  /**
   * Scoreout createMany
   */
  export type ScoreoutCreateManyArgs = {
    /**
     * The data used to create many Scoreouts.
     */
    data: Enumerable<ScoreoutCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Scoreout update
   */
  export type ScoreoutUpdateArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * The data needed to update a Scoreout.
     */
    data: XOR<ScoreoutUpdateInput, ScoreoutUncheckedUpdateInput>
    /**
     * Choose, which Scoreout to update.
     */
    where: ScoreoutWhereUniqueInput
  }


  /**
   * Scoreout updateMany
   */
  export type ScoreoutUpdateManyArgs = {
    /**
     * The data used to update Scoreouts.
     */
    data: XOR<ScoreoutUpdateManyMutationInput, ScoreoutUncheckedUpdateManyInput>
    /**
     * Filter which Scoreouts to update
     */
    where?: ScoreoutWhereInput
  }


  /**
   * Scoreout upsert
   */
  export type ScoreoutUpsertArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * The filter to search for the Scoreout to update in case it exists.
     */
    where: ScoreoutWhereUniqueInput
    /**
     * In case the Scoreout found by the `where` argument doesn't exist, create a new Scoreout with this data.
     */
    create: XOR<ScoreoutCreateInput, ScoreoutUncheckedCreateInput>
    /**
     * In case the Scoreout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoreoutUpdateInput, ScoreoutUncheckedUpdateInput>
  }


  /**
   * Scoreout delete
   */
  export type ScoreoutDeleteArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
    /**
     * Filter which Scoreout to delete.
     */
    where: ScoreoutWhereUniqueInput
  }


  /**
   * Scoreout deleteMany
   */
  export type ScoreoutDeleteManyArgs = {
    /**
     * Filter which Scoreouts to delete
     */
    where?: ScoreoutWhereInput
  }


  /**
   * Scoreout without action
   */
  export type ScoreoutArgs = {
    /**
     * Select specific fields to fetch from the Scoreout
     */
    select?: ScoreoutSelect | null
  }



  /**
   * Model Sendcoinlog
   */


  export type AggregateSendcoinlog = {
    _count: SendcoinlogCountAggregateOutputType | null
    _avg: SendcoinlogAvgAggregateOutputType | null
    _sum: SendcoinlogSumAggregateOutputType | null
    _min: SendcoinlogMinAggregateOutputType | null
    _max: SendcoinlogMaxAggregateOutputType | null
  }

  export type SendcoinlogAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    getcoinuserid: number | null
    sendcoin: number | null
  }

  export type SendcoinlogSumAggregateOutputType = {
    id: number | null
    userid: number | null
    getcoinuserid: number | null
    sendcoin: number | null
  }

  export type SendcoinlogMinAggregateOutputType = {
    id: number | null
    userid: number | null
    getcoinuserid: number | null
    sendcoin: number | null
    addtime: Date | null
  }

  export type SendcoinlogMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    getcoinuserid: number | null
    sendcoin: number | null
    addtime: Date | null
  }

  export type SendcoinlogCountAggregateOutputType = {
    id: number
    userid: number
    getcoinuserid: number
    sendcoin: number
    addtime: number
    _all: number
  }


  export type SendcoinlogAvgAggregateInputType = {
    id?: true
    userid?: true
    getcoinuserid?: true
    sendcoin?: true
  }

  export type SendcoinlogSumAggregateInputType = {
    id?: true
    userid?: true
    getcoinuserid?: true
    sendcoin?: true
  }

  export type SendcoinlogMinAggregateInputType = {
    id?: true
    userid?: true
    getcoinuserid?: true
    sendcoin?: true
    addtime?: true
  }

  export type SendcoinlogMaxAggregateInputType = {
    id?: true
    userid?: true
    getcoinuserid?: true
    sendcoin?: true
    addtime?: true
  }

  export type SendcoinlogCountAggregateInputType = {
    id?: true
    userid?: true
    getcoinuserid?: true
    sendcoin?: true
    addtime?: true
    _all?: true
  }

  export type SendcoinlogAggregateArgs = {
    /**
     * Filter which Sendcoinlog to aggregate.
     */
    where?: SendcoinlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sendcoinlogs to fetch.
     */
    orderBy?: Enumerable<SendcoinlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SendcoinlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sendcoinlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sendcoinlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sendcoinlogs
    **/
    _count?: true | SendcoinlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SendcoinlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SendcoinlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SendcoinlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SendcoinlogMaxAggregateInputType
  }

  export type GetSendcoinlogAggregateType<T extends SendcoinlogAggregateArgs> = {
        [P in keyof T & keyof AggregateSendcoinlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSendcoinlog[P]>
      : GetScalarType<T[P], AggregateSendcoinlog[P]>
  }




  export type SendcoinlogGroupByArgs = {
    where?: SendcoinlogWhereInput
    orderBy?: Enumerable<SendcoinlogOrderByWithAggregationInput>
    by: SendcoinlogScalarFieldEnum[]
    having?: SendcoinlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SendcoinlogCountAggregateInputType | true
    _avg?: SendcoinlogAvgAggregateInputType
    _sum?: SendcoinlogSumAggregateInputType
    _min?: SendcoinlogMinAggregateInputType
    _max?: SendcoinlogMaxAggregateInputType
  }


  export type SendcoinlogGroupByOutputType = {
    id: number
    userid: number
    getcoinuserid: number
    sendcoin: number
    addtime: Date
    _count: SendcoinlogCountAggregateOutputType | null
    _avg: SendcoinlogAvgAggregateOutputType | null
    _sum: SendcoinlogSumAggregateOutputType | null
    _min: SendcoinlogMinAggregateOutputType | null
    _max: SendcoinlogMaxAggregateOutputType | null
  }

  type GetSendcoinlogGroupByPayload<T extends SendcoinlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SendcoinlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SendcoinlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SendcoinlogGroupByOutputType[P]>
            : GetScalarType<T[P], SendcoinlogGroupByOutputType[P]>
        }
      >
    >


  export type SendcoinlogSelect = {
    id?: boolean
    userid?: boolean
    getcoinuserid?: boolean
    sendcoin?: boolean
    addtime?: boolean
  }


  export type SendcoinlogGetPayload<S extends boolean | null | undefined | SendcoinlogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Sendcoinlog :
    S extends undefined ? never :
    S extends { include: any } & (SendcoinlogArgs | SendcoinlogFindManyArgs)
    ? Sendcoinlog 
    : S extends { select: any } & (SendcoinlogArgs | SendcoinlogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Sendcoinlog ? Sendcoinlog[P] : never
  } 
      : Sendcoinlog


  type SendcoinlogCountArgs = 
    Omit<SendcoinlogFindManyArgs, 'select' | 'include'> & {
      select?: SendcoinlogCountAggregateInputType | true
    }

  export interface SendcoinlogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sendcoinlog that matches the filter.
     * @param {SendcoinlogFindUniqueArgs} args - Arguments to find a Sendcoinlog
     * @example
     * // Get one Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SendcoinlogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SendcoinlogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sendcoinlog'> extends True ? Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>> : Prisma__SendcoinlogClient<SendcoinlogGetPayload<T> | null, null>

    /**
     * Find one Sendcoinlog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SendcoinlogFindUniqueOrThrowArgs} args - Arguments to find a Sendcoinlog
     * @example
     * // Get one Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SendcoinlogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SendcoinlogFindUniqueOrThrowArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Find the first Sendcoinlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogFindFirstArgs} args - Arguments to find a Sendcoinlog
     * @example
     * // Get one Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SendcoinlogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SendcoinlogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sendcoinlog'> extends True ? Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>> : Prisma__SendcoinlogClient<SendcoinlogGetPayload<T> | null, null>

    /**
     * Find the first Sendcoinlog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogFindFirstOrThrowArgs} args - Arguments to find a Sendcoinlog
     * @example
     * // Get one Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SendcoinlogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SendcoinlogFindFirstOrThrowArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Find zero or more Sendcoinlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sendcoinlogs
     * const sendcoinlogs = await prisma.sendcoinlog.findMany()
     * 
     * // Get first 10 Sendcoinlogs
     * const sendcoinlogs = await prisma.sendcoinlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sendcoinlogWithIdOnly = await prisma.sendcoinlog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SendcoinlogFindManyArgs>(
      args?: SelectSubset<T, SendcoinlogFindManyArgs>
    ): Prisma.PrismaPromise<Array<SendcoinlogGetPayload<T>>>

    /**
     * Create a Sendcoinlog.
     * @param {SendcoinlogCreateArgs} args - Arguments to create a Sendcoinlog.
     * @example
     * // Create one Sendcoinlog
     * const Sendcoinlog = await prisma.sendcoinlog.create({
     *   data: {
     *     // ... data to create a Sendcoinlog
     *   }
     * })
     * 
    **/
    create<T extends SendcoinlogCreateArgs>(
      args: SelectSubset<T, SendcoinlogCreateArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Create many Sendcoinlogs.
     *     @param {SendcoinlogCreateManyArgs} args - Arguments to create many Sendcoinlogs.
     *     @example
     *     // Create many Sendcoinlogs
     *     const sendcoinlog = await prisma.sendcoinlog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SendcoinlogCreateManyArgs>(
      args?: SelectSubset<T, SendcoinlogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sendcoinlog.
     * @param {SendcoinlogDeleteArgs} args - Arguments to delete one Sendcoinlog.
     * @example
     * // Delete one Sendcoinlog
     * const Sendcoinlog = await prisma.sendcoinlog.delete({
     *   where: {
     *     // ... filter to delete one Sendcoinlog
     *   }
     * })
     * 
    **/
    delete<T extends SendcoinlogDeleteArgs>(
      args: SelectSubset<T, SendcoinlogDeleteArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Update one Sendcoinlog.
     * @param {SendcoinlogUpdateArgs} args - Arguments to update one Sendcoinlog.
     * @example
     * // Update one Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SendcoinlogUpdateArgs>(
      args: SelectSubset<T, SendcoinlogUpdateArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Delete zero or more Sendcoinlogs.
     * @param {SendcoinlogDeleteManyArgs} args - Arguments to filter Sendcoinlogs to delete.
     * @example
     * // Delete a few Sendcoinlogs
     * const { count } = await prisma.sendcoinlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SendcoinlogDeleteManyArgs>(
      args?: SelectSubset<T, SendcoinlogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sendcoinlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sendcoinlogs
     * const sendcoinlog = await prisma.sendcoinlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SendcoinlogUpdateManyArgs>(
      args: SelectSubset<T, SendcoinlogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sendcoinlog.
     * @param {SendcoinlogUpsertArgs} args - Arguments to update or create a Sendcoinlog.
     * @example
     * // Update or create a Sendcoinlog
     * const sendcoinlog = await prisma.sendcoinlog.upsert({
     *   create: {
     *     // ... data to create a Sendcoinlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sendcoinlog we want to update
     *   }
     * })
    **/
    upsert<T extends SendcoinlogUpsertArgs>(
      args: SelectSubset<T, SendcoinlogUpsertArgs>
    ): Prisma__SendcoinlogClient<SendcoinlogGetPayload<T>>

    /**
     * Count the number of Sendcoinlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogCountArgs} args - Arguments to filter Sendcoinlogs to count.
     * @example
     * // Count the number of Sendcoinlogs
     * const count = await prisma.sendcoinlog.count({
     *   where: {
     *     // ... the filter for the Sendcoinlogs we want to count
     *   }
     * })
    **/
    count<T extends SendcoinlogCountArgs>(
      args?: Subset<T, SendcoinlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SendcoinlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sendcoinlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SendcoinlogAggregateArgs>(args: Subset<T, SendcoinlogAggregateArgs>): Prisma.PrismaPromise<GetSendcoinlogAggregateType<T>>

    /**
     * Group by Sendcoinlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SendcoinlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SendcoinlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SendcoinlogGroupByArgs['orderBy'] }
        : { orderBy?: SendcoinlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SendcoinlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSendcoinlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sendcoinlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SendcoinlogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sendcoinlog base type for findUnique actions
   */
  export type SendcoinlogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter, which Sendcoinlog to fetch.
     */
    where: SendcoinlogWhereUniqueInput
  }

  /**
   * Sendcoinlog findUnique
   */
  export interface SendcoinlogFindUniqueArgs extends SendcoinlogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sendcoinlog findUniqueOrThrow
   */
  export type SendcoinlogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter, which Sendcoinlog to fetch.
     */
    where: SendcoinlogWhereUniqueInput
  }


  /**
   * Sendcoinlog base type for findFirst actions
   */
  export type SendcoinlogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter, which Sendcoinlog to fetch.
     */
    where?: SendcoinlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sendcoinlogs to fetch.
     */
    orderBy?: Enumerable<SendcoinlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sendcoinlogs.
     */
    cursor?: SendcoinlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sendcoinlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sendcoinlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sendcoinlogs.
     */
    distinct?: Enumerable<SendcoinlogScalarFieldEnum>
  }

  /**
   * Sendcoinlog findFirst
   */
  export interface SendcoinlogFindFirstArgs extends SendcoinlogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sendcoinlog findFirstOrThrow
   */
  export type SendcoinlogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter, which Sendcoinlog to fetch.
     */
    where?: SendcoinlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sendcoinlogs to fetch.
     */
    orderBy?: Enumerable<SendcoinlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sendcoinlogs.
     */
    cursor?: SendcoinlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sendcoinlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sendcoinlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sendcoinlogs.
     */
    distinct?: Enumerable<SendcoinlogScalarFieldEnum>
  }


  /**
   * Sendcoinlog findMany
   */
  export type SendcoinlogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter, which Sendcoinlogs to fetch.
     */
    where?: SendcoinlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sendcoinlogs to fetch.
     */
    orderBy?: Enumerable<SendcoinlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sendcoinlogs.
     */
    cursor?: SendcoinlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sendcoinlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sendcoinlogs.
     */
    skip?: number
    distinct?: Enumerable<SendcoinlogScalarFieldEnum>
  }


  /**
   * Sendcoinlog create
   */
  export type SendcoinlogCreateArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * The data needed to create a Sendcoinlog.
     */
    data: XOR<SendcoinlogCreateInput, SendcoinlogUncheckedCreateInput>
  }


  /**
   * Sendcoinlog createMany
   */
  export type SendcoinlogCreateManyArgs = {
    /**
     * The data used to create many Sendcoinlogs.
     */
    data: Enumerable<SendcoinlogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sendcoinlog update
   */
  export type SendcoinlogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * The data needed to update a Sendcoinlog.
     */
    data: XOR<SendcoinlogUpdateInput, SendcoinlogUncheckedUpdateInput>
    /**
     * Choose, which Sendcoinlog to update.
     */
    where: SendcoinlogWhereUniqueInput
  }


  /**
   * Sendcoinlog updateMany
   */
  export type SendcoinlogUpdateManyArgs = {
    /**
     * The data used to update Sendcoinlogs.
     */
    data: XOR<SendcoinlogUpdateManyMutationInput, SendcoinlogUncheckedUpdateManyInput>
    /**
     * Filter which Sendcoinlogs to update
     */
    where?: SendcoinlogWhereInput
  }


  /**
   * Sendcoinlog upsert
   */
  export type SendcoinlogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * The filter to search for the Sendcoinlog to update in case it exists.
     */
    where: SendcoinlogWhereUniqueInput
    /**
     * In case the Sendcoinlog found by the `where` argument doesn't exist, create a new Sendcoinlog with this data.
     */
    create: XOR<SendcoinlogCreateInput, SendcoinlogUncheckedCreateInput>
    /**
     * In case the Sendcoinlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SendcoinlogUpdateInput, SendcoinlogUncheckedUpdateInput>
  }


  /**
   * Sendcoinlog delete
   */
  export type SendcoinlogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
    /**
     * Filter which Sendcoinlog to delete.
     */
    where: SendcoinlogWhereUniqueInput
  }


  /**
   * Sendcoinlog deleteMany
   */
  export type SendcoinlogDeleteManyArgs = {
    /**
     * Filter which Sendcoinlogs to delete
     */
    where?: SendcoinlogWhereInput
  }


  /**
   * Sendcoinlog without action
   */
  export type SendcoinlogArgs = {
    /**
     * Select specific fields to fetch from the Sendcoinlog
     */
    select?: SendcoinlogSelect | null
  }



  /**
   * Model Server_log
   */


  export type AggregateServer_log = {
    _count: Server_logCountAggregateOutputType | null
    _avg: Server_logAvgAggregateOutputType | null
    _sum: Server_logSumAggregateOutputType | null
    _min: Server_logMinAggregateOutputType | null
    _max: Server_logMaxAggregateOutputType | null
  }

  export type Server_logAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type Server_logSumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type Server_logMinAggregateOutputType = {
    id: number | null
    txt: string | null
    status: number | null
    createtime: string | null
    updatetime: string | null
  }

  export type Server_logMaxAggregateOutputType = {
    id: number | null
    txt: string | null
    status: number | null
    createtime: string | null
    updatetime: string | null
  }

  export type Server_logCountAggregateOutputType = {
    id: number
    txt: number
    status: number
    createtime: number
    updatetime: number
    _all: number
  }


  export type Server_logAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type Server_logSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type Server_logMinAggregateInputType = {
    id?: true
    txt?: true
    status?: true
    createtime?: true
    updatetime?: true
  }

  export type Server_logMaxAggregateInputType = {
    id?: true
    txt?: true
    status?: true
    createtime?: true
    updatetime?: true
  }

  export type Server_logCountAggregateInputType = {
    id?: true
    txt?: true
    status?: true
    createtime?: true
    updatetime?: true
    _all?: true
  }

  export type Server_logAggregateArgs = {
    /**
     * Filter which Server_log to aggregate.
     */
    where?: Server_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Server_logs to fetch.
     */
    orderBy?: Enumerable<Server_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Server_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Server_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Server_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Server_logs
    **/
    _count?: true | Server_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Server_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Server_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Server_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Server_logMaxAggregateInputType
  }

  export type GetServer_logAggregateType<T extends Server_logAggregateArgs> = {
        [P in keyof T & keyof AggregateServer_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer_log[P]>
      : GetScalarType<T[P], AggregateServer_log[P]>
  }




  export type Server_logGroupByArgs = {
    where?: Server_logWhereInput
    orderBy?: Enumerable<Server_logOrderByWithAggregationInput>
    by: Server_logScalarFieldEnum[]
    having?: Server_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Server_logCountAggregateInputType | true
    _avg?: Server_logAvgAggregateInputType
    _sum?: Server_logSumAggregateInputType
    _min?: Server_logMinAggregateInputType
    _max?: Server_logMaxAggregateInputType
  }


  export type Server_logGroupByOutputType = {
    id: number
    txt: string
    status: number
    createtime: string
    updatetime: string
    _count: Server_logCountAggregateOutputType | null
    _avg: Server_logAvgAggregateOutputType | null
    _sum: Server_logSumAggregateOutputType | null
    _min: Server_logMinAggregateOutputType | null
    _max: Server_logMaxAggregateOutputType | null
  }

  type GetServer_logGroupByPayload<T extends Server_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Server_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Server_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Server_logGroupByOutputType[P]>
            : GetScalarType<T[P], Server_logGroupByOutputType[P]>
        }
      >
    >


  export type Server_logSelect = {
    id?: boolean
    txt?: boolean
    status?: boolean
    createtime?: boolean
    updatetime?: boolean
  }


  export type Server_logGetPayload<S extends boolean | null | undefined | Server_logArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Server_log :
    S extends undefined ? never :
    S extends { include: any } & (Server_logArgs | Server_logFindManyArgs)
    ? Server_log 
    : S extends { select: any } & (Server_logArgs | Server_logFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Server_log ? Server_log[P] : never
  } 
      : Server_log


  type Server_logCountArgs = 
    Omit<Server_logFindManyArgs, 'select' | 'include'> & {
      select?: Server_logCountAggregateInputType | true
    }

  export interface Server_logDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Server_log that matches the filter.
     * @param {Server_logFindUniqueArgs} args - Arguments to find a Server_log
     * @example
     * // Get one Server_log
     * const server_log = await prisma.server_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Server_logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Server_logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Server_log'> extends True ? Prisma__Server_logClient<Server_logGetPayload<T>> : Prisma__Server_logClient<Server_logGetPayload<T> | null, null>

    /**
     * Find one Server_log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Server_logFindUniqueOrThrowArgs} args - Arguments to find a Server_log
     * @example
     * // Get one Server_log
     * const server_log = await prisma.server_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Server_logFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Server_logFindUniqueOrThrowArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Find the first Server_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logFindFirstArgs} args - Arguments to find a Server_log
     * @example
     * // Get one Server_log
     * const server_log = await prisma.server_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Server_logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Server_logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Server_log'> extends True ? Prisma__Server_logClient<Server_logGetPayload<T>> : Prisma__Server_logClient<Server_logGetPayload<T> | null, null>

    /**
     * Find the first Server_log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logFindFirstOrThrowArgs} args - Arguments to find a Server_log
     * @example
     * // Get one Server_log
     * const server_log = await prisma.server_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Server_logFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Server_logFindFirstOrThrowArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Find zero or more Server_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Server_logs
     * const server_logs = await prisma.server_log.findMany()
     * 
     * // Get first 10 Server_logs
     * const server_logs = await prisma.server_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const server_logWithIdOnly = await prisma.server_log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Server_logFindManyArgs>(
      args?: SelectSubset<T, Server_logFindManyArgs>
    ): Prisma.PrismaPromise<Array<Server_logGetPayload<T>>>

    /**
     * Create a Server_log.
     * @param {Server_logCreateArgs} args - Arguments to create a Server_log.
     * @example
     * // Create one Server_log
     * const Server_log = await prisma.server_log.create({
     *   data: {
     *     // ... data to create a Server_log
     *   }
     * })
     * 
    **/
    create<T extends Server_logCreateArgs>(
      args: SelectSubset<T, Server_logCreateArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Create many Server_logs.
     *     @param {Server_logCreateManyArgs} args - Arguments to create many Server_logs.
     *     @example
     *     // Create many Server_logs
     *     const server_log = await prisma.server_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Server_logCreateManyArgs>(
      args?: SelectSubset<T, Server_logCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server_log.
     * @param {Server_logDeleteArgs} args - Arguments to delete one Server_log.
     * @example
     * // Delete one Server_log
     * const Server_log = await prisma.server_log.delete({
     *   where: {
     *     // ... filter to delete one Server_log
     *   }
     * })
     * 
    **/
    delete<T extends Server_logDeleteArgs>(
      args: SelectSubset<T, Server_logDeleteArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Update one Server_log.
     * @param {Server_logUpdateArgs} args - Arguments to update one Server_log.
     * @example
     * // Update one Server_log
     * const server_log = await prisma.server_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Server_logUpdateArgs>(
      args: SelectSubset<T, Server_logUpdateArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Delete zero or more Server_logs.
     * @param {Server_logDeleteManyArgs} args - Arguments to filter Server_logs to delete.
     * @example
     * // Delete a few Server_logs
     * const { count } = await prisma.server_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Server_logDeleteManyArgs>(
      args?: SelectSubset<T, Server_logDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Server_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Server_logs
     * const server_log = await prisma.server_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Server_logUpdateManyArgs>(
      args: SelectSubset<T, Server_logUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server_log.
     * @param {Server_logUpsertArgs} args - Arguments to update or create a Server_log.
     * @example
     * // Update or create a Server_log
     * const server_log = await prisma.server_log.upsert({
     *   create: {
     *     // ... data to create a Server_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server_log we want to update
     *   }
     * })
    **/
    upsert<T extends Server_logUpsertArgs>(
      args: SelectSubset<T, Server_logUpsertArgs>
    ): Prisma__Server_logClient<Server_logGetPayload<T>>

    /**
     * Count the number of Server_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logCountArgs} args - Arguments to filter Server_logs to count.
     * @example
     * // Count the number of Server_logs
     * const count = await prisma.server_log.count({
     *   where: {
     *     // ... the filter for the Server_logs we want to count
     *   }
     * })
    **/
    count<T extends Server_logCountArgs>(
      args?: Subset<T, Server_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Server_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Server_logAggregateArgs>(args: Subset<T, Server_logAggregateArgs>): Prisma.PrismaPromise<GetServer_logAggregateType<T>>

    /**
     * Group by Server_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Server_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Server_logGroupByArgs['orderBy'] }
        : { orderBy?: Server_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Server_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServer_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Server_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Server_logClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Server_log base type for findUnique actions
   */
  export type Server_logFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter, which Server_log to fetch.
     */
    where: Server_logWhereUniqueInput
  }

  /**
   * Server_log findUnique
   */
  export interface Server_logFindUniqueArgs extends Server_logFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Server_log findUniqueOrThrow
   */
  export type Server_logFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter, which Server_log to fetch.
     */
    where: Server_logWhereUniqueInput
  }


  /**
   * Server_log base type for findFirst actions
   */
  export type Server_logFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter, which Server_log to fetch.
     */
    where?: Server_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Server_logs to fetch.
     */
    orderBy?: Enumerable<Server_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Server_logs.
     */
    cursor?: Server_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Server_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Server_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Server_logs.
     */
    distinct?: Enumerable<Server_logScalarFieldEnum>
  }

  /**
   * Server_log findFirst
   */
  export interface Server_logFindFirstArgs extends Server_logFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Server_log findFirstOrThrow
   */
  export type Server_logFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter, which Server_log to fetch.
     */
    where?: Server_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Server_logs to fetch.
     */
    orderBy?: Enumerable<Server_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Server_logs.
     */
    cursor?: Server_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Server_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Server_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Server_logs.
     */
    distinct?: Enumerable<Server_logScalarFieldEnum>
  }


  /**
   * Server_log findMany
   */
  export type Server_logFindManyArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter, which Server_logs to fetch.
     */
    where?: Server_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Server_logs to fetch.
     */
    orderBy?: Enumerable<Server_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Server_logs.
     */
    cursor?: Server_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Server_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Server_logs.
     */
    skip?: number
    distinct?: Enumerable<Server_logScalarFieldEnum>
  }


  /**
   * Server_log create
   */
  export type Server_logCreateArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * The data needed to create a Server_log.
     */
    data: XOR<Server_logCreateInput, Server_logUncheckedCreateInput>
  }


  /**
   * Server_log createMany
   */
  export type Server_logCreateManyArgs = {
    /**
     * The data used to create many Server_logs.
     */
    data: Enumerable<Server_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Server_log update
   */
  export type Server_logUpdateArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * The data needed to update a Server_log.
     */
    data: XOR<Server_logUpdateInput, Server_logUncheckedUpdateInput>
    /**
     * Choose, which Server_log to update.
     */
    where: Server_logWhereUniqueInput
  }


  /**
   * Server_log updateMany
   */
  export type Server_logUpdateManyArgs = {
    /**
     * The data used to update Server_logs.
     */
    data: XOR<Server_logUpdateManyMutationInput, Server_logUncheckedUpdateManyInput>
    /**
     * Filter which Server_logs to update
     */
    where?: Server_logWhereInput
  }


  /**
   * Server_log upsert
   */
  export type Server_logUpsertArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * The filter to search for the Server_log to update in case it exists.
     */
    where: Server_logWhereUniqueInput
    /**
     * In case the Server_log found by the `where` argument doesn't exist, create a new Server_log with this data.
     */
    create: XOR<Server_logCreateInput, Server_logUncheckedCreateInput>
    /**
     * In case the Server_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Server_logUpdateInput, Server_logUncheckedUpdateInput>
  }


  /**
   * Server_log delete
   */
  export type Server_logDeleteArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
    /**
     * Filter which Server_log to delete.
     */
    where: Server_logWhereUniqueInput
  }


  /**
   * Server_log deleteMany
   */
  export type Server_logDeleteManyArgs = {
    /**
     * Filter which Server_logs to delete
     */
    where?: Server_logWhereInput
  }


  /**
   * Server_log without action
   */
  export type Server_logArgs = {
    /**
     * Select specific fields to fetch from the Server_log
     */
    select?: Server_logSelect | null
  }



  /**
   * Model Tempadddiamond
   */


  export type AggregateTempadddiamond = {
    _count: TempadddiamondCountAggregateOutputType | null
    _avg: TempadddiamondAvgAggregateOutputType | null
    _sum: TempadddiamondSumAggregateOutputType | null
    _min: TempadddiamondMinAggregateOutputType | null
    _max: TempadddiamondMaxAggregateOutputType | null
  }

  export type TempadddiamondAvgAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempadddiamondSumAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempadddiamondMinAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempadddiamondMaxAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempadddiamondCountAggregateOutputType = {
    userId: number
    score: number
    change_type: number
    _all: number
  }


  export type TempadddiamondAvgAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempadddiamondSumAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempadddiamondMinAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempadddiamondMaxAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempadddiamondCountAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
    _all?: true
  }

  export type TempadddiamondAggregateArgs = {
    /**
     * Filter which Tempadddiamond to aggregate.
     */
    where?: TempadddiamondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempadddiamonds to fetch.
     */
    orderBy?: Enumerable<TempadddiamondOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempadddiamondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempadddiamonds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempadddiamonds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tempadddiamonds
    **/
    _count?: true | TempadddiamondCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TempadddiamondAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TempadddiamondSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempadddiamondMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempadddiamondMaxAggregateInputType
  }

  export type GetTempadddiamondAggregateType<T extends TempadddiamondAggregateArgs> = {
        [P in keyof T & keyof AggregateTempadddiamond]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempadddiamond[P]>
      : GetScalarType<T[P], AggregateTempadddiamond[P]>
  }




  export type TempadddiamondGroupByArgs = {
    where?: TempadddiamondWhereInput
    orderBy?: Enumerable<TempadddiamondOrderByWithAggregationInput>
    by: TempadddiamondScalarFieldEnum[]
    having?: TempadddiamondScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempadddiamondCountAggregateInputType | true
    _avg?: TempadddiamondAvgAggregateInputType
    _sum?: TempadddiamondSumAggregateInputType
    _min?: TempadddiamondMinAggregateInputType
    _max?: TempadddiamondMaxAggregateInputType
  }


  export type TempadddiamondGroupByOutputType = {
    userId: number
    score: number
    change_type: number
    _count: TempadddiamondCountAggregateOutputType | null
    _avg: TempadddiamondAvgAggregateOutputType | null
    _sum: TempadddiamondSumAggregateOutputType | null
    _min: TempadddiamondMinAggregateOutputType | null
    _max: TempadddiamondMaxAggregateOutputType | null
  }

  type GetTempadddiamondGroupByPayload<T extends TempadddiamondGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TempadddiamondGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempadddiamondGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempadddiamondGroupByOutputType[P]>
            : GetScalarType<T[P], TempadddiamondGroupByOutputType[P]>
        }
      >
    >


  export type TempadddiamondSelect = {
    userId?: boolean
    score?: boolean
    change_type?: boolean
  }


  export type TempadddiamondGetPayload<S extends boolean | null | undefined | TempadddiamondArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tempadddiamond :
    S extends undefined ? never :
    S extends { include: any } & (TempadddiamondArgs | TempadddiamondFindManyArgs)
    ? Tempadddiamond 
    : S extends { select: any } & (TempadddiamondArgs | TempadddiamondFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Tempadddiamond ? Tempadddiamond[P] : never
  } 
      : Tempadddiamond


  type TempadddiamondCountArgs = 
    Omit<TempadddiamondFindManyArgs, 'select' | 'include'> & {
      select?: TempadddiamondCountAggregateInputType | true
    }

  export interface TempadddiamondDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tempadddiamond that matches the filter.
     * @param {TempadddiamondFindUniqueArgs} args - Arguments to find a Tempadddiamond
     * @example
     * // Get one Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TempadddiamondFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TempadddiamondFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tempadddiamond'> extends True ? Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>> : Prisma__TempadddiamondClient<TempadddiamondGetPayload<T> | null, null>

    /**
     * Find one Tempadddiamond that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TempadddiamondFindUniqueOrThrowArgs} args - Arguments to find a Tempadddiamond
     * @example
     * // Get one Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TempadddiamondFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TempadddiamondFindUniqueOrThrowArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Find the first Tempadddiamond that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondFindFirstArgs} args - Arguments to find a Tempadddiamond
     * @example
     * // Get one Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TempadddiamondFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TempadddiamondFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tempadddiamond'> extends True ? Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>> : Prisma__TempadddiamondClient<TempadddiamondGetPayload<T> | null, null>

    /**
     * Find the first Tempadddiamond that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondFindFirstOrThrowArgs} args - Arguments to find a Tempadddiamond
     * @example
     * // Get one Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TempadddiamondFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TempadddiamondFindFirstOrThrowArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Find zero or more Tempadddiamonds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tempadddiamonds
     * const tempadddiamonds = await prisma.tempadddiamond.findMany()
     * 
     * // Get first 10 Tempadddiamonds
     * const tempadddiamonds = await prisma.tempadddiamond.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const tempadddiamondWithUserIdOnly = await prisma.tempadddiamond.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends TempadddiamondFindManyArgs>(
      args?: SelectSubset<T, TempadddiamondFindManyArgs>
    ): Prisma.PrismaPromise<Array<TempadddiamondGetPayload<T>>>

    /**
     * Create a Tempadddiamond.
     * @param {TempadddiamondCreateArgs} args - Arguments to create a Tempadddiamond.
     * @example
     * // Create one Tempadddiamond
     * const Tempadddiamond = await prisma.tempadddiamond.create({
     *   data: {
     *     // ... data to create a Tempadddiamond
     *   }
     * })
     * 
    **/
    create<T extends TempadddiamondCreateArgs>(
      args: SelectSubset<T, TempadddiamondCreateArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Create many Tempadddiamonds.
     *     @param {TempadddiamondCreateManyArgs} args - Arguments to create many Tempadddiamonds.
     *     @example
     *     // Create many Tempadddiamonds
     *     const tempadddiamond = await prisma.tempadddiamond.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TempadddiamondCreateManyArgs>(
      args?: SelectSubset<T, TempadddiamondCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tempadddiamond.
     * @param {TempadddiamondDeleteArgs} args - Arguments to delete one Tempadddiamond.
     * @example
     * // Delete one Tempadddiamond
     * const Tempadddiamond = await prisma.tempadddiamond.delete({
     *   where: {
     *     // ... filter to delete one Tempadddiamond
     *   }
     * })
     * 
    **/
    delete<T extends TempadddiamondDeleteArgs>(
      args: SelectSubset<T, TempadddiamondDeleteArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Update one Tempadddiamond.
     * @param {TempadddiamondUpdateArgs} args - Arguments to update one Tempadddiamond.
     * @example
     * // Update one Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TempadddiamondUpdateArgs>(
      args: SelectSubset<T, TempadddiamondUpdateArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Delete zero or more Tempadddiamonds.
     * @param {TempadddiamondDeleteManyArgs} args - Arguments to filter Tempadddiamonds to delete.
     * @example
     * // Delete a few Tempadddiamonds
     * const { count } = await prisma.tempadddiamond.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TempadddiamondDeleteManyArgs>(
      args?: SelectSubset<T, TempadddiamondDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tempadddiamonds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tempadddiamonds
     * const tempadddiamond = await prisma.tempadddiamond.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TempadddiamondUpdateManyArgs>(
      args: SelectSubset<T, TempadddiamondUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tempadddiamond.
     * @param {TempadddiamondUpsertArgs} args - Arguments to update or create a Tempadddiamond.
     * @example
     * // Update or create a Tempadddiamond
     * const tempadddiamond = await prisma.tempadddiamond.upsert({
     *   create: {
     *     // ... data to create a Tempadddiamond
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tempadddiamond we want to update
     *   }
     * })
    **/
    upsert<T extends TempadddiamondUpsertArgs>(
      args: SelectSubset<T, TempadddiamondUpsertArgs>
    ): Prisma__TempadddiamondClient<TempadddiamondGetPayload<T>>

    /**
     * Count the number of Tempadddiamonds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondCountArgs} args - Arguments to filter Tempadddiamonds to count.
     * @example
     * // Count the number of Tempadddiamonds
     * const count = await prisma.tempadddiamond.count({
     *   where: {
     *     // ... the filter for the Tempadddiamonds we want to count
     *   }
     * })
    **/
    count<T extends TempadddiamondCountArgs>(
      args?: Subset<T, TempadddiamondCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempadddiamondCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tempadddiamond.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempadddiamondAggregateArgs>(args: Subset<T, TempadddiamondAggregateArgs>): Prisma.PrismaPromise<GetTempadddiamondAggregateType<T>>

    /**
     * Group by Tempadddiamond.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempadddiamondGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempadddiamondGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempadddiamondGroupByArgs['orderBy'] }
        : { orderBy?: TempadddiamondGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempadddiamondGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempadddiamondGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tempadddiamond.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TempadddiamondClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tempadddiamond base type for findUnique actions
   */
  export type TempadddiamondFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter, which Tempadddiamond to fetch.
     */
    where: TempadddiamondWhereUniqueInput
  }

  /**
   * Tempadddiamond findUnique
   */
  export interface TempadddiamondFindUniqueArgs extends TempadddiamondFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tempadddiamond findUniqueOrThrow
   */
  export type TempadddiamondFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter, which Tempadddiamond to fetch.
     */
    where: TempadddiamondWhereUniqueInput
  }


  /**
   * Tempadddiamond base type for findFirst actions
   */
  export type TempadddiamondFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter, which Tempadddiamond to fetch.
     */
    where?: TempadddiamondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempadddiamonds to fetch.
     */
    orderBy?: Enumerable<TempadddiamondOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tempadddiamonds.
     */
    cursor?: TempadddiamondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempadddiamonds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempadddiamonds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tempadddiamonds.
     */
    distinct?: Enumerable<TempadddiamondScalarFieldEnum>
  }

  /**
   * Tempadddiamond findFirst
   */
  export interface TempadddiamondFindFirstArgs extends TempadddiamondFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tempadddiamond findFirstOrThrow
   */
  export type TempadddiamondFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter, which Tempadddiamond to fetch.
     */
    where?: TempadddiamondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempadddiamonds to fetch.
     */
    orderBy?: Enumerable<TempadddiamondOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tempadddiamonds.
     */
    cursor?: TempadddiamondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempadddiamonds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempadddiamonds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tempadddiamonds.
     */
    distinct?: Enumerable<TempadddiamondScalarFieldEnum>
  }


  /**
   * Tempadddiamond findMany
   */
  export type TempadddiamondFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter, which Tempadddiamonds to fetch.
     */
    where?: TempadddiamondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempadddiamonds to fetch.
     */
    orderBy?: Enumerable<TempadddiamondOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tempadddiamonds.
     */
    cursor?: TempadddiamondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempadddiamonds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempadddiamonds.
     */
    skip?: number
    distinct?: Enumerable<TempadddiamondScalarFieldEnum>
  }


  /**
   * Tempadddiamond create
   */
  export type TempadddiamondCreateArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * The data needed to create a Tempadddiamond.
     */
    data: XOR<TempadddiamondCreateInput, TempadddiamondUncheckedCreateInput>
  }


  /**
   * Tempadddiamond createMany
   */
  export type TempadddiamondCreateManyArgs = {
    /**
     * The data used to create many Tempadddiamonds.
     */
    data: Enumerable<TempadddiamondCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tempadddiamond update
   */
  export type TempadddiamondUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * The data needed to update a Tempadddiamond.
     */
    data: XOR<TempadddiamondUpdateInput, TempadddiamondUncheckedUpdateInput>
    /**
     * Choose, which Tempadddiamond to update.
     */
    where: TempadddiamondWhereUniqueInput
  }


  /**
   * Tempadddiamond updateMany
   */
  export type TempadddiamondUpdateManyArgs = {
    /**
     * The data used to update Tempadddiamonds.
     */
    data: XOR<TempadddiamondUpdateManyMutationInput, TempadddiamondUncheckedUpdateManyInput>
    /**
     * Filter which Tempadddiamonds to update
     */
    where?: TempadddiamondWhereInput
  }


  /**
   * Tempadddiamond upsert
   */
  export type TempadddiamondUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * The filter to search for the Tempadddiamond to update in case it exists.
     */
    where: TempadddiamondWhereUniqueInput
    /**
     * In case the Tempadddiamond found by the `where` argument doesn't exist, create a new Tempadddiamond with this data.
     */
    create: XOR<TempadddiamondCreateInput, TempadddiamondUncheckedCreateInput>
    /**
     * In case the Tempadddiamond was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempadddiamondUpdateInput, TempadddiamondUncheckedUpdateInput>
  }


  /**
   * Tempadddiamond delete
   */
  export type TempadddiamondDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
    /**
     * Filter which Tempadddiamond to delete.
     */
    where: TempadddiamondWhereUniqueInput
  }


  /**
   * Tempadddiamond deleteMany
   */
  export type TempadddiamondDeleteManyArgs = {
    /**
     * Filter which Tempadddiamonds to delete
     */
    where?: TempadddiamondWhereInput
  }


  /**
   * Tempadddiamond without action
   */
  export type TempadddiamondArgs = {
    /**
     * Select specific fields to fetch from the Tempadddiamond
     */
    select?: TempadddiamondSelect | null
  }



  /**
   * Model Tempaddscore
   */


  export type AggregateTempaddscore = {
    _count: TempaddscoreCountAggregateOutputType | null
    _avg: TempaddscoreAvgAggregateOutputType | null
    _sum: TempaddscoreSumAggregateOutputType | null
    _min: TempaddscoreMinAggregateOutputType | null
    _max: TempaddscoreMaxAggregateOutputType | null
  }

  export type TempaddscoreAvgAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempaddscoreSumAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempaddscoreMinAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempaddscoreMaxAggregateOutputType = {
    userId: number | null
    score: number | null
    change_type: number | null
  }

  export type TempaddscoreCountAggregateOutputType = {
    userId: number
    score: number
    change_type: number
    _all: number
  }


  export type TempaddscoreAvgAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempaddscoreSumAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempaddscoreMinAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempaddscoreMaxAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
  }

  export type TempaddscoreCountAggregateInputType = {
    userId?: true
    score?: true
    change_type?: true
    _all?: true
  }

  export type TempaddscoreAggregateArgs = {
    /**
     * Filter which Tempaddscore to aggregate.
     */
    where?: TempaddscoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempaddscores to fetch.
     */
    orderBy?: Enumerable<TempaddscoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempaddscoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempaddscores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempaddscores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tempaddscores
    **/
    _count?: true | TempaddscoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TempaddscoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TempaddscoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempaddscoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempaddscoreMaxAggregateInputType
  }

  export type GetTempaddscoreAggregateType<T extends TempaddscoreAggregateArgs> = {
        [P in keyof T & keyof AggregateTempaddscore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempaddscore[P]>
      : GetScalarType<T[P], AggregateTempaddscore[P]>
  }




  export type TempaddscoreGroupByArgs = {
    where?: TempaddscoreWhereInput
    orderBy?: Enumerable<TempaddscoreOrderByWithAggregationInput>
    by: TempaddscoreScalarFieldEnum[]
    having?: TempaddscoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempaddscoreCountAggregateInputType | true
    _avg?: TempaddscoreAvgAggregateInputType
    _sum?: TempaddscoreSumAggregateInputType
    _min?: TempaddscoreMinAggregateInputType
    _max?: TempaddscoreMaxAggregateInputType
  }


  export type TempaddscoreGroupByOutputType = {
    userId: number
    score: number
    change_type: number
    _count: TempaddscoreCountAggregateOutputType | null
    _avg: TempaddscoreAvgAggregateOutputType | null
    _sum: TempaddscoreSumAggregateOutputType | null
    _min: TempaddscoreMinAggregateOutputType | null
    _max: TempaddscoreMaxAggregateOutputType | null
  }

  type GetTempaddscoreGroupByPayload<T extends TempaddscoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TempaddscoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempaddscoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempaddscoreGroupByOutputType[P]>
            : GetScalarType<T[P], TempaddscoreGroupByOutputType[P]>
        }
      >
    >


  export type TempaddscoreSelect = {
    userId?: boolean
    score?: boolean
    change_type?: boolean
  }


  export type TempaddscoreGetPayload<S extends boolean | null | undefined | TempaddscoreArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tempaddscore :
    S extends undefined ? never :
    S extends { include: any } & (TempaddscoreArgs | TempaddscoreFindManyArgs)
    ? Tempaddscore 
    : S extends { select: any } & (TempaddscoreArgs | TempaddscoreFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Tempaddscore ? Tempaddscore[P] : never
  } 
      : Tempaddscore


  type TempaddscoreCountArgs = 
    Omit<TempaddscoreFindManyArgs, 'select' | 'include'> & {
      select?: TempaddscoreCountAggregateInputType | true
    }

  export interface TempaddscoreDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tempaddscore that matches the filter.
     * @param {TempaddscoreFindUniqueArgs} args - Arguments to find a Tempaddscore
     * @example
     * // Get one Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TempaddscoreFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TempaddscoreFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tempaddscore'> extends True ? Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>> : Prisma__TempaddscoreClient<TempaddscoreGetPayload<T> | null, null>

    /**
     * Find one Tempaddscore that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TempaddscoreFindUniqueOrThrowArgs} args - Arguments to find a Tempaddscore
     * @example
     * // Get one Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TempaddscoreFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TempaddscoreFindUniqueOrThrowArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Find the first Tempaddscore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreFindFirstArgs} args - Arguments to find a Tempaddscore
     * @example
     * // Get one Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TempaddscoreFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TempaddscoreFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tempaddscore'> extends True ? Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>> : Prisma__TempaddscoreClient<TempaddscoreGetPayload<T> | null, null>

    /**
     * Find the first Tempaddscore that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreFindFirstOrThrowArgs} args - Arguments to find a Tempaddscore
     * @example
     * // Get one Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TempaddscoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TempaddscoreFindFirstOrThrowArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Find zero or more Tempaddscores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tempaddscores
     * const tempaddscores = await prisma.tempaddscore.findMany()
     * 
     * // Get first 10 Tempaddscores
     * const tempaddscores = await prisma.tempaddscore.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const tempaddscoreWithUserIdOnly = await prisma.tempaddscore.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends TempaddscoreFindManyArgs>(
      args?: SelectSubset<T, TempaddscoreFindManyArgs>
    ): Prisma.PrismaPromise<Array<TempaddscoreGetPayload<T>>>

    /**
     * Create a Tempaddscore.
     * @param {TempaddscoreCreateArgs} args - Arguments to create a Tempaddscore.
     * @example
     * // Create one Tempaddscore
     * const Tempaddscore = await prisma.tempaddscore.create({
     *   data: {
     *     // ... data to create a Tempaddscore
     *   }
     * })
     * 
    **/
    create<T extends TempaddscoreCreateArgs>(
      args: SelectSubset<T, TempaddscoreCreateArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Create many Tempaddscores.
     *     @param {TempaddscoreCreateManyArgs} args - Arguments to create many Tempaddscores.
     *     @example
     *     // Create many Tempaddscores
     *     const tempaddscore = await prisma.tempaddscore.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TempaddscoreCreateManyArgs>(
      args?: SelectSubset<T, TempaddscoreCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tempaddscore.
     * @param {TempaddscoreDeleteArgs} args - Arguments to delete one Tempaddscore.
     * @example
     * // Delete one Tempaddscore
     * const Tempaddscore = await prisma.tempaddscore.delete({
     *   where: {
     *     // ... filter to delete one Tempaddscore
     *   }
     * })
     * 
    **/
    delete<T extends TempaddscoreDeleteArgs>(
      args: SelectSubset<T, TempaddscoreDeleteArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Update one Tempaddscore.
     * @param {TempaddscoreUpdateArgs} args - Arguments to update one Tempaddscore.
     * @example
     * // Update one Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TempaddscoreUpdateArgs>(
      args: SelectSubset<T, TempaddscoreUpdateArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Delete zero or more Tempaddscores.
     * @param {TempaddscoreDeleteManyArgs} args - Arguments to filter Tempaddscores to delete.
     * @example
     * // Delete a few Tempaddscores
     * const { count } = await prisma.tempaddscore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TempaddscoreDeleteManyArgs>(
      args?: SelectSubset<T, TempaddscoreDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tempaddscores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tempaddscores
     * const tempaddscore = await prisma.tempaddscore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TempaddscoreUpdateManyArgs>(
      args: SelectSubset<T, TempaddscoreUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tempaddscore.
     * @param {TempaddscoreUpsertArgs} args - Arguments to update or create a Tempaddscore.
     * @example
     * // Update or create a Tempaddscore
     * const tempaddscore = await prisma.tempaddscore.upsert({
     *   create: {
     *     // ... data to create a Tempaddscore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tempaddscore we want to update
     *   }
     * })
    **/
    upsert<T extends TempaddscoreUpsertArgs>(
      args: SelectSubset<T, TempaddscoreUpsertArgs>
    ): Prisma__TempaddscoreClient<TempaddscoreGetPayload<T>>

    /**
     * Count the number of Tempaddscores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreCountArgs} args - Arguments to filter Tempaddscores to count.
     * @example
     * // Count the number of Tempaddscores
     * const count = await prisma.tempaddscore.count({
     *   where: {
     *     // ... the filter for the Tempaddscores we want to count
     *   }
     * })
    **/
    count<T extends TempaddscoreCountArgs>(
      args?: Subset<T, TempaddscoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempaddscoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tempaddscore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempaddscoreAggregateArgs>(args: Subset<T, TempaddscoreAggregateArgs>): Prisma.PrismaPromise<GetTempaddscoreAggregateType<T>>

    /**
     * Group by Tempaddscore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempaddscoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempaddscoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempaddscoreGroupByArgs['orderBy'] }
        : { orderBy?: TempaddscoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempaddscoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempaddscoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tempaddscore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TempaddscoreClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tempaddscore base type for findUnique actions
   */
  export type TempaddscoreFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter, which Tempaddscore to fetch.
     */
    where: TempaddscoreWhereUniqueInput
  }

  /**
   * Tempaddscore findUnique
   */
  export interface TempaddscoreFindUniqueArgs extends TempaddscoreFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tempaddscore findUniqueOrThrow
   */
  export type TempaddscoreFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter, which Tempaddscore to fetch.
     */
    where: TempaddscoreWhereUniqueInput
  }


  /**
   * Tempaddscore base type for findFirst actions
   */
  export type TempaddscoreFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter, which Tempaddscore to fetch.
     */
    where?: TempaddscoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempaddscores to fetch.
     */
    orderBy?: Enumerable<TempaddscoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tempaddscores.
     */
    cursor?: TempaddscoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempaddscores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempaddscores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tempaddscores.
     */
    distinct?: Enumerable<TempaddscoreScalarFieldEnum>
  }

  /**
   * Tempaddscore findFirst
   */
  export interface TempaddscoreFindFirstArgs extends TempaddscoreFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tempaddscore findFirstOrThrow
   */
  export type TempaddscoreFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter, which Tempaddscore to fetch.
     */
    where?: TempaddscoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempaddscores to fetch.
     */
    orderBy?: Enumerable<TempaddscoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tempaddscores.
     */
    cursor?: TempaddscoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempaddscores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempaddscores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tempaddscores.
     */
    distinct?: Enumerable<TempaddscoreScalarFieldEnum>
  }


  /**
   * Tempaddscore findMany
   */
  export type TempaddscoreFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter, which Tempaddscores to fetch.
     */
    where?: TempaddscoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tempaddscores to fetch.
     */
    orderBy?: Enumerable<TempaddscoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tempaddscores.
     */
    cursor?: TempaddscoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tempaddscores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tempaddscores.
     */
    skip?: number
    distinct?: Enumerable<TempaddscoreScalarFieldEnum>
  }


  /**
   * Tempaddscore create
   */
  export type TempaddscoreCreateArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * The data needed to create a Tempaddscore.
     */
    data: XOR<TempaddscoreCreateInput, TempaddscoreUncheckedCreateInput>
  }


  /**
   * Tempaddscore createMany
   */
  export type TempaddscoreCreateManyArgs = {
    /**
     * The data used to create many Tempaddscores.
     */
    data: Enumerable<TempaddscoreCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tempaddscore update
   */
  export type TempaddscoreUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * The data needed to update a Tempaddscore.
     */
    data: XOR<TempaddscoreUpdateInput, TempaddscoreUncheckedUpdateInput>
    /**
     * Choose, which Tempaddscore to update.
     */
    where: TempaddscoreWhereUniqueInput
  }


  /**
   * Tempaddscore updateMany
   */
  export type TempaddscoreUpdateManyArgs = {
    /**
     * The data used to update Tempaddscores.
     */
    data: XOR<TempaddscoreUpdateManyMutationInput, TempaddscoreUncheckedUpdateManyInput>
    /**
     * Filter which Tempaddscores to update
     */
    where?: TempaddscoreWhereInput
  }


  /**
   * Tempaddscore upsert
   */
  export type TempaddscoreUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * The filter to search for the Tempaddscore to update in case it exists.
     */
    where: TempaddscoreWhereUniqueInput
    /**
     * In case the Tempaddscore found by the `where` argument doesn't exist, create a new Tempaddscore with this data.
     */
    create: XOR<TempaddscoreCreateInput, TempaddscoreUncheckedCreateInput>
    /**
     * In case the Tempaddscore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempaddscoreUpdateInput, TempaddscoreUncheckedUpdateInput>
  }


  /**
   * Tempaddscore delete
   */
  export type TempaddscoreDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
    /**
     * Filter which Tempaddscore to delete.
     */
    where: TempaddscoreWhereUniqueInput
  }


  /**
   * Tempaddscore deleteMany
   */
  export type TempaddscoreDeleteManyArgs = {
    /**
     * Filter which Tempaddscores to delete
     */
    where?: TempaddscoreWhereInput
  }


  /**
   * Tempaddscore without action
   */
  export type TempaddscoreArgs = {
    /**
     * Select specific fields to fetch from the Tempaddscore
     */
    select?: TempaddscoreSelect | null
  }



  /**
   * Model Ticket_changelog
   */


  export type AggregateTicket_changelog = {
    _count: Ticket_changelogCountAggregateOutputType | null
    _avg: Ticket_changelogAvgAggregateOutputType | null
    _sum: Ticket_changelogSumAggregateOutputType | null
    _min: Ticket_changelogMinAggregateOutputType | null
    _max: Ticket_changelogMaxAggregateOutputType | null
  }

  export type Ticket_changelogAvgAggregateOutputType = {
    userid: number | null
    score_before: number | null
    score_change: number | null
    score_current: number | null
    change_type: number | null
    isOnline: number | null
  }

  export type Ticket_changelogSumAggregateOutputType = {
    userid: number | null
    score_before: number | null
    score_change: number | null
    score_current: number | null
    change_type: number | null
    isOnline: number | null
  }

  export type Ticket_changelogMinAggregateOutputType = {
    userid: number | null
    score_before: number | null
    score_change: number | null
    score_current: number | null
    change_type: number | null
    change_time: Date | null
    isOnline: number | null
  }

  export type Ticket_changelogMaxAggregateOutputType = {
    userid: number | null
    score_before: number | null
    score_change: number | null
    score_current: number | null
    change_type: number | null
    change_time: Date | null
    isOnline: number | null
  }

  export type Ticket_changelogCountAggregateOutputType = {
    userid: number
    score_before: number
    score_change: number
    score_current: number
    change_type: number
    change_time: number
    isOnline: number
    _all: number
  }


  export type Ticket_changelogAvgAggregateInputType = {
    userid?: true
    score_before?: true
    score_change?: true
    score_current?: true
    change_type?: true
    isOnline?: true
  }

  export type Ticket_changelogSumAggregateInputType = {
    userid?: true
    score_before?: true
    score_change?: true
    score_current?: true
    change_type?: true
    isOnline?: true
  }

  export type Ticket_changelogMinAggregateInputType = {
    userid?: true
    score_before?: true
    score_change?: true
    score_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
  }

  export type Ticket_changelogMaxAggregateInputType = {
    userid?: true
    score_before?: true
    score_change?: true
    score_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
  }

  export type Ticket_changelogCountAggregateInputType = {
    userid?: true
    score_before?: true
    score_change?: true
    score_current?: true
    change_type?: true
    change_time?: true
    isOnline?: true
    _all?: true
  }

  export type Ticket_changelogAggregateArgs = {
    /**
     * Filter which Ticket_changelog to aggregate.
     */
    where?: Ticket_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticket_changelogs to fetch.
     */
    orderBy?: Enumerable<Ticket_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Ticket_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticket_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticket_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ticket_changelogs
    **/
    _count?: true | Ticket_changelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ticket_changelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ticket_changelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ticket_changelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ticket_changelogMaxAggregateInputType
  }

  export type GetTicket_changelogAggregateType<T extends Ticket_changelogAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket_changelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket_changelog[P]>
      : GetScalarType<T[P], AggregateTicket_changelog[P]>
  }




  export type Ticket_changelogGroupByArgs = {
    where?: Ticket_changelogWhereInput
    orderBy?: Enumerable<Ticket_changelogOrderByWithAggregationInput>
    by: Ticket_changelogScalarFieldEnum[]
    having?: Ticket_changelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ticket_changelogCountAggregateInputType | true
    _avg?: Ticket_changelogAvgAggregateInputType
    _sum?: Ticket_changelogSumAggregateInputType
    _min?: Ticket_changelogMinAggregateInputType
    _max?: Ticket_changelogMaxAggregateInputType
  }


  export type Ticket_changelogGroupByOutputType = {
    userid: number
    score_before: number
    score_change: number
    score_current: number
    change_type: number
    change_time: Date
    isOnline: number
    _count: Ticket_changelogCountAggregateOutputType | null
    _avg: Ticket_changelogAvgAggregateOutputType | null
    _sum: Ticket_changelogSumAggregateOutputType | null
    _min: Ticket_changelogMinAggregateOutputType | null
    _max: Ticket_changelogMaxAggregateOutputType | null
  }

  type GetTicket_changelogGroupByPayload<T extends Ticket_changelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Ticket_changelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ticket_changelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ticket_changelogGroupByOutputType[P]>
            : GetScalarType<T[P], Ticket_changelogGroupByOutputType[P]>
        }
      >
    >


  export type Ticket_changelogSelect = {
    userid?: boolean
    score_before?: boolean
    score_change?: boolean
    score_current?: boolean
    change_type?: boolean
    change_time?: boolean
    isOnline?: boolean
  }


  export type Ticket_changelogGetPayload<S extends boolean | null | undefined | Ticket_changelogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Ticket_changelog :
    S extends undefined ? never :
    S extends { include: any } & (Ticket_changelogArgs | Ticket_changelogFindManyArgs)
    ? Ticket_changelog 
    : S extends { select: any } & (Ticket_changelogArgs | Ticket_changelogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Ticket_changelog ? Ticket_changelog[P] : never
  } 
      : Ticket_changelog


  type Ticket_changelogCountArgs = 
    Omit<Ticket_changelogFindManyArgs, 'select' | 'include'> & {
      select?: Ticket_changelogCountAggregateInputType | true
    }

  export interface Ticket_changelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ticket_changelog that matches the filter.
     * @param {Ticket_changelogFindUniqueArgs} args - Arguments to find a Ticket_changelog
     * @example
     * // Get one Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Ticket_changelogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Ticket_changelogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ticket_changelog'> extends True ? Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>> : Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T> | null, null>

    /**
     * Find one Ticket_changelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Ticket_changelogFindUniqueOrThrowArgs} args - Arguments to find a Ticket_changelog
     * @example
     * // Get one Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Ticket_changelogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Ticket_changelogFindUniqueOrThrowArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Find the first Ticket_changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogFindFirstArgs} args - Arguments to find a Ticket_changelog
     * @example
     * // Get one Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Ticket_changelogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Ticket_changelogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ticket_changelog'> extends True ? Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>> : Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T> | null, null>

    /**
     * Find the first Ticket_changelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogFindFirstOrThrowArgs} args - Arguments to find a Ticket_changelog
     * @example
     * // Get one Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Ticket_changelogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Ticket_changelogFindFirstOrThrowArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Find zero or more Ticket_changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ticket_changelogs
     * const ticket_changelogs = await prisma.ticket_changelog.findMany()
     * 
     * // Get first 10 Ticket_changelogs
     * const ticket_changelogs = await prisma.ticket_changelog.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const ticket_changelogWithUseridOnly = await prisma.ticket_changelog.findMany({ select: { userid: true } })
     * 
    **/
    findMany<T extends Ticket_changelogFindManyArgs>(
      args?: SelectSubset<T, Ticket_changelogFindManyArgs>
    ): Prisma.PrismaPromise<Array<Ticket_changelogGetPayload<T>>>

    /**
     * Create a Ticket_changelog.
     * @param {Ticket_changelogCreateArgs} args - Arguments to create a Ticket_changelog.
     * @example
     * // Create one Ticket_changelog
     * const Ticket_changelog = await prisma.ticket_changelog.create({
     *   data: {
     *     // ... data to create a Ticket_changelog
     *   }
     * })
     * 
    **/
    create<T extends Ticket_changelogCreateArgs>(
      args: SelectSubset<T, Ticket_changelogCreateArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Create many Ticket_changelogs.
     *     @param {Ticket_changelogCreateManyArgs} args - Arguments to create many Ticket_changelogs.
     *     @example
     *     // Create many Ticket_changelogs
     *     const ticket_changelog = await prisma.ticket_changelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Ticket_changelogCreateManyArgs>(
      args?: SelectSubset<T, Ticket_changelogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket_changelog.
     * @param {Ticket_changelogDeleteArgs} args - Arguments to delete one Ticket_changelog.
     * @example
     * // Delete one Ticket_changelog
     * const Ticket_changelog = await prisma.ticket_changelog.delete({
     *   where: {
     *     // ... filter to delete one Ticket_changelog
     *   }
     * })
     * 
    **/
    delete<T extends Ticket_changelogDeleteArgs>(
      args: SelectSubset<T, Ticket_changelogDeleteArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Update one Ticket_changelog.
     * @param {Ticket_changelogUpdateArgs} args - Arguments to update one Ticket_changelog.
     * @example
     * // Update one Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Ticket_changelogUpdateArgs>(
      args: SelectSubset<T, Ticket_changelogUpdateArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Delete zero or more Ticket_changelogs.
     * @param {Ticket_changelogDeleteManyArgs} args - Arguments to filter Ticket_changelogs to delete.
     * @example
     * // Delete a few Ticket_changelogs
     * const { count } = await prisma.ticket_changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Ticket_changelogDeleteManyArgs>(
      args?: SelectSubset<T, Ticket_changelogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ticket_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ticket_changelogs
     * const ticket_changelog = await prisma.ticket_changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Ticket_changelogUpdateManyArgs>(
      args: SelectSubset<T, Ticket_changelogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket_changelog.
     * @param {Ticket_changelogUpsertArgs} args - Arguments to update or create a Ticket_changelog.
     * @example
     * // Update or create a Ticket_changelog
     * const ticket_changelog = await prisma.ticket_changelog.upsert({
     *   create: {
     *     // ... data to create a Ticket_changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket_changelog we want to update
     *   }
     * })
    **/
    upsert<T extends Ticket_changelogUpsertArgs>(
      args: SelectSubset<T, Ticket_changelogUpsertArgs>
    ): Prisma__Ticket_changelogClient<Ticket_changelogGetPayload<T>>

    /**
     * Count the number of Ticket_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogCountArgs} args - Arguments to filter Ticket_changelogs to count.
     * @example
     * // Count the number of Ticket_changelogs
     * const count = await prisma.ticket_changelog.count({
     *   where: {
     *     // ... the filter for the Ticket_changelogs we want to count
     *   }
     * })
    **/
    count<T extends Ticket_changelogCountArgs>(
      args?: Subset<T, Ticket_changelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ticket_changelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ticket_changelogAggregateArgs>(args: Subset<T, Ticket_changelogAggregateArgs>): Prisma.PrismaPromise<GetTicket_changelogAggregateType<T>>

    /**
     * Group by Ticket_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ticket_changelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ticket_changelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ticket_changelogGroupByArgs['orderBy'] }
        : { orderBy?: Ticket_changelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ticket_changelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicket_changelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket_changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Ticket_changelogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ticket_changelog base type for findUnique actions
   */
  export type Ticket_changelogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter, which Ticket_changelog to fetch.
     */
    where: Ticket_changelogWhereUniqueInput
  }

  /**
   * Ticket_changelog findUnique
   */
  export interface Ticket_changelogFindUniqueArgs extends Ticket_changelogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ticket_changelog findUniqueOrThrow
   */
  export type Ticket_changelogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter, which Ticket_changelog to fetch.
     */
    where: Ticket_changelogWhereUniqueInput
  }


  /**
   * Ticket_changelog base type for findFirst actions
   */
  export type Ticket_changelogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter, which Ticket_changelog to fetch.
     */
    where?: Ticket_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticket_changelogs to fetch.
     */
    orderBy?: Enumerable<Ticket_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ticket_changelogs.
     */
    cursor?: Ticket_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticket_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticket_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ticket_changelogs.
     */
    distinct?: Enumerable<Ticket_changelogScalarFieldEnum>
  }

  /**
   * Ticket_changelog findFirst
   */
  export interface Ticket_changelogFindFirstArgs extends Ticket_changelogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ticket_changelog findFirstOrThrow
   */
  export type Ticket_changelogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter, which Ticket_changelog to fetch.
     */
    where?: Ticket_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticket_changelogs to fetch.
     */
    orderBy?: Enumerable<Ticket_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ticket_changelogs.
     */
    cursor?: Ticket_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticket_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticket_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ticket_changelogs.
     */
    distinct?: Enumerable<Ticket_changelogScalarFieldEnum>
  }


  /**
   * Ticket_changelog findMany
   */
  export type Ticket_changelogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter, which Ticket_changelogs to fetch.
     */
    where?: Ticket_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticket_changelogs to fetch.
     */
    orderBy?: Enumerable<Ticket_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ticket_changelogs.
     */
    cursor?: Ticket_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticket_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticket_changelogs.
     */
    skip?: number
    distinct?: Enumerable<Ticket_changelogScalarFieldEnum>
  }


  /**
   * Ticket_changelog create
   */
  export type Ticket_changelogCreateArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * The data needed to create a Ticket_changelog.
     */
    data: XOR<Ticket_changelogCreateInput, Ticket_changelogUncheckedCreateInput>
  }


  /**
   * Ticket_changelog createMany
   */
  export type Ticket_changelogCreateManyArgs = {
    /**
     * The data used to create many Ticket_changelogs.
     */
    data: Enumerable<Ticket_changelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ticket_changelog update
   */
  export type Ticket_changelogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * The data needed to update a Ticket_changelog.
     */
    data: XOR<Ticket_changelogUpdateInput, Ticket_changelogUncheckedUpdateInput>
    /**
     * Choose, which Ticket_changelog to update.
     */
    where: Ticket_changelogWhereUniqueInput
  }


  /**
   * Ticket_changelog updateMany
   */
  export type Ticket_changelogUpdateManyArgs = {
    /**
     * The data used to update Ticket_changelogs.
     */
    data: XOR<Ticket_changelogUpdateManyMutationInput, Ticket_changelogUncheckedUpdateManyInput>
    /**
     * Filter which Ticket_changelogs to update
     */
    where?: Ticket_changelogWhereInput
  }


  /**
   * Ticket_changelog upsert
   */
  export type Ticket_changelogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * The filter to search for the Ticket_changelog to update in case it exists.
     */
    where: Ticket_changelogWhereUniqueInput
    /**
     * In case the Ticket_changelog found by the `where` argument doesn't exist, create a new Ticket_changelog with this data.
     */
    create: XOR<Ticket_changelogCreateInput, Ticket_changelogUncheckedCreateInput>
    /**
     * In case the Ticket_changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Ticket_changelogUpdateInput, Ticket_changelogUncheckedUpdateInput>
  }


  /**
   * Ticket_changelog delete
   */
  export type Ticket_changelogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
    /**
     * Filter which Ticket_changelog to delete.
     */
    where: Ticket_changelogWhereUniqueInput
  }


  /**
   * Ticket_changelog deleteMany
   */
  export type Ticket_changelogDeleteManyArgs = {
    /**
     * Filter which Ticket_changelogs to delete
     */
    where?: Ticket_changelogWhereInput
  }


  /**
   * Ticket_changelog without action
   */
  export type Ticket_changelogArgs = {
    /**
     * Select specific fields to fetch from the Ticket_changelog
     */
    select?: Ticket_changelogSelect | null
  }



  /**
   * Model User_admin
   */


  export type AggregateUser_admin = {
    _count: User_adminCountAggregateOutputType | null
    _avg: User_adminAvgAggregateOutputType | null
    _sum: User_adminSumAggregateOutputType | null
    _min: User_adminMinAggregateOutputType | null
    _max: User_adminMaxAggregateOutputType | null
  }

  export type User_adminAvgAggregateOutputType = {
    id: number | null
    userflag: number | null
  }

  export type User_adminSumAggregateOutputType = {
    id: number | null
    userflag: number | null
  }

  export type User_adminMinAggregateOutputType = {
    id: number | null
    user: string | null
    password: string | null
    ip: string | null
    time: string | null
    userflag: number | null
  }

  export type User_adminMaxAggregateOutputType = {
    id: number | null
    user: string | null
    password: string | null
    ip: string | null
    time: string | null
    userflag: number | null
  }

  export type User_adminCountAggregateOutputType = {
    id: number
    user: number
    password: number
    ip: number
    time: number
    userflag: number
    _all: number
  }


  export type User_adminAvgAggregateInputType = {
    id?: true
    userflag?: true
  }

  export type User_adminSumAggregateInputType = {
    id?: true
    userflag?: true
  }

  export type User_adminMinAggregateInputType = {
    id?: true
    user?: true
    password?: true
    ip?: true
    time?: true
    userflag?: true
  }

  export type User_adminMaxAggregateInputType = {
    id?: true
    user?: true
    password?: true
    ip?: true
    time?: true
    userflag?: true
  }

  export type User_adminCountAggregateInputType = {
    id?: true
    user?: true
    password?: true
    ip?: true
    time?: true
    userflag?: true
    _all?: true
  }

  export type User_adminAggregateArgs = {
    /**
     * Filter which User_admin to aggregate.
     */
    where?: User_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_admins to fetch.
     */
    orderBy?: Enumerable<User_adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_admins
    **/
    _count?: true | User_adminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_adminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_adminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_adminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_adminMaxAggregateInputType
  }

  export type GetUser_adminAggregateType<T extends User_adminAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_admin[P]>
      : GetScalarType<T[P], AggregateUser_admin[P]>
  }




  export type User_adminGroupByArgs = {
    where?: User_adminWhereInput
    orderBy?: Enumerable<User_adminOrderByWithAggregationInput>
    by: User_adminScalarFieldEnum[]
    having?: User_adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_adminCountAggregateInputType | true
    _avg?: User_adminAvgAggregateInputType
    _sum?: User_adminSumAggregateInputType
    _min?: User_adminMinAggregateInputType
    _max?: User_adminMaxAggregateInputType
  }


  export type User_adminGroupByOutputType = {
    id: number
    user: string
    password: string
    ip: string
    time: string
    userflag: number
    _count: User_adminCountAggregateOutputType | null
    _avg: User_adminAvgAggregateOutputType | null
    _sum: User_adminSumAggregateOutputType | null
    _min: User_adminMinAggregateOutputType | null
    _max: User_adminMaxAggregateOutputType | null
  }

  type GetUser_adminGroupByPayload<T extends User_adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_adminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_adminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_adminGroupByOutputType[P]>
            : GetScalarType<T[P], User_adminGroupByOutputType[P]>
        }
      >
    >


  export type User_adminSelect = {
    id?: boolean
    user?: boolean
    password?: boolean
    ip?: boolean
    time?: boolean
    userflag?: boolean
  }


  export type User_adminGetPayload<S extends boolean | null | undefined | User_adminArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User_admin :
    S extends undefined ? never :
    S extends { include: any } & (User_adminArgs | User_adminFindManyArgs)
    ? User_admin 
    : S extends { select: any } & (User_adminArgs | User_adminFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof User_admin ? User_admin[P] : never
  } 
      : User_admin


  type User_adminCountArgs = 
    Omit<User_adminFindManyArgs, 'select' | 'include'> & {
      select?: User_adminCountAggregateInputType | true
    }

  export interface User_adminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User_admin that matches the filter.
     * @param {User_adminFindUniqueArgs} args - Arguments to find a User_admin
     * @example
     * // Get one User_admin
     * const user_admin = await prisma.user_admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_adminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, User_adminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User_admin'> extends True ? Prisma__User_adminClient<User_adminGetPayload<T>> : Prisma__User_adminClient<User_adminGetPayload<T> | null, null>

    /**
     * Find one User_admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {User_adminFindUniqueOrThrowArgs} args - Arguments to find a User_admin
     * @example
     * // Get one User_admin
     * const user_admin = await prisma.user_admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends User_adminFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, User_adminFindUniqueOrThrowArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Find the first User_admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminFindFirstArgs} args - Arguments to find a User_admin
     * @example
     * // Get one User_admin
     * const user_admin = await prisma.user_admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_adminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, User_adminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User_admin'> extends True ? Prisma__User_adminClient<User_adminGetPayload<T>> : Prisma__User_adminClient<User_adminGetPayload<T> | null, null>

    /**
     * Find the first User_admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminFindFirstOrThrowArgs} args - Arguments to find a User_admin
     * @example
     * // Get one User_admin
     * const user_admin = await prisma.user_admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends User_adminFindFirstOrThrowArgs>(
      args?: SelectSubset<T, User_adminFindFirstOrThrowArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Find zero or more User_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_admins
     * const user_admins = await prisma.user_admin.findMany()
     * 
     * // Get first 10 User_admins
     * const user_admins = await prisma.user_admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_adminWithIdOnly = await prisma.user_admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends User_adminFindManyArgs>(
      args?: SelectSubset<T, User_adminFindManyArgs>
    ): Prisma.PrismaPromise<Array<User_adminGetPayload<T>>>

    /**
     * Create a User_admin.
     * @param {User_adminCreateArgs} args - Arguments to create a User_admin.
     * @example
     * // Create one User_admin
     * const User_admin = await prisma.user_admin.create({
     *   data: {
     *     // ... data to create a User_admin
     *   }
     * })
     * 
    **/
    create<T extends User_adminCreateArgs>(
      args: SelectSubset<T, User_adminCreateArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Create many User_admins.
     *     @param {User_adminCreateManyArgs} args - Arguments to create many User_admins.
     *     @example
     *     // Create many User_admins
     *     const user_admin = await prisma.user_admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends User_adminCreateManyArgs>(
      args?: SelectSubset<T, User_adminCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_admin.
     * @param {User_adminDeleteArgs} args - Arguments to delete one User_admin.
     * @example
     * // Delete one User_admin
     * const User_admin = await prisma.user_admin.delete({
     *   where: {
     *     // ... filter to delete one User_admin
     *   }
     * })
     * 
    **/
    delete<T extends User_adminDeleteArgs>(
      args: SelectSubset<T, User_adminDeleteArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Update one User_admin.
     * @param {User_adminUpdateArgs} args - Arguments to update one User_admin.
     * @example
     * // Update one User_admin
     * const user_admin = await prisma.user_admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_adminUpdateArgs>(
      args: SelectSubset<T, User_adminUpdateArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Delete zero or more User_admins.
     * @param {User_adminDeleteManyArgs} args - Arguments to filter User_admins to delete.
     * @example
     * // Delete a few User_admins
     * const { count } = await prisma.user_admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_adminDeleteManyArgs>(
      args?: SelectSubset<T, User_adminDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_admins
     * const user_admin = await prisma.user_admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_adminUpdateManyArgs>(
      args: SelectSubset<T, User_adminUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_admin.
     * @param {User_adminUpsertArgs} args - Arguments to update or create a User_admin.
     * @example
     * // Update or create a User_admin
     * const user_admin = await prisma.user_admin.upsert({
     *   create: {
     *     // ... data to create a User_admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_admin we want to update
     *   }
     * })
    **/
    upsert<T extends User_adminUpsertArgs>(
      args: SelectSubset<T, User_adminUpsertArgs>
    ): Prisma__User_adminClient<User_adminGetPayload<T>>

    /**
     * Count the number of User_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminCountArgs} args - Arguments to filter User_admins to count.
     * @example
     * // Count the number of User_admins
     * const count = await prisma.user_admin.count({
     *   where: {
     *     // ... the filter for the User_admins we want to count
     *   }
     * })
    **/
    count<T extends User_adminCountArgs>(
      args?: Subset<T, User_adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_adminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_adminAggregateArgs>(args: Subset<T, User_adminAggregateArgs>): Prisma.PrismaPromise<GetUser_adminAggregateType<T>>

    /**
     * Group by User_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_adminGroupByArgs['orderBy'] }
        : { orderBy?: User_adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User_admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_adminClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User_admin base type for findUnique actions
   */
  export type User_adminFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter, which User_admin to fetch.
     */
    where: User_adminWhereUniqueInput
  }

  /**
   * User_admin findUnique
   */
  export interface User_adminFindUniqueArgs extends User_adminFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_admin findUniqueOrThrow
   */
  export type User_adminFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter, which User_admin to fetch.
     */
    where: User_adminWhereUniqueInput
  }


  /**
   * User_admin base type for findFirst actions
   */
  export type User_adminFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter, which User_admin to fetch.
     */
    where?: User_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_admins to fetch.
     */
    orderBy?: Enumerable<User_adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_admins.
     */
    cursor?: User_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_admins.
     */
    distinct?: Enumerable<User_adminScalarFieldEnum>
  }

  /**
   * User_admin findFirst
   */
  export interface User_adminFindFirstArgs extends User_adminFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_admin findFirstOrThrow
   */
  export type User_adminFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter, which User_admin to fetch.
     */
    where?: User_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_admins to fetch.
     */
    orderBy?: Enumerable<User_adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_admins.
     */
    cursor?: User_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_admins.
     */
    distinct?: Enumerable<User_adminScalarFieldEnum>
  }


  /**
   * User_admin findMany
   */
  export type User_adminFindManyArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter, which User_admins to fetch.
     */
    where?: User_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_admins to fetch.
     */
    orderBy?: Enumerable<User_adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_admins.
     */
    cursor?: User_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_admins.
     */
    skip?: number
    distinct?: Enumerable<User_adminScalarFieldEnum>
  }


  /**
   * User_admin create
   */
  export type User_adminCreateArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * The data needed to create a User_admin.
     */
    data: XOR<User_adminCreateInput, User_adminUncheckedCreateInput>
  }


  /**
   * User_admin createMany
   */
  export type User_adminCreateManyArgs = {
    /**
     * The data used to create many User_admins.
     */
    data: Enumerable<User_adminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User_admin update
   */
  export type User_adminUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * The data needed to update a User_admin.
     */
    data: XOR<User_adminUpdateInput, User_adminUncheckedUpdateInput>
    /**
     * Choose, which User_admin to update.
     */
    where: User_adminWhereUniqueInput
  }


  /**
   * User_admin updateMany
   */
  export type User_adminUpdateManyArgs = {
    /**
     * The data used to update User_admins.
     */
    data: XOR<User_adminUpdateManyMutationInput, User_adminUncheckedUpdateManyInput>
    /**
     * Filter which User_admins to update
     */
    where?: User_adminWhereInput
  }


  /**
   * User_admin upsert
   */
  export type User_adminUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * The filter to search for the User_admin to update in case it exists.
     */
    where: User_adminWhereUniqueInput
    /**
     * In case the User_admin found by the `where` argument doesn't exist, create a new User_admin with this data.
     */
    create: XOR<User_adminCreateInput, User_adminUncheckedCreateInput>
    /**
     * In case the User_admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_adminUpdateInput, User_adminUncheckedUpdateInput>
  }


  /**
   * User_admin delete
   */
  export type User_adminDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
    /**
     * Filter which User_admin to delete.
     */
    where: User_adminWhereUniqueInput
  }


  /**
   * User_admin deleteMany
   */
  export type User_adminDeleteManyArgs = {
    /**
     * Filter which User_admins to delete
     */
    where?: User_adminWhereInput
  }


  /**
   * User_admin without action
   */
  export type User_adminArgs = {
    /**
     * Select specific fields to fetch from the User_admin
     */
    select?: User_adminSelect | null
  }



  /**
   * Model Userinfo
   */


  export type AggregateUserinfo = {
    _count: UserinfoCountAggregateOutputType | null
    _avg: UserinfoAvgAggregateOutputType | null
    _sum: UserinfoSumAggregateOutputType | null
    _min: UserinfoMinAggregateOutputType | null
    _max: UserinfoMaxAggregateOutputType | null
  }

  export type UserinfoAvgAggregateOutputType = {
    userId: number | null
    Devid: number | null
    firstexchange: number | null
  }

  export type UserinfoSumAggregateOutputType = {
    userId: number | null
    Devid: number | null
    firstexchange: number | null
  }

  export type UserinfoMinAggregateOutputType = {
    userId: number | null
    Devid: number | null
    firstexchange: number | null
    zhifubao: string | null
    zhifubaoName: string | null
  }

  export type UserinfoMaxAggregateOutputType = {
    userId: number | null
    Devid: number | null
    firstexchange: number | null
    zhifubao: string | null
    zhifubaoName: string | null
  }

  export type UserinfoCountAggregateOutputType = {
    userId: number
    Devid: number
    firstexchange: number
    zhifubao: number
    zhifubaoName: number
    _all: number
  }


  export type UserinfoAvgAggregateInputType = {
    userId?: true
    Devid?: true
    firstexchange?: true
  }

  export type UserinfoSumAggregateInputType = {
    userId?: true
    Devid?: true
    firstexchange?: true
  }

  export type UserinfoMinAggregateInputType = {
    userId?: true
    Devid?: true
    firstexchange?: true
    zhifubao?: true
    zhifubaoName?: true
  }

  export type UserinfoMaxAggregateInputType = {
    userId?: true
    Devid?: true
    firstexchange?: true
    zhifubao?: true
    zhifubaoName?: true
  }

  export type UserinfoCountAggregateInputType = {
    userId?: true
    Devid?: true
    firstexchange?: true
    zhifubao?: true
    zhifubaoName?: true
    _all?: true
  }

  export type UserinfoAggregateArgs = {
    /**
     * Filter which Userinfo to aggregate.
     */
    where?: UserinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfos to fetch.
     */
    orderBy?: Enumerable<UserinfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Userinfos
    **/
    _count?: true | UserinfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserinfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserinfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserinfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserinfoMaxAggregateInputType
  }

  export type GetUserinfoAggregateType<T extends UserinfoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserinfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserinfo[P]>
      : GetScalarType<T[P], AggregateUserinfo[P]>
  }




  export type UserinfoGroupByArgs = {
    where?: UserinfoWhereInput
    orderBy?: Enumerable<UserinfoOrderByWithAggregationInput>
    by: UserinfoScalarFieldEnum[]
    having?: UserinfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserinfoCountAggregateInputType | true
    _avg?: UserinfoAvgAggregateInputType
    _sum?: UserinfoSumAggregateInputType
    _min?: UserinfoMinAggregateInputType
    _max?: UserinfoMaxAggregateInputType
  }


  export type UserinfoGroupByOutputType = {
    userId: number
    Devid: number
    firstexchange: number
    zhifubao: string
    zhifubaoName: string
    _count: UserinfoCountAggregateOutputType | null
    _avg: UserinfoAvgAggregateOutputType | null
    _sum: UserinfoSumAggregateOutputType | null
    _min: UserinfoMinAggregateOutputType | null
    _max: UserinfoMaxAggregateOutputType | null
  }

  type GetUserinfoGroupByPayload<T extends UserinfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserinfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserinfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserinfoGroupByOutputType[P]>
            : GetScalarType<T[P], UserinfoGroupByOutputType[P]>
        }
      >
    >


  export type UserinfoSelect = {
    userId?: boolean
    Devid?: boolean
    firstexchange?: boolean
    zhifubao?: boolean
    zhifubaoName?: boolean
  }


  export type UserinfoGetPayload<S extends boolean | null | undefined | UserinfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Userinfo :
    S extends undefined ? never :
    S extends { include: any } & (UserinfoArgs | UserinfoFindManyArgs)
    ? Userinfo 
    : S extends { select: any } & (UserinfoArgs | UserinfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Userinfo ? Userinfo[P] : never
  } 
      : Userinfo


  type UserinfoCountArgs = 
    Omit<UserinfoFindManyArgs, 'select' | 'include'> & {
      select?: UserinfoCountAggregateInputType | true
    }

  export interface UserinfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Userinfo that matches the filter.
     * @param {UserinfoFindUniqueArgs} args - Arguments to find a Userinfo
     * @example
     * // Get one Userinfo
     * const userinfo = await prisma.userinfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserinfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserinfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Userinfo'> extends True ? Prisma__UserinfoClient<UserinfoGetPayload<T>> : Prisma__UserinfoClient<UserinfoGetPayload<T> | null, null>

    /**
     * Find one Userinfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserinfoFindUniqueOrThrowArgs} args - Arguments to find a Userinfo
     * @example
     * // Get one Userinfo
     * const userinfo = await prisma.userinfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserinfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserinfoFindUniqueOrThrowArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Find the first Userinfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoFindFirstArgs} args - Arguments to find a Userinfo
     * @example
     * // Get one Userinfo
     * const userinfo = await prisma.userinfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserinfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserinfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Userinfo'> extends True ? Prisma__UserinfoClient<UserinfoGetPayload<T>> : Prisma__UserinfoClient<UserinfoGetPayload<T> | null, null>

    /**
     * Find the first Userinfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoFindFirstOrThrowArgs} args - Arguments to find a Userinfo
     * @example
     * // Get one Userinfo
     * const userinfo = await prisma.userinfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserinfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserinfoFindFirstOrThrowArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Find zero or more Userinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userinfos
     * const userinfos = await prisma.userinfo.findMany()
     * 
     * // Get first 10 Userinfos
     * const userinfos = await prisma.userinfo.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userinfoWithUserIdOnly = await prisma.userinfo.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserinfoFindManyArgs>(
      args?: SelectSubset<T, UserinfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserinfoGetPayload<T>>>

    /**
     * Create a Userinfo.
     * @param {UserinfoCreateArgs} args - Arguments to create a Userinfo.
     * @example
     * // Create one Userinfo
     * const Userinfo = await prisma.userinfo.create({
     *   data: {
     *     // ... data to create a Userinfo
     *   }
     * })
     * 
    **/
    create<T extends UserinfoCreateArgs>(
      args: SelectSubset<T, UserinfoCreateArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Create many Userinfos.
     *     @param {UserinfoCreateManyArgs} args - Arguments to create many Userinfos.
     *     @example
     *     // Create many Userinfos
     *     const userinfo = await prisma.userinfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserinfoCreateManyArgs>(
      args?: SelectSubset<T, UserinfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userinfo.
     * @param {UserinfoDeleteArgs} args - Arguments to delete one Userinfo.
     * @example
     * // Delete one Userinfo
     * const Userinfo = await prisma.userinfo.delete({
     *   where: {
     *     // ... filter to delete one Userinfo
     *   }
     * })
     * 
    **/
    delete<T extends UserinfoDeleteArgs>(
      args: SelectSubset<T, UserinfoDeleteArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Update one Userinfo.
     * @param {UserinfoUpdateArgs} args - Arguments to update one Userinfo.
     * @example
     * // Update one Userinfo
     * const userinfo = await prisma.userinfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserinfoUpdateArgs>(
      args: SelectSubset<T, UserinfoUpdateArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Delete zero or more Userinfos.
     * @param {UserinfoDeleteManyArgs} args - Arguments to filter Userinfos to delete.
     * @example
     * // Delete a few Userinfos
     * const { count } = await prisma.userinfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserinfoDeleteManyArgs>(
      args?: SelectSubset<T, UserinfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userinfos
     * const userinfo = await prisma.userinfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserinfoUpdateManyArgs>(
      args: SelectSubset<T, UserinfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userinfo.
     * @param {UserinfoUpsertArgs} args - Arguments to update or create a Userinfo.
     * @example
     * // Update or create a Userinfo
     * const userinfo = await prisma.userinfo.upsert({
     *   create: {
     *     // ... data to create a Userinfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userinfo we want to update
     *   }
     * })
    **/
    upsert<T extends UserinfoUpsertArgs>(
      args: SelectSubset<T, UserinfoUpsertArgs>
    ): Prisma__UserinfoClient<UserinfoGetPayload<T>>

    /**
     * Count the number of Userinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoCountArgs} args - Arguments to filter Userinfos to count.
     * @example
     * // Count the number of Userinfos
     * const count = await prisma.userinfo.count({
     *   where: {
     *     // ... the filter for the Userinfos we want to count
     *   }
     * })
    **/
    count<T extends UserinfoCountArgs>(
      args?: Subset<T, UserinfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserinfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserinfoAggregateArgs>(args: Subset<T, UserinfoAggregateArgs>): Prisma.PrismaPromise<GetUserinfoAggregateType<T>>

    /**
     * Group by Userinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserinfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserinfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserinfoGroupByArgs['orderBy'] }
        : { orderBy?: UserinfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserinfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserinfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Userinfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserinfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Userinfo base type for findUnique actions
   */
  export type UserinfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter, which Userinfo to fetch.
     */
    where: UserinfoWhereUniqueInput
  }

  /**
   * Userinfo findUnique
   */
  export interface UserinfoFindUniqueArgs extends UserinfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Userinfo findUniqueOrThrow
   */
  export type UserinfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter, which Userinfo to fetch.
     */
    where: UserinfoWhereUniqueInput
  }


  /**
   * Userinfo base type for findFirst actions
   */
  export type UserinfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter, which Userinfo to fetch.
     */
    where?: UserinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfos to fetch.
     */
    orderBy?: Enumerable<UserinfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userinfos.
     */
    cursor?: UserinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userinfos.
     */
    distinct?: Enumerable<UserinfoScalarFieldEnum>
  }

  /**
   * Userinfo findFirst
   */
  export interface UserinfoFindFirstArgs extends UserinfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Userinfo findFirstOrThrow
   */
  export type UserinfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter, which Userinfo to fetch.
     */
    where?: UserinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfos to fetch.
     */
    orderBy?: Enumerable<UserinfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userinfos.
     */
    cursor?: UserinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userinfos.
     */
    distinct?: Enumerable<UserinfoScalarFieldEnum>
  }


  /**
   * Userinfo findMany
   */
  export type UserinfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter, which Userinfos to fetch.
     */
    where?: UserinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfos to fetch.
     */
    orderBy?: Enumerable<UserinfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Userinfos.
     */
    cursor?: UserinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfos.
     */
    skip?: number
    distinct?: Enumerable<UserinfoScalarFieldEnum>
  }


  /**
   * Userinfo create
   */
  export type UserinfoCreateArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * The data needed to create a Userinfo.
     */
    data: XOR<UserinfoCreateInput, UserinfoUncheckedCreateInput>
  }


  /**
   * Userinfo createMany
   */
  export type UserinfoCreateManyArgs = {
    /**
     * The data used to create many Userinfos.
     */
    data: Enumerable<UserinfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Userinfo update
   */
  export type UserinfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * The data needed to update a Userinfo.
     */
    data: XOR<UserinfoUpdateInput, UserinfoUncheckedUpdateInput>
    /**
     * Choose, which Userinfo to update.
     */
    where: UserinfoWhereUniqueInput
  }


  /**
   * Userinfo updateMany
   */
  export type UserinfoUpdateManyArgs = {
    /**
     * The data used to update Userinfos.
     */
    data: XOR<UserinfoUpdateManyMutationInput, UserinfoUncheckedUpdateManyInput>
    /**
     * Filter which Userinfos to update
     */
    where?: UserinfoWhereInput
  }


  /**
   * Userinfo upsert
   */
  export type UserinfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * The filter to search for the Userinfo to update in case it exists.
     */
    where: UserinfoWhereUniqueInput
    /**
     * In case the Userinfo found by the `where` argument doesn't exist, create a new Userinfo with this data.
     */
    create: XOR<UserinfoCreateInput, UserinfoUncheckedCreateInput>
    /**
     * In case the Userinfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserinfoUpdateInput, UserinfoUncheckedUpdateInput>
  }


  /**
   * Userinfo delete
   */
  export type UserinfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
    /**
     * Filter which Userinfo to delete.
     */
    where: UserinfoWhereUniqueInput
  }


  /**
   * Userinfo deleteMany
   */
  export type UserinfoDeleteManyArgs = {
    /**
     * Filter which Userinfos to delete
     */
    where?: UserinfoWhereInput
  }


  /**
   * Userinfo without action
   */
  export type UserinfoArgs = {
    /**
     * Select specific fields to fetch from the Userinfo
     */
    select?: UserinfoSelect | null
  }



  /**
   * Model Userinfo_imp
   */


  export type AggregateUserinfo_imp = {
    _count: Userinfo_impCountAggregateOutputType | null
    _avg: Userinfo_impAvgAggregateOutputType | null
    _sum: Userinfo_impSumAggregateOutputType | null
    _min: Userinfo_impMinAggregateOutputType | null
    _max: Userinfo_impMaxAggregateOutputType | null
  }

  export type Userinfo_impAvgAggregateOutputType = {
    userId: number | null
    score: number | null
    diamond: number | null
    giftTicket: number | null
  }

  export type Userinfo_impSumAggregateOutputType = {
    userId: number | null
    score: number | null
    diamond: number | null
    giftTicket: number | null
  }

  export type Userinfo_impMinAggregateOutputType = {
    userId: number | null
    score: number | null
    diamond: number | null
    giftTicket: number | null
  }

  export type Userinfo_impMaxAggregateOutputType = {
    userId: number | null
    score: number | null
    diamond: number | null
    giftTicket: number | null
  }

  export type Userinfo_impCountAggregateOutputType = {
    userId: number
    score: number
    diamond: number
    giftTicket: number
    _all: number
  }


  export type Userinfo_impAvgAggregateInputType = {
    userId?: true
    score?: true
    diamond?: true
    giftTicket?: true
  }

  export type Userinfo_impSumAggregateInputType = {
    userId?: true
    score?: true
    diamond?: true
    giftTicket?: true
  }

  export type Userinfo_impMinAggregateInputType = {
    userId?: true
    score?: true
    diamond?: true
    giftTicket?: true
  }

  export type Userinfo_impMaxAggregateInputType = {
    userId?: true
    score?: true
    diamond?: true
    giftTicket?: true
  }

  export type Userinfo_impCountAggregateInputType = {
    userId?: true
    score?: true
    diamond?: true
    giftTicket?: true
    _all?: true
  }

  export type Userinfo_impAggregateArgs = {
    /**
     * Filter which Userinfo_imp to aggregate.
     */
    where?: Userinfo_impWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfo_imps to fetch.
     */
    orderBy?: Enumerable<Userinfo_impOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Userinfo_impWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfo_imps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfo_imps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Userinfo_imps
    **/
    _count?: true | Userinfo_impCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Userinfo_impAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Userinfo_impSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Userinfo_impMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Userinfo_impMaxAggregateInputType
  }

  export type GetUserinfo_impAggregateType<T extends Userinfo_impAggregateArgs> = {
        [P in keyof T & keyof AggregateUserinfo_imp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserinfo_imp[P]>
      : GetScalarType<T[P], AggregateUserinfo_imp[P]>
  }




  export type Userinfo_impGroupByArgs = {
    where?: Userinfo_impWhereInput
    orderBy?: Enumerable<Userinfo_impOrderByWithAggregationInput>
    by: Userinfo_impScalarFieldEnum[]
    having?: Userinfo_impScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Userinfo_impCountAggregateInputType | true
    _avg?: Userinfo_impAvgAggregateInputType
    _sum?: Userinfo_impSumAggregateInputType
    _min?: Userinfo_impMinAggregateInputType
    _max?: Userinfo_impMaxAggregateInputType
  }


  export type Userinfo_impGroupByOutputType = {
    userId: number
    score: number
    diamond: number
    giftTicket: number
    _count: Userinfo_impCountAggregateOutputType | null
    _avg: Userinfo_impAvgAggregateOutputType | null
    _sum: Userinfo_impSumAggregateOutputType | null
    _min: Userinfo_impMinAggregateOutputType | null
    _max: Userinfo_impMaxAggregateOutputType | null
  }

  type GetUserinfo_impGroupByPayload<T extends Userinfo_impGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Userinfo_impGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Userinfo_impGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Userinfo_impGroupByOutputType[P]>
            : GetScalarType<T[P], Userinfo_impGroupByOutputType[P]>
        }
      >
    >


  export type Userinfo_impSelect = {
    userId?: boolean
    score?: boolean
    diamond?: boolean
    giftTicket?: boolean
  }


  export type Userinfo_impGetPayload<S extends boolean | null | undefined | Userinfo_impArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Userinfo_imp :
    S extends undefined ? never :
    S extends { include: any } & (Userinfo_impArgs | Userinfo_impFindManyArgs)
    ? Userinfo_imp 
    : S extends { select: any } & (Userinfo_impArgs | Userinfo_impFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Userinfo_imp ? Userinfo_imp[P] : never
  } 
      : Userinfo_imp


  type Userinfo_impCountArgs = 
    Omit<Userinfo_impFindManyArgs, 'select' | 'include'> & {
      select?: Userinfo_impCountAggregateInputType | true
    }

  export interface Userinfo_impDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Userinfo_imp that matches the filter.
     * @param {Userinfo_impFindUniqueArgs} args - Arguments to find a Userinfo_imp
     * @example
     * // Get one Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Userinfo_impFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Userinfo_impFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Userinfo_imp'> extends True ? Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>> : Prisma__Userinfo_impClient<Userinfo_impGetPayload<T> | null, null>

    /**
     * Find one Userinfo_imp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Userinfo_impFindUniqueOrThrowArgs} args - Arguments to find a Userinfo_imp
     * @example
     * // Get one Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Userinfo_impFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Userinfo_impFindUniqueOrThrowArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Find the first Userinfo_imp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impFindFirstArgs} args - Arguments to find a Userinfo_imp
     * @example
     * // Get one Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Userinfo_impFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Userinfo_impFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Userinfo_imp'> extends True ? Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>> : Prisma__Userinfo_impClient<Userinfo_impGetPayload<T> | null, null>

    /**
     * Find the first Userinfo_imp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impFindFirstOrThrowArgs} args - Arguments to find a Userinfo_imp
     * @example
     * // Get one Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Userinfo_impFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Userinfo_impFindFirstOrThrowArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Find zero or more Userinfo_imps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userinfo_imps
     * const userinfo_imps = await prisma.userinfo_imp.findMany()
     * 
     * // Get first 10 Userinfo_imps
     * const userinfo_imps = await prisma.userinfo_imp.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userinfo_impWithUserIdOnly = await prisma.userinfo_imp.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends Userinfo_impFindManyArgs>(
      args?: SelectSubset<T, Userinfo_impFindManyArgs>
    ): Prisma.PrismaPromise<Array<Userinfo_impGetPayload<T>>>

    /**
     * Create a Userinfo_imp.
     * @param {Userinfo_impCreateArgs} args - Arguments to create a Userinfo_imp.
     * @example
     * // Create one Userinfo_imp
     * const Userinfo_imp = await prisma.userinfo_imp.create({
     *   data: {
     *     // ... data to create a Userinfo_imp
     *   }
     * })
     * 
    **/
    create<T extends Userinfo_impCreateArgs>(
      args: SelectSubset<T, Userinfo_impCreateArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Create many Userinfo_imps.
     *     @param {Userinfo_impCreateManyArgs} args - Arguments to create many Userinfo_imps.
     *     @example
     *     // Create many Userinfo_imps
     *     const userinfo_imp = await prisma.userinfo_imp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Userinfo_impCreateManyArgs>(
      args?: SelectSubset<T, Userinfo_impCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userinfo_imp.
     * @param {Userinfo_impDeleteArgs} args - Arguments to delete one Userinfo_imp.
     * @example
     * // Delete one Userinfo_imp
     * const Userinfo_imp = await prisma.userinfo_imp.delete({
     *   where: {
     *     // ... filter to delete one Userinfo_imp
     *   }
     * })
     * 
    **/
    delete<T extends Userinfo_impDeleteArgs>(
      args: SelectSubset<T, Userinfo_impDeleteArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Update one Userinfo_imp.
     * @param {Userinfo_impUpdateArgs} args - Arguments to update one Userinfo_imp.
     * @example
     * // Update one Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Userinfo_impUpdateArgs>(
      args: SelectSubset<T, Userinfo_impUpdateArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Delete zero or more Userinfo_imps.
     * @param {Userinfo_impDeleteManyArgs} args - Arguments to filter Userinfo_imps to delete.
     * @example
     * // Delete a few Userinfo_imps
     * const { count } = await prisma.userinfo_imp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Userinfo_impDeleteManyArgs>(
      args?: SelectSubset<T, Userinfo_impDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userinfo_imps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userinfo_imps
     * const userinfo_imp = await prisma.userinfo_imp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Userinfo_impUpdateManyArgs>(
      args: SelectSubset<T, Userinfo_impUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userinfo_imp.
     * @param {Userinfo_impUpsertArgs} args - Arguments to update or create a Userinfo_imp.
     * @example
     * // Update or create a Userinfo_imp
     * const userinfo_imp = await prisma.userinfo_imp.upsert({
     *   create: {
     *     // ... data to create a Userinfo_imp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userinfo_imp we want to update
     *   }
     * })
    **/
    upsert<T extends Userinfo_impUpsertArgs>(
      args: SelectSubset<T, Userinfo_impUpsertArgs>
    ): Prisma__Userinfo_impClient<Userinfo_impGetPayload<T>>

    /**
     * Count the number of Userinfo_imps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impCountArgs} args - Arguments to filter Userinfo_imps to count.
     * @example
     * // Count the number of Userinfo_imps
     * const count = await prisma.userinfo_imp.count({
     *   where: {
     *     // ... the filter for the Userinfo_imps we want to count
     *   }
     * })
    **/
    count<T extends Userinfo_impCountArgs>(
      args?: Subset<T, Userinfo_impCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Userinfo_impCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userinfo_imp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Userinfo_impAggregateArgs>(args: Subset<T, Userinfo_impAggregateArgs>): Prisma.PrismaPromise<GetUserinfo_impAggregateType<T>>

    /**
     * Group by Userinfo_imp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Userinfo_impGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Userinfo_impGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Userinfo_impGroupByArgs['orderBy'] }
        : { orderBy?: Userinfo_impGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Userinfo_impGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserinfo_impGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Userinfo_imp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Userinfo_impClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Userinfo_imp base type for findUnique actions
   */
  export type Userinfo_impFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter, which Userinfo_imp to fetch.
     */
    where: Userinfo_impWhereUniqueInput
  }

  /**
   * Userinfo_imp findUnique
   */
  export interface Userinfo_impFindUniqueArgs extends Userinfo_impFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Userinfo_imp findUniqueOrThrow
   */
  export type Userinfo_impFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter, which Userinfo_imp to fetch.
     */
    where: Userinfo_impWhereUniqueInput
  }


  /**
   * Userinfo_imp base type for findFirst actions
   */
  export type Userinfo_impFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter, which Userinfo_imp to fetch.
     */
    where?: Userinfo_impWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfo_imps to fetch.
     */
    orderBy?: Enumerable<Userinfo_impOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userinfo_imps.
     */
    cursor?: Userinfo_impWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfo_imps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfo_imps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userinfo_imps.
     */
    distinct?: Enumerable<Userinfo_impScalarFieldEnum>
  }

  /**
   * Userinfo_imp findFirst
   */
  export interface Userinfo_impFindFirstArgs extends Userinfo_impFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Userinfo_imp findFirstOrThrow
   */
  export type Userinfo_impFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter, which Userinfo_imp to fetch.
     */
    where?: Userinfo_impWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfo_imps to fetch.
     */
    orderBy?: Enumerable<Userinfo_impOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userinfo_imps.
     */
    cursor?: Userinfo_impWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfo_imps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfo_imps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userinfo_imps.
     */
    distinct?: Enumerable<Userinfo_impScalarFieldEnum>
  }


  /**
   * Userinfo_imp findMany
   */
  export type Userinfo_impFindManyArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter, which Userinfo_imps to fetch.
     */
    where?: Userinfo_impWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userinfo_imps to fetch.
     */
    orderBy?: Enumerable<Userinfo_impOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Userinfo_imps.
     */
    cursor?: Userinfo_impWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userinfo_imps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userinfo_imps.
     */
    skip?: number
    distinct?: Enumerable<Userinfo_impScalarFieldEnum>
  }


  /**
   * Userinfo_imp create
   */
  export type Userinfo_impCreateArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * The data needed to create a Userinfo_imp.
     */
    data: XOR<Userinfo_impCreateInput, Userinfo_impUncheckedCreateInput>
  }


  /**
   * Userinfo_imp createMany
   */
  export type Userinfo_impCreateManyArgs = {
    /**
     * The data used to create many Userinfo_imps.
     */
    data: Enumerable<Userinfo_impCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Userinfo_imp update
   */
  export type Userinfo_impUpdateArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * The data needed to update a Userinfo_imp.
     */
    data: XOR<Userinfo_impUpdateInput, Userinfo_impUncheckedUpdateInput>
    /**
     * Choose, which Userinfo_imp to update.
     */
    where: Userinfo_impWhereUniqueInput
  }


  /**
   * Userinfo_imp updateMany
   */
  export type Userinfo_impUpdateManyArgs = {
    /**
     * The data used to update Userinfo_imps.
     */
    data: XOR<Userinfo_impUpdateManyMutationInput, Userinfo_impUncheckedUpdateManyInput>
    /**
     * Filter which Userinfo_imps to update
     */
    where?: Userinfo_impWhereInput
  }


  /**
   * Userinfo_imp upsert
   */
  export type Userinfo_impUpsertArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * The filter to search for the Userinfo_imp to update in case it exists.
     */
    where: Userinfo_impWhereUniqueInput
    /**
     * In case the Userinfo_imp found by the `where` argument doesn't exist, create a new Userinfo_imp with this data.
     */
    create: XOR<Userinfo_impCreateInput, Userinfo_impUncheckedCreateInput>
    /**
     * In case the Userinfo_imp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Userinfo_impUpdateInput, Userinfo_impUncheckedUpdateInput>
  }


  /**
   * Userinfo_imp delete
   */
  export type Userinfo_impDeleteArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
    /**
     * Filter which Userinfo_imp to delete.
     */
    where: Userinfo_impWhereUniqueInput
  }


  /**
   * Userinfo_imp deleteMany
   */
  export type Userinfo_impDeleteManyArgs = {
    /**
     * Filter which Userinfo_imps to delete
     */
    where?: Userinfo_impWhereInput
  }


  /**
   * Userinfo_imp without action
   */
  export type Userinfo_impArgs = {
    /**
     * Select specific fields to fetch from the Userinfo_imp
     */
    select?: Userinfo_impSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BankbindlistScalarFieldEnum: {
    cardId: 'cardId',
    userId: 'userId',
    account: 'account',
    name: 'name',
    bankType: 'bankType'
  };

  export type BankbindlistScalarFieldEnum = (typeof BankbindlistScalarFieldEnum)[keyof typeof BankbindlistScalarFieldEnum]


  export const BanknameScalarFieldEnum: {
    typeId: 'typeId',
    bankName: 'bankName'
  };

  export type BanknameScalarFieldEnum = (typeof BanknameScalarFieldEnum)[keyof typeof BanknameScalarFieldEnum]


  export const ChatlogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    toUserId: 'toUserId',
    nickname: 'nickname',
    msg: 'msg',
    isSendEnd: 'isSendEnd',
    addDate: 'addDate'
  };

  export type ChatlogScalarFieldEnum = (typeof ChatlogScalarFieldEnum)[keyof typeof ChatlogScalarFieldEnum]


  export const Diamond_changelogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    diamond_before: 'diamond_before',
    diamond_change: 'diamond_change',
    diamond_current: 'diamond_current',
    change_type: 'change_type',
    change_time: 'change_time',
    isOnline: 'isOnline'
  };

  export type Diamond_changelogScalarFieldEnum = (typeof Diamond_changelogScalarFieldEnum)[keyof typeof Diamond_changelogScalarFieldEnum]


  export const DongshanzaiqiScalarFieldEnum: {
    userId: 'userId',
    dcount: 'dcount',
    dtime: 'dtime'
  };

  export type DongshanzaiqiScalarFieldEnum = (typeof DongshanzaiqiScalarFieldEnum)[keyof typeof DongshanzaiqiScalarFieldEnum]


  export const Game_login_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    serverId: 'serverId',
    encoin: 'encoin',
    login_score: 'login_score',
    logout_score: 'logout_score',
    loginDate: 'loginDate',
    logoutDate: 'logoutDate'
  };

  export type Game_login_historyScalarFieldEnum = (typeof Game_login_historyScalarFieldEnum)[keyof typeof Game_login_historyScalarFieldEnum]


  export const Game_onlinenumScalarFieldEnum: {
    id: 'id',
    gid: 'gid',
    gport: 'gport',
    num: 'num',
    createtime: 'createtime'
  };

  export type Game_onlinenumScalarFieldEnum = (typeof Game_onlinenumScalarFieldEnum)[keyof typeof Game_onlinenumScalarFieldEnum]


  export const LineoutScalarFieldEnum: {
    userId: 'userId'
  };

  export type LineoutScalarFieldEnum = (typeof LineoutScalarFieldEnum)[keyof typeof LineoutScalarFieldEnum]


  export const Login_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loginType: 'loginType',
    loginToken: 'loginToken',
    passwordToken: 'passwordToken',
    score: 'score',
    loginDate: 'loginDate',
    loginIp: 'loginIp'
  };

  export type Login_historyScalarFieldEnum = (typeof Login_historyScalarFieldEnum)[keyof typeof Login_historyScalarFieldEnum]


  export const LogintempScalarFieldEnum: {
    id: 'id',
    loginid: 'loginid',
    logincode: 'logincode',
    loginDate: 'loginDate'
  };

  export type LogintempScalarFieldEnum = (typeof LogintempScalarFieldEnum)[keyof typeof LogintempScalarFieldEnum]


  export const Logout_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    logoutType: 'logoutType',
    score: 'score',
    logoutDate: 'logoutDate',
    logoutIp: 'logoutIp'
  };

  export type Logout_historyScalarFieldEnum = (typeof Logout_historyScalarFieldEnum)[keyof typeof Logout_historyScalarFieldEnum]


  export const MarkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    useCoin: 'useCoin',
    winCoin: 'winCoin',
    tax: 'tax',
    gameId: 'gameId',
    serverId: 'serverId',
    balanceTime: 'balanceTime',
    mark: 'mark'
  };

  export type MarkScalarFieldEnum = (typeof MarkScalarFieldEnum)[keyof typeof MarkScalarFieldEnum]


  export const MsgScalarFieldEnum: {
    msgId: 'msgId',
    userId: 'userId',
    winPropId: 'winPropId',
    winPropCount: 'winPropCount',
    winScore: 'winScore',
    matchlogId: 'matchlogId',
    isGetPrize: 'isGetPrize',
    type: 'type',
    AddDate: 'AddDate',
    sendCoinUserId: 'sendCoinUserId',
    nickName: 'nickName'
  };

  export type MsgScalarFieldEnum = (typeof MsgScalarFieldEnum)[keyof typeof MsgScalarFieldEnum]


  export const NewuseraccountsScalarFieldEnum: {
    Id: 'Id',
    Account: 'Account',
    Password: 'Password',
    nickname: 'nickname',
    score: 'score',
    AddDate: 'AddDate',
    LoginCount: 'LoginCount',
    p: 'p',
    diamond: 'diamond',
    giftTicket: 'giftTicket',
    phoneNo: 'phoneNo',
    email: 'email',
    sex: 'sex',
    city: 'city',
    province: 'province',
    country: 'country',
    headimgurl: 'headimgurl',
    language: 'language',
    Robot: 'Robot',
    ChannelType: 'ChannelType',
    official: 'official',
    gametoken: 'gametoken',
    qdid: 'qdid',
    housecard: 'housecard',
    totalRecharge: 'totalRecharge',
    loginip: 'loginip',
    iscanlogin: 'iscanlogin',
    diansha_score: 'diansha_score',
    diansha_gameids: 'diansha_gameids',
    is_vip: 'is_vip',
    g4_uid: 'g4_uid',
    account_using: 'account_using',
    bankPwd: 'bankPwd',
    bankScore: 'bankScore'
  };

  export type NewuseraccountsScalarFieldEnum = (typeof NewuseraccountsScalarFieldEnum)[keyof typeof NewuseraccountsScalarFieldEnum]


  export const PcdandanScalarFieldEnum: {
    userId: 'userId',
    pcdandanId: 'pcdandanId',
    Devid: 'Devid'
  };

  export type PcdandanScalarFieldEnum = (typeof PcdandanScalarFieldEnum)[keyof typeof PcdandanScalarFieldEnum]


  export const Prop_changelogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    propid: 'propid',
    change_before: 'change_before',
    change_count: 'change_count',
    change_after: 'change_after',
    insertTime: 'insertTime',
    gameid: 'gameid',
    codeid: 'codeid'
  };

  export type Prop_changelogScalarFieldEnum = (typeof Prop_changelogScalarFieldEnum)[keyof typeof Prop_changelogScalarFieldEnum]


  export const Prop_itemScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    propid: 'propid',
    propcount: 'propcount'
  };

  export type Prop_itemScalarFieldEnum = (typeof Prop_itemScalarFieldEnum)[keyof typeof Prop_itemScalarFieldEnum]


  export const RechargeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    Account: 'Account',
    total_fee: 'total_fee',
    out_trade_no: 'out_trade_no',
    goodsid: 'goodsid',
    state: 'state',
    createTime: 'createTime'
  };

  export type RechargeScalarFieldEnum = (typeof RechargeScalarFieldEnum)[keyof typeof RechargeScalarFieldEnum]


  export const Recharge_firstScalarFieldEnum: {
    userId: 'userId',
    FIRST: 'FIRST',
    anyFirst: 'anyFirst',
    goods1: 'goods1',
    goods2: 'goods2',
    goods3: 'goods3',
    goods4: 'goods4',
    goods5: 'goods5',
    daytime: 'daytime'
  };

  export type Recharge_firstScalarFieldEnum = (typeof Recharge_firstScalarFieldEnum)[keyof typeof Recharge_firstScalarFieldEnum]


  export const RechargelogScalarFieldEnum: {
    id: 'id',
    adminid: 'adminid',
    userid: 'userid',
    createtime: 'createtime',
    czfee: 'czfee',
    oldfee: 'oldfee',
    newfee: 'newfee',
    type: 'type'
  };

  export type RechargelogScalarFieldEnum = (typeof RechargelogScalarFieldEnum)[keyof typeof RechargelogScalarFieldEnum]


  export const ReturnscorelogScalarFieldEnum: {
    id: 'id',
    msg: 'msg',
    ret: 'ret',
    createtime: 'createtime'
  };

  export type ReturnscorelogScalarFieldEnum = (typeof ReturnscorelogScalarFieldEnum)[keyof typeof ReturnscorelogScalarFieldEnum]


  export const Score_changelogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    ret: 'ret',
    createtime: 'createtime'
  };

  export type Score_changelogScalarFieldEnum = (typeof Score_changelogScalarFieldEnum)[keyof typeof Score_changelogScalarFieldEnum]


  export const ScoreoutScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score',
    coin: 'coin',
    tax: 'tax',
    addDate: 'addDate',
    state: 'state',
    outDate: 'outDate',
    cardType: 'cardType',
    cardId: 'cardId',
    out_trade_no: 'out_trade_no',
    zfb_account: 'zfb_account',
    zfb_name: 'zfb_name',
    remark: 'remark'
  };

  export type ScoreoutScalarFieldEnum = (typeof ScoreoutScalarFieldEnum)[keyof typeof ScoreoutScalarFieldEnum]


  export const SendcoinlogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    getcoinuserid: 'getcoinuserid',
    sendcoin: 'sendcoin',
    addtime: 'addtime'
  };

  export type SendcoinlogScalarFieldEnum = (typeof SendcoinlogScalarFieldEnum)[keyof typeof SendcoinlogScalarFieldEnum]


  export const Server_logScalarFieldEnum: {
    id: 'id',
    txt: 'txt',
    status: 'status',
    createtime: 'createtime',
    updatetime: 'updatetime'
  };

  export type Server_logScalarFieldEnum = (typeof Server_logScalarFieldEnum)[keyof typeof Server_logScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TempadddiamondScalarFieldEnum: {
    userId: 'userId',
    score: 'score',
    change_type: 'change_type'
  };

  export type TempadddiamondScalarFieldEnum = (typeof TempadddiamondScalarFieldEnum)[keyof typeof TempadddiamondScalarFieldEnum]


  export const TempaddscoreScalarFieldEnum: {
    userId: 'userId',
    score: 'score',
    change_type: 'change_type'
  };

  export type TempaddscoreScalarFieldEnum = (typeof TempaddscoreScalarFieldEnum)[keyof typeof TempaddscoreScalarFieldEnum]


  export const Ticket_changelogScalarFieldEnum: {
    userid: 'userid',
    score_before: 'score_before',
    score_change: 'score_change',
    score_current: 'score_current',
    change_type: 'change_type',
    change_time: 'change_time',
    isOnline: 'isOnline'
  };

  export type Ticket_changelogScalarFieldEnum = (typeof Ticket_changelogScalarFieldEnum)[keyof typeof Ticket_changelogScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const User_adminScalarFieldEnum: {
    id: 'id',
    user: 'user',
    password: 'password',
    ip: 'ip',
    time: 'time',
    userflag: 'userflag'
  };

  export type User_adminScalarFieldEnum = (typeof User_adminScalarFieldEnum)[keyof typeof User_adminScalarFieldEnum]


  export const UserinfoScalarFieldEnum: {
    userId: 'userId',
    Devid: 'Devid',
    firstexchange: 'firstexchange',
    zhifubao: 'zhifubao',
    zhifubaoName: 'zhifubaoName'
  };

  export type UserinfoScalarFieldEnum = (typeof UserinfoScalarFieldEnum)[keyof typeof UserinfoScalarFieldEnum]


  export const Userinfo_impScalarFieldEnum: {
    userId: 'userId',
    score: 'score',
    diamond: 'diamond',
    giftTicket: 'giftTicket'
  };

  export type Userinfo_impScalarFieldEnum = (typeof Userinfo_impScalarFieldEnum)[keyof typeof Userinfo_impScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type BankbindlistWhereInput = {
    AND?: Enumerable<BankbindlistWhereInput>
    OR?: Enumerable<BankbindlistWhereInput>
    NOT?: Enumerable<BankbindlistWhereInput>
    cardId?: IntFilter | number
    userId?: IntFilter | number
    account?: StringFilter | string
    name?: StringFilter | string
    bankType?: StringFilter | string
  }

  export type BankbindlistOrderByWithRelationInput = {
    cardId?: SortOrder
    userId?: SortOrder
    account?: SortOrder
    name?: SortOrder
    bankType?: SortOrder
  }

  export type BankbindlistWhereUniqueInput = {
    cardId?: number
  }

  export type BankbindlistOrderByWithAggregationInput = {
    cardId?: SortOrder
    userId?: SortOrder
    account?: SortOrder
    name?: SortOrder
    bankType?: SortOrder
    _count?: BankbindlistCountOrderByAggregateInput
    _avg?: BankbindlistAvgOrderByAggregateInput
    _max?: BankbindlistMaxOrderByAggregateInput
    _min?: BankbindlistMinOrderByAggregateInput
    _sum?: BankbindlistSumOrderByAggregateInput
  }

  export type BankbindlistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankbindlistScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankbindlistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankbindlistScalarWhereWithAggregatesInput>
    cardId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    account?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    bankType?: StringWithAggregatesFilter | string
  }

  export type BanknameWhereInput = {
    AND?: Enumerable<BanknameWhereInput>
    OR?: Enumerable<BanknameWhereInput>
    NOT?: Enumerable<BanknameWhereInput>
    typeId?: IntFilter | number
    bankName?: StringFilter | string
  }

  export type BanknameOrderByWithRelationInput = {
    typeId?: SortOrder
    bankName?: SortOrder
  }

  export type BanknameWhereUniqueInput = {
    typeId?: number
  }

  export type BanknameOrderByWithAggregationInput = {
    typeId?: SortOrder
    bankName?: SortOrder
    _count?: BanknameCountOrderByAggregateInput
    _avg?: BanknameAvgOrderByAggregateInput
    _max?: BanknameMaxOrderByAggregateInput
    _min?: BanknameMinOrderByAggregateInput
    _sum?: BanknameSumOrderByAggregateInput
  }

  export type BanknameScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BanknameScalarWhereWithAggregatesInput>
    OR?: Enumerable<BanknameScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BanknameScalarWhereWithAggregatesInput>
    typeId?: IntWithAggregatesFilter | number
    bankName?: StringWithAggregatesFilter | string
  }

  export type ChatlogWhereInput = {
    AND?: Enumerable<ChatlogWhereInput>
    OR?: Enumerable<ChatlogWhereInput>
    NOT?: Enumerable<ChatlogWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    toUserId?: IntFilter | number
    nickname?: StringFilter | string
    msg?: StringFilter | string
    isSendEnd?: IntFilter | number
    addDate?: DateTimeFilter | Date | string
  }

  export type ChatlogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    nickname?: SortOrder
    msg?: SortOrder
    isSendEnd?: SortOrder
    addDate?: SortOrder
  }

  export type ChatlogWhereUniqueInput = {
    id?: number
  }

  export type ChatlogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    nickname?: SortOrder
    msg?: SortOrder
    isSendEnd?: SortOrder
    addDate?: SortOrder
    _count?: ChatlogCountOrderByAggregateInput
    _avg?: ChatlogAvgOrderByAggregateInput
    _max?: ChatlogMaxOrderByAggregateInput
    _min?: ChatlogMinOrderByAggregateInput
    _sum?: ChatlogSumOrderByAggregateInput
  }

  export type ChatlogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatlogScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatlogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatlogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    nickname?: StringWithAggregatesFilter | string
    msg?: StringWithAggregatesFilter | string
    isSendEnd?: IntWithAggregatesFilter | number
    addDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Diamond_changelogWhereInput = {
    AND?: Enumerable<Diamond_changelogWhereInput>
    OR?: Enumerable<Diamond_changelogWhereInput>
    NOT?: Enumerable<Diamond_changelogWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    diamond_before?: IntFilter | number
    diamond_change?: IntFilter | number
    diamond_current?: IntFilter | number
    change_type?: IntFilter | number
    change_time?: DateTimeFilter | Date | string
    isOnline?: IntFilter | number
  }

  export type Diamond_changelogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Diamond_changelogWhereUniqueInput = {
    id?: number
  }

  export type Diamond_changelogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
    _count?: Diamond_changelogCountOrderByAggregateInput
    _avg?: Diamond_changelogAvgOrderByAggregateInput
    _max?: Diamond_changelogMaxOrderByAggregateInput
    _min?: Diamond_changelogMinOrderByAggregateInput
    _sum?: Diamond_changelogSumOrderByAggregateInput
  }

  export type Diamond_changelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Diamond_changelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<Diamond_changelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Diamond_changelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    diamond_before?: IntWithAggregatesFilter | number
    diamond_change?: IntWithAggregatesFilter | number
    diamond_current?: IntWithAggregatesFilter | number
    change_type?: IntWithAggregatesFilter | number
    change_time?: DateTimeWithAggregatesFilter | Date | string
    isOnline?: IntWithAggregatesFilter | number
  }

  export type DongshanzaiqiWhereInput = {
    AND?: Enumerable<DongshanzaiqiWhereInput>
    OR?: Enumerable<DongshanzaiqiWhereInput>
    NOT?: Enumerable<DongshanzaiqiWhereInput>
    userId?: IntFilter | number
    dcount?: IntFilter | number
    dtime?: DateTimeFilter | Date | string
  }

  export type DongshanzaiqiOrderByWithRelationInput = {
    userId?: SortOrder
    dcount?: SortOrder
    dtime?: SortOrder
  }

  export type DongshanzaiqiWhereUniqueInput = {
    userId?: number
  }

  export type DongshanzaiqiOrderByWithAggregationInput = {
    userId?: SortOrder
    dcount?: SortOrder
    dtime?: SortOrder
    _count?: DongshanzaiqiCountOrderByAggregateInput
    _avg?: DongshanzaiqiAvgOrderByAggregateInput
    _max?: DongshanzaiqiMaxOrderByAggregateInput
    _min?: DongshanzaiqiMinOrderByAggregateInput
    _sum?: DongshanzaiqiSumOrderByAggregateInput
  }

  export type DongshanzaiqiScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DongshanzaiqiScalarWhereWithAggregatesInput>
    OR?: Enumerable<DongshanzaiqiScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DongshanzaiqiScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    dcount?: IntWithAggregatesFilter | number
    dtime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Game_login_historyWhereInput = {
    AND?: Enumerable<Game_login_historyWhereInput>
    OR?: Enumerable<Game_login_historyWhereInput>
    NOT?: Enumerable<Game_login_historyWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    gameId?: IntFilter | number
    serverId?: StringFilter | string
    encoin?: IntFilter | number
    login_score?: IntFilter | number
    logout_score?: IntFilter | number
    loginDate?: DateTimeFilter | Date | string
    logoutDate?: DateTimeFilter | Date | string
  }

  export type Game_login_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type Game_login_historyWhereUniqueInput = {
    id?: number
  }

  export type Game_login_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
    _count?: Game_login_historyCountOrderByAggregateInput
    _avg?: Game_login_historyAvgOrderByAggregateInput
    _max?: Game_login_historyMaxOrderByAggregateInput
    _min?: Game_login_historyMinOrderByAggregateInput
    _sum?: Game_login_historySumOrderByAggregateInput
  }

  export type Game_login_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Game_login_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<Game_login_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Game_login_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    gameId?: IntWithAggregatesFilter | number
    serverId?: StringWithAggregatesFilter | string
    encoin?: IntWithAggregatesFilter | number
    login_score?: IntWithAggregatesFilter | number
    logout_score?: IntWithAggregatesFilter | number
    loginDate?: DateTimeWithAggregatesFilter | Date | string
    logoutDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Game_onlinenumWhereInput = {
    AND?: Enumerable<Game_onlinenumWhereInput>
    OR?: Enumerable<Game_onlinenumWhereInput>
    NOT?: Enumerable<Game_onlinenumWhereInput>
    id?: IntFilter | number
    gid?: IntFilter | number
    gport?: StringFilter | string
    num?: IntFilter | number
    createtime?: StringFilter | string
  }

  export type Game_onlinenumOrderByWithRelationInput = {
    id?: SortOrder
    gid?: SortOrder
    gport?: SortOrder
    num?: SortOrder
    createtime?: SortOrder
  }

  export type Game_onlinenumWhereUniqueInput = {
    id?: number
  }

  export type Game_onlinenumOrderByWithAggregationInput = {
    id?: SortOrder
    gid?: SortOrder
    gport?: SortOrder
    num?: SortOrder
    createtime?: SortOrder
    _count?: Game_onlinenumCountOrderByAggregateInput
    _avg?: Game_onlinenumAvgOrderByAggregateInput
    _max?: Game_onlinenumMaxOrderByAggregateInput
    _min?: Game_onlinenumMinOrderByAggregateInput
    _sum?: Game_onlinenumSumOrderByAggregateInput
  }

  export type Game_onlinenumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Game_onlinenumScalarWhereWithAggregatesInput>
    OR?: Enumerable<Game_onlinenumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Game_onlinenumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    gid?: IntWithAggregatesFilter | number
    gport?: StringWithAggregatesFilter | string
    num?: IntWithAggregatesFilter | number
    createtime?: StringWithAggregatesFilter | string
  }

  export type LineoutWhereInput = {
    AND?: Enumerable<LineoutWhereInput>
    OR?: Enumerable<LineoutWhereInput>
    NOT?: Enumerable<LineoutWhereInput>
    userId?: IntFilter | number
  }

  export type LineoutOrderByWithRelationInput = {
    userId?: SortOrder
  }

  export type LineoutWhereUniqueInput = {
    userId?: number
  }

  export type LineoutOrderByWithAggregationInput = {
    userId?: SortOrder
    _count?: LineoutCountOrderByAggregateInput
    _avg?: LineoutAvgOrderByAggregateInput
    _max?: LineoutMaxOrderByAggregateInput
    _min?: LineoutMinOrderByAggregateInput
    _sum?: LineoutSumOrderByAggregateInput
  }

  export type LineoutScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LineoutScalarWhereWithAggregatesInput>
    OR?: Enumerable<LineoutScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LineoutScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
  }

  export type Login_historyWhereInput = {
    AND?: Enumerable<Login_historyWhereInput>
    OR?: Enumerable<Login_historyWhereInput>
    NOT?: Enumerable<Login_historyWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    loginType?: StringFilter | string
    loginToken?: StringFilter | string
    passwordToken?: IntFilter | number
    score?: IntFilter | number
    loginDate?: DateTimeFilter | Date | string
    loginIp?: StringFilter | string
  }

  export type Login_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginType?: SortOrder
    loginToken?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
    loginDate?: SortOrder
    loginIp?: SortOrder
  }

  export type Login_historyWhereUniqueInput = {
    id?: number
  }

  export type Login_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginType?: SortOrder
    loginToken?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
    loginDate?: SortOrder
    loginIp?: SortOrder
    _count?: Login_historyCountOrderByAggregateInput
    _avg?: Login_historyAvgOrderByAggregateInput
    _max?: Login_historyMaxOrderByAggregateInput
    _min?: Login_historyMinOrderByAggregateInput
    _sum?: Login_historySumOrderByAggregateInput
  }

  export type Login_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Login_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<Login_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Login_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    loginType?: StringWithAggregatesFilter | string
    loginToken?: StringWithAggregatesFilter | string
    passwordToken?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    loginDate?: DateTimeWithAggregatesFilter | Date | string
    loginIp?: StringWithAggregatesFilter | string
  }

  export type LogintempWhereInput = {
    AND?: Enumerable<LogintempWhereInput>
    OR?: Enumerable<LogintempWhereInput>
    NOT?: Enumerable<LogintempWhereInput>
    id?: IntFilter | number
    loginid?: IntFilter | number
    logincode?: StringFilter | string
    loginDate?: DateTimeFilter | Date | string
  }

  export type LogintempOrderByWithRelationInput = {
    id?: SortOrder
    loginid?: SortOrder
    logincode?: SortOrder
    loginDate?: SortOrder
  }

  export type LogintempWhereUniqueInput = {
    id?: number
  }

  export type LogintempOrderByWithAggregationInput = {
    id?: SortOrder
    loginid?: SortOrder
    logincode?: SortOrder
    loginDate?: SortOrder
    _count?: LogintempCountOrderByAggregateInput
    _avg?: LogintempAvgOrderByAggregateInput
    _max?: LogintempMaxOrderByAggregateInput
    _min?: LogintempMinOrderByAggregateInput
    _sum?: LogintempSumOrderByAggregateInput
  }

  export type LogintempScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LogintempScalarWhereWithAggregatesInput>
    OR?: Enumerable<LogintempScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LogintempScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    loginid?: IntWithAggregatesFilter | number
    logincode?: StringWithAggregatesFilter | string
    loginDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Logout_historyWhereInput = {
    AND?: Enumerable<Logout_historyWhereInput>
    OR?: Enumerable<Logout_historyWhereInput>
    NOT?: Enumerable<Logout_historyWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    logoutType?: IntFilter | number
    score?: IntFilter | number
    logoutDate?: DateTimeFilter | Date | string
    logoutIp?: StringFilter | string
  }

  export type Logout_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
    logoutDate?: SortOrder
    logoutIp?: SortOrder
  }

  export type Logout_historyWhereUniqueInput = {
    id?: number
  }

  export type Logout_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
    logoutDate?: SortOrder
    logoutIp?: SortOrder
    _count?: Logout_historyCountOrderByAggregateInput
    _avg?: Logout_historyAvgOrderByAggregateInput
    _max?: Logout_historyMaxOrderByAggregateInput
    _min?: Logout_historyMinOrderByAggregateInput
    _sum?: Logout_historySumOrderByAggregateInput
  }

  export type Logout_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Logout_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<Logout_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Logout_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    logoutType?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    logoutDate?: DateTimeWithAggregatesFilter | Date | string
    logoutIp?: StringWithAggregatesFilter | string
  }

  export type MarkWhereInput = {
    AND?: Enumerable<MarkWhereInput>
    OR?: Enumerable<MarkWhereInput>
    NOT?: Enumerable<MarkWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    useCoin?: IntFilter | number
    winCoin?: IntFilter | number
    tax?: IntFilter | number
    gameId?: IntFilter | number
    serverId?: IntFilter | number
    balanceTime?: DateTimeFilter | Date | string
    mark?: IntFilter | number
  }

  export type MarkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    balanceTime?: SortOrder
    mark?: SortOrder
  }

  export type MarkWhereUniqueInput = {
    id?: number
  }

  export type MarkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    balanceTime?: SortOrder
    mark?: SortOrder
    _count?: MarkCountOrderByAggregateInput
    _avg?: MarkAvgOrderByAggregateInput
    _max?: MarkMaxOrderByAggregateInput
    _min?: MarkMinOrderByAggregateInput
    _sum?: MarkSumOrderByAggregateInput
  }

  export type MarkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarkScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarkScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    useCoin?: IntWithAggregatesFilter | number
    winCoin?: IntWithAggregatesFilter | number
    tax?: IntWithAggregatesFilter | number
    gameId?: IntWithAggregatesFilter | number
    serverId?: IntWithAggregatesFilter | number
    balanceTime?: DateTimeWithAggregatesFilter | Date | string
    mark?: IntWithAggregatesFilter | number
  }

  export type MsgWhereInput = {
    AND?: Enumerable<MsgWhereInput>
    OR?: Enumerable<MsgWhereInput>
    NOT?: Enumerable<MsgWhereInput>
    msgId?: IntFilter | number
    userId?: IntFilter | number
    winPropId?: IntFilter | number
    winPropCount?: IntFilter | number
    winScore?: IntFilter | number
    matchlogId?: IntFilter | number
    isGetPrize?: IntFilter | number
    type?: IntFilter | number
    AddDate?: DateTimeFilter | Date | string
    sendCoinUserId?: IntFilter | number
    nickName?: StringFilter | string
  }

  export type MsgOrderByWithRelationInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    AddDate?: SortOrder
    sendCoinUserId?: SortOrder
    nickName?: SortOrder
  }

  export type MsgWhereUniqueInput = {
    msgId?: number
  }

  export type MsgOrderByWithAggregationInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    AddDate?: SortOrder
    sendCoinUserId?: SortOrder
    nickName?: SortOrder
    _count?: MsgCountOrderByAggregateInput
    _avg?: MsgAvgOrderByAggregateInput
    _max?: MsgMaxOrderByAggregateInput
    _min?: MsgMinOrderByAggregateInput
    _sum?: MsgSumOrderByAggregateInput
  }

  export type MsgScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MsgScalarWhereWithAggregatesInput>
    OR?: Enumerable<MsgScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MsgScalarWhereWithAggregatesInput>
    msgId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    winPropId?: IntWithAggregatesFilter | number
    winPropCount?: IntWithAggregatesFilter | number
    winScore?: IntWithAggregatesFilter | number
    matchlogId?: IntWithAggregatesFilter | number
    isGetPrize?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    AddDate?: DateTimeWithAggregatesFilter | Date | string
    sendCoinUserId?: IntWithAggregatesFilter | number
    nickName?: StringWithAggregatesFilter | string
  }

  export type NewuseraccountsWhereInput = {
    AND?: Enumerable<NewuseraccountsWhereInput>
    OR?: Enumerable<NewuseraccountsWhereInput>
    NOT?: Enumerable<NewuseraccountsWhereInput>
    Id?: IntFilter | number
    Account?: StringFilter | string
    Password?: StringFilter | string
    nickname?: StringFilter | string
    score?: IntFilter | number
    AddDate?: DateTimeFilter | Date | string
    LoginCount?: IntFilter | number
    p?: StringFilter | string
    diamond?: IntFilter | number
    giftTicket?: IntFilter | number
    phoneNo?: StringFilter | string
    email?: StringFilter | string
    sex?: IntFilter | number
    city?: StringFilter | string
    province?: StringFilter | string
    country?: StringFilter | string
    headimgurl?: StringFilter | string
    language?: StringFilter | string
    Robot?: IntFilter | number
    ChannelType?: StringFilter | string
    official?: IntFilter | number
    gametoken?: StringFilter | string
    qdid?: IntFilter | number
    housecard?: IntFilter | number
    totalRecharge?: DecimalFilter | Decimal | DecimalJsLike | number | string
    loginip?: StringFilter | string
    iscanlogin?: IntFilter | number
    diansha_score?: IntFilter | number
    diansha_gameids?: StringFilter | string
    is_vip?: IntFilter | number
    g4_uid?: StringFilter | string
    account_using?: IntFilter | number
    bankPwd?: StringFilter | string
    bankScore?: IntFilter | number
  }

  export type NewuseraccountsOrderByWithRelationInput = {
    Id?: SortOrder
    Account?: SortOrder
    Password?: SortOrder
    nickname?: SortOrder
    score?: SortOrder
    AddDate?: SortOrder
    LoginCount?: SortOrder
    p?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    phoneNo?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    headimgurl?: SortOrder
    language?: SortOrder
    Robot?: SortOrder
    ChannelType?: SortOrder
    official?: SortOrder
    gametoken?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    loginip?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    diansha_gameids?: SortOrder
    is_vip?: SortOrder
    g4_uid?: SortOrder
    account_using?: SortOrder
    bankPwd?: SortOrder
    bankScore?: SortOrder
  }

  export type NewuseraccountsWhereUniqueInput = {
    Id?: number
  }

  export type NewuseraccountsOrderByWithAggregationInput = {
    Id?: SortOrder
    Account?: SortOrder
    Password?: SortOrder
    nickname?: SortOrder
    score?: SortOrder
    AddDate?: SortOrder
    LoginCount?: SortOrder
    p?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    phoneNo?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    headimgurl?: SortOrder
    language?: SortOrder
    Robot?: SortOrder
    ChannelType?: SortOrder
    official?: SortOrder
    gametoken?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    loginip?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    diansha_gameids?: SortOrder
    is_vip?: SortOrder
    g4_uid?: SortOrder
    account_using?: SortOrder
    bankPwd?: SortOrder
    bankScore?: SortOrder
    _count?: NewuseraccountsCountOrderByAggregateInput
    _avg?: NewuseraccountsAvgOrderByAggregateInput
    _max?: NewuseraccountsMaxOrderByAggregateInput
    _min?: NewuseraccountsMinOrderByAggregateInput
    _sum?: NewuseraccountsSumOrderByAggregateInput
  }

  export type NewuseraccountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NewuseraccountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<NewuseraccountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NewuseraccountsScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Account?: StringWithAggregatesFilter | string
    Password?: StringWithAggregatesFilter | string
    nickname?: StringWithAggregatesFilter | string
    score?: IntWithAggregatesFilter | number
    AddDate?: DateTimeWithAggregatesFilter | Date | string
    LoginCount?: IntWithAggregatesFilter | number
    p?: StringWithAggregatesFilter | string
    diamond?: IntWithAggregatesFilter | number
    giftTicket?: IntWithAggregatesFilter | number
    phoneNo?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    sex?: IntWithAggregatesFilter | number
    city?: StringWithAggregatesFilter | string
    province?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    headimgurl?: StringWithAggregatesFilter | string
    language?: StringWithAggregatesFilter | string
    Robot?: IntWithAggregatesFilter | number
    ChannelType?: StringWithAggregatesFilter | string
    official?: IntWithAggregatesFilter | number
    gametoken?: StringWithAggregatesFilter | string
    qdid?: IntWithAggregatesFilter | number
    housecard?: IntWithAggregatesFilter | number
    totalRecharge?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    loginip?: StringWithAggregatesFilter | string
    iscanlogin?: IntWithAggregatesFilter | number
    diansha_score?: IntWithAggregatesFilter | number
    diansha_gameids?: StringWithAggregatesFilter | string
    is_vip?: IntWithAggregatesFilter | number
    g4_uid?: StringWithAggregatesFilter | string
    account_using?: IntWithAggregatesFilter | number
    bankPwd?: StringWithAggregatesFilter | string
    bankScore?: IntWithAggregatesFilter | number
  }

  export type PcdandanWhereInput = {
    AND?: Enumerable<PcdandanWhereInput>
    OR?: Enumerable<PcdandanWhereInput>
    NOT?: Enumerable<PcdandanWhereInput>
    userId?: IntFilter | number
    pcdandanId?: StringFilter | string
    Devid?: StringFilter | string
  }

  export type PcdandanOrderByWithRelationInput = {
    userId?: SortOrder
    pcdandanId?: SortOrder
    Devid?: SortOrder
  }

  export type PcdandanWhereUniqueInput = {
    userId?: number
  }

  export type PcdandanOrderByWithAggregationInput = {
    userId?: SortOrder
    pcdandanId?: SortOrder
    Devid?: SortOrder
    _count?: PcdandanCountOrderByAggregateInput
    _avg?: PcdandanAvgOrderByAggregateInput
    _max?: PcdandanMaxOrderByAggregateInput
    _min?: PcdandanMinOrderByAggregateInput
    _sum?: PcdandanSumOrderByAggregateInput
  }

  export type PcdandanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PcdandanScalarWhereWithAggregatesInput>
    OR?: Enumerable<PcdandanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PcdandanScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    pcdandanId?: StringWithAggregatesFilter | string
    Devid?: StringWithAggregatesFilter | string
  }

  export type Prop_changelogWhereInput = {
    AND?: Enumerable<Prop_changelogWhereInput>
    OR?: Enumerable<Prop_changelogWhereInput>
    NOT?: Enumerable<Prop_changelogWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    propid?: IntFilter | number
    change_before?: IntFilter | number
    change_count?: IntFilter | number
    change_after?: IntFilter | number
    insertTime?: DateTimeFilter | Date | string
    gameid?: IntFilter | number
    codeid?: IntFilter | number
  }

  export type Prop_changelogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    insertTime?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_changelogWhereUniqueInput = {
    id?: number
  }

  export type Prop_changelogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    insertTime?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
    _count?: Prop_changelogCountOrderByAggregateInput
    _avg?: Prop_changelogAvgOrderByAggregateInput
    _max?: Prop_changelogMaxOrderByAggregateInput
    _min?: Prop_changelogMinOrderByAggregateInput
    _sum?: Prop_changelogSumOrderByAggregateInput
  }

  export type Prop_changelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Prop_changelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<Prop_changelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Prop_changelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    propid?: IntWithAggregatesFilter | number
    change_before?: IntWithAggregatesFilter | number
    change_count?: IntWithAggregatesFilter | number
    change_after?: IntWithAggregatesFilter | number
    insertTime?: DateTimeWithAggregatesFilter | Date | string
    gameid?: IntWithAggregatesFilter | number
    codeid?: IntWithAggregatesFilter | number
  }

  export type Prop_itemWhereInput = {
    AND?: Enumerable<Prop_itemWhereInput>
    OR?: Enumerable<Prop_itemWhereInput>
    NOT?: Enumerable<Prop_itemWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    propid?: IntFilter | number
    propcount?: IntFilter | number
  }

  export type Prop_itemOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type Prop_itemWhereUniqueInput = {
    id?: number
  }

  export type Prop_itemOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
    _count?: Prop_itemCountOrderByAggregateInput
    _avg?: Prop_itemAvgOrderByAggregateInput
    _max?: Prop_itemMaxOrderByAggregateInput
    _min?: Prop_itemMinOrderByAggregateInput
    _sum?: Prop_itemSumOrderByAggregateInput
  }

  export type Prop_itemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Prop_itemScalarWhereWithAggregatesInput>
    OR?: Enumerable<Prop_itemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Prop_itemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    propid?: IntWithAggregatesFilter | number
    propcount?: IntWithAggregatesFilter | number
  }

  export type RechargeWhereInput = {
    AND?: Enumerable<RechargeWhereInput>
    OR?: Enumerable<RechargeWhereInput>
    NOT?: Enumerable<RechargeWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    Account?: StringFilter | string
    total_fee?: IntFilter | number
    out_trade_no?: StringFilter | string
    goodsid?: IntFilter | number
    state?: IntFilter | number
    createTime?: DateTimeFilter | Date | string
  }

  export type RechargeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    Account?: SortOrder
    total_fee?: SortOrder
    out_trade_no?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
    createTime?: SortOrder
  }

  export type RechargeWhereUniqueInput = {
    id?: number
  }

  export type RechargeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    Account?: SortOrder
    total_fee?: SortOrder
    out_trade_no?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
    createTime?: SortOrder
    _count?: RechargeCountOrderByAggregateInput
    _avg?: RechargeAvgOrderByAggregateInput
    _max?: RechargeMaxOrderByAggregateInput
    _min?: RechargeMinOrderByAggregateInput
    _sum?: RechargeSumOrderByAggregateInput
  }

  export type RechargeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RechargeScalarWhereWithAggregatesInput>
    OR?: Enumerable<RechargeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RechargeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    Account?: StringWithAggregatesFilter | string
    total_fee?: IntWithAggregatesFilter | number
    out_trade_no?: StringWithAggregatesFilter | string
    goodsid?: IntWithAggregatesFilter | number
    state?: IntWithAggregatesFilter | number
    createTime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Recharge_firstWhereInput = {
    AND?: Enumerable<Recharge_firstWhereInput>
    OR?: Enumerable<Recharge_firstWhereInput>
    NOT?: Enumerable<Recharge_firstWhereInput>
    userId?: IntFilter | number
    FIRST?: IntFilter | number
    anyFirst?: IntFilter | number
    goods1?: IntFilter | number
    goods2?: IntFilter | number
    goods3?: IntFilter | number
    goods4?: IntFilter | number
    goods5?: IntFilter | number
    daytime?: DateTimeFilter | Date | string
  }

  export type Recharge_firstOrderByWithRelationInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
    daytime?: SortOrder
  }

  export type Recharge_firstWhereUniqueInput = {
    userId?: number
  }

  export type Recharge_firstOrderByWithAggregationInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
    daytime?: SortOrder
    _count?: Recharge_firstCountOrderByAggregateInput
    _avg?: Recharge_firstAvgOrderByAggregateInput
    _max?: Recharge_firstMaxOrderByAggregateInput
    _min?: Recharge_firstMinOrderByAggregateInput
    _sum?: Recharge_firstSumOrderByAggregateInput
  }

  export type Recharge_firstScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Recharge_firstScalarWhereWithAggregatesInput>
    OR?: Enumerable<Recharge_firstScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Recharge_firstScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    FIRST?: IntWithAggregatesFilter | number
    anyFirst?: IntWithAggregatesFilter | number
    goods1?: IntWithAggregatesFilter | number
    goods2?: IntWithAggregatesFilter | number
    goods3?: IntWithAggregatesFilter | number
    goods4?: IntWithAggregatesFilter | number
    goods5?: IntWithAggregatesFilter | number
    daytime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RechargelogWhereInput = {
    AND?: Enumerable<RechargelogWhereInput>
    OR?: Enumerable<RechargelogWhereInput>
    NOT?: Enumerable<RechargelogWhereInput>
    id?: IntFilter | number
    adminid?: IntFilter | number
    userid?: IntFilter | number
    createtime?: StringFilter | string
    czfee?: IntFilter | number
    oldfee?: IntFilter | number
    newfee?: IntFilter | number
    type?: IntFilter | number
  }

  export type RechargelogOrderByWithRelationInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    createtime?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type RechargelogWhereUniqueInput = {
    id?: number
  }

  export type RechargelogOrderByWithAggregationInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    createtime?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
    _count?: RechargelogCountOrderByAggregateInput
    _avg?: RechargelogAvgOrderByAggregateInput
    _max?: RechargelogMaxOrderByAggregateInput
    _min?: RechargelogMinOrderByAggregateInput
    _sum?: RechargelogSumOrderByAggregateInput
  }

  export type RechargelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RechargelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<RechargelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RechargelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    adminid?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    createtime?: StringWithAggregatesFilter | string
    czfee?: IntWithAggregatesFilter | number
    oldfee?: IntWithAggregatesFilter | number
    newfee?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
  }

  export type ReturnscorelogWhereInput = {
    AND?: Enumerable<ReturnscorelogWhereInput>
    OR?: Enumerable<ReturnscorelogWhereInput>
    NOT?: Enumerable<ReturnscorelogWhereInput>
    id?: IntFilter | number
    msg?: StringFilter | string
    ret?: StringFilter | string
    createtime?: StringFilter | string
  }

  export type ReturnscorelogOrderByWithRelationInput = {
    id?: SortOrder
    msg?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type ReturnscorelogWhereUniqueInput = {
    id?: number
  }

  export type ReturnscorelogOrderByWithAggregationInput = {
    id?: SortOrder
    msg?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
    _count?: ReturnscorelogCountOrderByAggregateInput
    _avg?: ReturnscorelogAvgOrderByAggregateInput
    _max?: ReturnscorelogMaxOrderByAggregateInput
    _min?: ReturnscorelogMinOrderByAggregateInput
    _sum?: ReturnscorelogSumOrderByAggregateInput
  }

  export type ReturnscorelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReturnscorelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReturnscorelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReturnscorelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    msg?: StringWithAggregatesFilter | string
    ret?: StringWithAggregatesFilter | string
    createtime?: StringWithAggregatesFilter | string
  }

  export type Score_changelogWhereInput = {
    AND?: Enumerable<Score_changelogWhereInput>
    OR?: Enumerable<Score_changelogWhereInput>
    NOT?: Enumerable<Score_changelogWhereInput>
    id?: IntFilter | number
    userid?: StringFilter | string
    ret?: StringFilter | string
    createtime?: StringFilter | string
  }

  export type Score_changelogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type Score_changelogWhereUniqueInput = {
    id?: number
  }

  export type Score_changelogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
    _count?: Score_changelogCountOrderByAggregateInput
    _avg?: Score_changelogAvgOrderByAggregateInput
    _max?: Score_changelogMaxOrderByAggregateInput
    _min?: Score_changelogMinOrderByAggregateInput
    _sum?: Score_changelogSumOrderByAggregateInput
  }

  export type Score_changelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Score_changelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<Score_changelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Score_changelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: StringWithAggregatesFilter | string
    ret?: StringWithAggregatesFilter | string
    createtime?: StringWithAggregatesFilter | string
  }

  export type ScoreoutWhereInput = {
    AND?: Enumerable<ScoreoutWhereInput>
    OR?: Enumerable<ScoreoutWhereInput>
    NOT?: Enumerable<ScoreoutWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    score?: IntFilter | number
    coin?: FloatFilter | number
    tax?: IntFilter | number
    addDate?: DateTimeFilter | Date | string
    state?: StringFilter | string
    outDate?: DateTimeFilter | Date | string
    cardType?: IntFilter | number
    cardId?: IntFilter | number
    out_trade_no?: StringFilter | string
    zfb_account?: StringFilter | string
    zfb_name?: StringFilter | string
    remark?: StringFilter | string
  }

  export type ScoreoutOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    addDate?: SortOrder
    state?: SortOrder
    outDate?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
    out_trade_no?: SortOrder
    zfb_account?: SortOrder
    zfb_name?: SortOrder
    remark?: SortOrder
  }

  export type ScoreoutWhereUniqueInput = {
    id?: number
  }

  export type ScoreoutOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    addDate?: SortOrder
    state?: SortOrder
    outDate?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
    out_trade_no?: SortOrder
    zfb_account?: SortOrder
    zfb_name?: SortOrder
    remark?: SortOrder
    _count?: ScoreoutCountOrderByAggregateInput
    _avg?: ScoreoutAvgOrderByAggregateInput
    _max?: ScoreoutMaxOrderByAggregateInput
    _min?: ScoreoutMinOrderByAggregateInput
    _sum?: ScoreoutSumOrderByAggregateInput
  }

  export type ScoreoutScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScoreoutScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScoreoutScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScoreoutScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    coin?: FloatWithAggregatesFilter | number
    tax?: IntWithAggregatesFilter | number
    addDate?: DateTimeWithAggregatesFilter | Date | string
    state?: StringWithAggregatesFilter | string
    outDate?: DateTimeWithAggregatesFilter | Date | string
    cardType?: IntWithAggregatesFilter | number
    cardId?: IntWithAggregatesFilter | number
    out_trade_no?: StringWithAggregatesFilter | string
    zfb_account?: StringWithAggregatesFilter | string
    zfb_name?: StringWithAggregatesFilter | string
    remark?: StringWithAggregatesFilter | string
  }

  export type SendcoinlogWhereInput = {
    AND?: Enumerable<SendcoinlogWhereInput>
    OR?: Enumerable<SendcoinlogWhereInput>
    NOT?: Enumerable<SendcoinlogWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    getcoinuserid?: IntFilter | number
    sendcoin?: IntFilter | number
    addtime?: DateTimeFilter | Date | string
  }

  export type SendcoinlogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
    addtime?: SortOrder
  }

  export type SendcoinlogWhereUniqueInput = {
    id?: number
  }

  export type SendcoinlogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
    addtime?: SortOrder
    _count?: SendcoinlogCountOrderByAggregateInput
    _avg?: SendcoinlogAvgOrderByAggregateInput
    _max?: SendcoinlogMaxOrderByAggregateInput
    _min?: SendcoinlogMinOrderByAggregateInput
    _sum?: SendcoinlogSumOrderByAggregateInput
  }

  export type SendcoinlogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SendcoinlogScalarWhereWithAggregatesInput>
    OR?: Enumerable<SendcoinlogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SendcoinlogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    getcoinuserid?: IntWithAggregatesFilter | number
    sendcoin?: IntWithAggregatesFilter | number
    addtime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Server_logWhereInput = {
    AND?: Enumerable<Server_logWhereInput>
    OR?: Enumerable<Server_logWhereInput>
    NOT?: Enumerable<Server_logWhereInput>
    id?: IntFilter | number
    txt?: StringFilter | string
    status?: IntFilter | number
    createtime?: StringFilter | string
    updatetime?: StringFilter | string
  }

  export type Server_logOrderByWithRelationInput = {
    id?: SortOrder
    txt?: SortOrder
    status?: SortOrder
    createtime?: SortOrder
    updatetime?: SortOrder
  }

  export type Server_logWhereUniqueInput = {
    id?: number
  }

  export type Server_logOrderByWithAggregationInput = {
    id?: SortOrder
    txt?: SortOrder
    status?: SortOrder
    createtime?: SortOrder
    updatetime?: SortOrder
    _count?: Server_logCountOrderByAggregateInput
    _avg?: Server_logAvgOrderByAggregateInput
    _max?: Server_logMaxOrderByAggregateInput
    _min?: Server_logMinOrderByAggregateInput
    _sum?: Server_logSumOrderByAggregateInput
  }

  export type Server_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Server_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<Server_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Server_logScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    txt?: StringWithAggregatesFilter | string
    status?: IntWithAggregatesFilter | number
    createtime?: StringWithAggregatesFilter | string
    updatetime?: StringWithAggregatesFilter | string
  }

  export type TempadddiamondWhereInput = {
    AND?: Enumerable<TempadddiamondWhereInput>
    OR?: Enumerable<TempadddiamondWhereInput>
    NOT?: Enumerable<TempadddiamondWhereInput>
    userId?: IntFilter | number
    score?: IntFilter | number
    change_type?: IntFilter | number
  }

  export type TempadddiamondOrderByWithRelationInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempadddiamondWhereUniqueInput = {
    userId?: number
  }

  export type TempadddiamondOrderByWithAggregationInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
    _count?: TempadddiamondCountOrderByAggregateInput
    _avg?: TempadddiamondAvgOrderByAggregateInput
    _max?: TempadddiamondMaxOrderByAggregateInput
    _min?: TempadddiamondMinOrderByAggregateInput
    _sum?: TempadddiamondSumOrderByAggregateInput
  }

  export type TempadddiamondScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TempadddiamondScalarWhereWithAggregatesInput>
    OR?: Enumerable<TempadddiamondScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TempadddiamondScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    change_type?: IntWithAggregatesFilter | number
  }

  export type TempaddscoreWhereInput = {
    AND?: Enumerable<TempaddscoreWhereInput>
    OR?: Enumerable<TempaddscoreWhereInput>
    NOT?: Enumerable<TempaddscoreWhereInput>
    userId?: IntFilter | number
    score?: IntFilter | number
    change_type?: IntFilter | number
  }

  export type TempaddscoreOrderByWithRelationInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreWhereUniqueInput = {
    userId?: number
  }

  export type TempaddscoreOrderByWithAggregationInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
    _count?: TempaddscoreCountOrderByAggregateInput
    _avg?: TempaddscoreAvgOrderByAggregateInput
    _max?: TempaddscoreMaxOrderByAggregateInput
    _min?: TempaddscoreMinOrderByAggregateInput
    _sum?: TempaddscoreSumOrderByAggregateInput
  }

  export type TempaddscoreScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TempaddscoreScalarWhereWithAggregatesInput>
    OR?: Enumerable<TempaddscoreScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TempaddscoreScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    change_type?: IntWithAggregatesFilter | number
  }

  export type Ticket_changelogWhereInput = {
    AND?: Enumerable<Ticket_changelogWhereInput>
    OR?: Enumerable<Ticket_changelogWhereInput>
    NOT?: Enumerable<Ticket_changelogWhereInput>
    userid?: IntFilter | number
    score_before?: IntFilter | number
    score_change?: IntFilter | number
    score_current?: IntFilter | number
    change_type?: IntFilter | number
    change_time?: DateTimeFilter | Date | string
    isOnline?: IntFilter | number
  }

  export type Ticket_changelogOrderByWithRelationInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Ticket_changelogWhereUniqueInput = {
    userid?: number
  }

  export type Ticket_changelogOrderByWithAggregationInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
    _count?: Ticket_changelogCountOrderByAggregateInput
    _avg?: Ticket_changelogAvgOrderByAggregateInput
    _max?: Ticket_changelogMaxOrderByAggregateInput
    _min?: Ticket_changelogMinOrderByAggregateInput
    _sum?: Ticket_changelogSumOrderByAggregateInput
  }

  export type Ticket_changelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Ticket_changelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<Ticket_changelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Ticket_changelogScalarWhereWithAggregatesInput>
    userid?: IntWithAggregatesFilter | number
    score_before?: IntWithAggregatesFilter | number
    score_change?: IntWithAggregatesFilter | number
    score_current?: IntWithAggregatesFilter | number
    change_type?: IntWithAggregatesFilter | number
    change_time?: DateTimeWithAggregatesFilter | Date | string
    isOnline?: IntWithAggregatesFilter | number
  }

  export type User_adminWhereInput = {
    AND?: Enumerable<User_adminWhereInput>
    OR?: Enumerable<User_adminWhereInput>
    NOT?: Enumerable<User_adminWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    password?: StringFilter | string
    ip?: StringFilter | string
    time?: StringFilter | string
    userflag?: IntFilter | number
  }

  export type User_adminOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    userflag?: SortOrder
  }

  export type User_adminWhereUniqueInput = {
    id?: number
  }

  export type User_adminOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    userflag?: SortOrder
    _count?: User_adminCountOrderByAggregateInput
    _avg?: User_adminAvgOrderByAggregateInput
    _max?: User_adminMaxOrderByAggregateInput
    _min?: User_adminMinOrderByAggregateInput
    _sum?: User_adminSumOrderByAggregateInput
  }

  export type User_adminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<User_adminScalarWhereWithAggregatesInput>
    OR?: Enumerable<User_adminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<User_adminScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    ip?: StringWithAggregatesFilter | string
    time?: StringWithAggregatesFilter | string
    userflag?: IntWithAggregatesFilter | number
  }

  export type UserinfoWhereInput = {
    AND?: Enumerable<UserinfoWhereInput>
    OR?: Enumerable<UserinfoWhereInput>
    NOT?: Enumerable<UserinfoWhereInput>
    userId?: IntFilter | number
    Devid?: IntFilter | number
    firstexchange?: IntFilter | number
    zhifubao?: StringFilter | string
    zhifubaoName?: StringFilter | string
  }

  export type UserinfoOrderByWithRelationInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
    zhifubao?: SortOrder
    zhifubaoName?: SortOrder
  }

  export type UserinfoWhereUniqueInput = {
    userId?: number
  }

  export type UserinfoOrderByWithAggregationInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
    zhifubao?: SortOrder
    zhifubaoName?: SortOrder
    _count?: UserinfoCountOrderByAggregateInput
    _avg?: UserinfoAvgOrderByAggregateInput
    _max?: UserinfoMaxOrderByAggregateInput
    _min?: UserinfoMinOrderByAggregateInput
    _sum?: UserinfoSumOrderByAggregateInput
  }

  export type UserinfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserinfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserinfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserinfoScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    Devid?: IntWithAggregatesFilter | number
    firstexchange?: IntWithAggregatesFilter | number
    zhifubao?: StringWithAggregatesFilter | string
    zhifubaoName?: StringWithAggregatesFilter | string
  }

  export type Userinfo_impWhereInput = {
    AND?: Enumerable<Userinfo_impWhereInput>
    OR?: Enumerable<Userinfo_impWhereInput>
    NOT?: Enumerable<Userinfo_impWhereInput>
    userId?: IntFilter | number
    score?: IntFilter | number
    diamond?: IntFilter | number
    giftTicket?: IntFilter | number
  }

  export type Userinfo_impOrderByWithRelationInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type Userinfo_impWhereUniqueInput = {
    userId?: number
  }

  export type Userinfo_impOrderByWithAggregationInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    _count?: Userinfo_impCountOrderByAggregateInput
    _avg?: Userinfo_impAvgOrderByAggregateInput
    _max?: Userinfo_impMaxOrderByAggregateInput
    _min?: Userinfo_impMinOrderByAggregateInput
    _sum?: Userinfo_impSumOrderByAggregateInput
  }

  export type Userinfo_impScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Userinfo_impScalarWhereWithAggregatesInput>
    OR?: Enumerable<Userinfo_impScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Userinfo_impScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    diamond?: IntWithAggregatesFilter | number
    giftTicket?: IntWithAggregatesFilter | number
  }

  export type BankbindlistCreateInput = {
    userId: number
    account: string
    name: string
    bankType: string
  }

  export type BankbindlistUncheckedCreateInput = {
    cardId?: number
    userId: number
    account: string
    name: string
    bankType: string
  }

  export type BankbindlistUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bankType?: StringFieldUpdateOperationsInput | string
  }

  export type BankbindlistUncheckedUpdateInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bankType?: StringFieldUpdateOperationsInput | string
  }

  export type BankbindlistCreateManyInput = {
    cardId?: number
    userId: number
    account: string
    name: string
    bankType: string
  }

  export type BankbindlistUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bankType?: StringFieldUpdateOperationsInput | string
  }

  export type BankbindlistUncheckedUpdateManyInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bankType?: StringFieldUpdateOperationsInput | string
  }

  export type BanknameCreateInput = {
    bankName: string
  }

  export type BanknameUncheckedCreateInput = {
    typeId?: number
    bankName: string
  }

  export type BanknameUpdateInput = {
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type BanknameUncheckedUpdateInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type BanknameCreateManyInput = {
    typeId?: number
    bankName: string
  }

  export type BanknameUpdateManyMutationInput = {
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type BanknameUncheckedUpdateManyInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type ChatlogCreateInput = {
    userId: number
    toUserId: number
    nickname: string
    msg: string
    isSendEnd: number
    addDate: Date | string
  }

  export type ChatlogUncheckedCreateInput = {
    id?: number
    userId: number
    toUserId: number
    nickname: string
    msg: string
    isSendEnd: number
    addDate: Date | string
  }

  export type ChatlogUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    msg?: StringFieldUpdateOperationsInput | string
    isSendEnd?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    msg?: StringFieldUpdateOperationsInput | string
    isSendEnd?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatlogCreateManyInput = {
    id?: number
    userId: number
    toUserId: number
    nickname: string
    msg: string
    isSendEnd: number
    addDate: Date | string
  }

  export type ChatlogUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    msg?: StringFieldUpdateOperationsInput | string
    isSendEnd?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    msg?: StringFieldUpdateOperationsInput | string
    isSendEnd?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Diamond_changelogCreateInput = {
    userid: number
    diamond_before: number
    diamond_change: number
    diamond_current: number
    change_type: number
    change_time: Date | string
    isOnline: number
  }

  export type Diamond_changelogUncheckedCreateInput = {
    id?: number
    userid: number
    diamond_before: number
    diamond_change: number
    diamond_current: number
    change_type: number
    change_time: Date | string
    isOnline: number
  }

  export type Diamond_changelogUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    diamond_before?: IntFieldUpdateOperationsInput | number
    diamond_change?: IntFieldUpdateOperationsInput | number
    diamond_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Diamond_changelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    diamond_before?: IntFieldUpdateOperationsInput | number
    diamond_change?: IntFieldUpdateOperationsInput | number
    diamond_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Diamond_changelogCreateManyInput = {
    id?: number
    userid: number
    diamond_before: number
    diamond_change: number
    diamond_current: number
    change_type: number
    change_time: Date | string
    isOnline: number
  }

  export type Diamond_changelogUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    diamond_before?: IntFieldUpdateOperationsInput | number
    diamond_change?: IntFieldUpdateOperationsInput | number
    diamond_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Diamond_changelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    diamond_before?: IntFieldUpdateOperationsInput | number
    diamond_change?: IntFieldUpdateOperationsInput | number
    diamond_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type DongshanzaiqiCreateInput = {
    userId: number
    dcount: number
    dtime?: Date | string
  }

  export type DongshanzaiqiUncheckedCreateInput = {
    userId: number
    dcount: number
    dtime?: Date | string
  }

  export type DongshanzaiqiUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    dcount?: IntFieldUpdateOperationsInput | number
    dtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DongshanzaiqiUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    dcount?: IntFieldUpdateOperationsInput | number
    dtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DongshanzaiqiCreateManyInput = {
    userId: number
    dcount: number
    dtime?: Date | string
  }

  export type DongshanzaiqiUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    dcount?: IntFieldUpdateOperationsInput | number
    dtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DongshanzaiqiUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    dcount?: IntFieldUpdateOperationsInput | number
    dtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Game_login_historyCreateInput = {
    userId: number
    gameId: number
    serverId: string
    encoin: number
    login_score: number
    logout_score: number
    loginDate?: Date | string
    logoutDate: Date | string
  }

  export type Game_login_historyUncheckedCreateInput = {
    id?: number
    userId: number
    gameId: number
    serverId: string
    encoin: number
    login_score: number
    logout_score: number
    loginDate?: Date | string
    logoutDate: Date | string
  }

  export type Game_login_historyUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: StringFieldUpdateOperationsInput | string
    encoin?: IntFieldUpdateOperationsInput | number
    login_score?: IntFieldUpdateOperationsInput | number
    logout_score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Game_login_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: StringFieldUpdateOperationsInput | string
    encoin?: IntFieldUpdateOperationsInput | number
    login_score?: IntFieldUpdateOperationsInput | number
    logout_score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Game_login_historyCreateManyInput = {
    id?: number
    userId: number
    gameId: number
    serverId: string
    encoin: number
    login_score: number
    logout_score: number
    loginDate?: Date | string
    logoutDate: Date | string
  }

  export type Game_login_historyUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: StringFieldUpdateOperationsInput | string
    encoin?: IntFieldUpdateOperationsInput | number
    login_score?: IntFieldUpdateOperationsInput | number
    logout_score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Game_login_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: StringFieldUpdateOperationsInput | string
    encoin?: IntFieldUpdateOperationsInput | number
    login_score?: IntFieldUpdateOperationsInput | number
    logout_score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Game_onlinenumCreateInput = {
    gid: number
    gport: string
    num: number
    createtime: string
  }

  export type Game_onlinenumUncheckedCreateInput = {
    id?: number
    gid: number
    gport: string
    num: number
    createtime: string
  }

  export type Game_onlinenumUpdateInput = {
    gid?: IntFieldUpdateOperationsInput | number
    gport?: StringFieldUpdateOperationsInput | string
    num?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Game_onlinenumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gid?: IntFieldUpdateOperationsInput | number
    gport?: StringFieldUpdateOperationsInput | string
    num?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Game_onlinenumCreateManyInput = {
    id?: number
    gid: number
    gport: string
    num: number
    createtime: string
  }

  export type Game_onlinenumUpdateManyMutationInput = {
    gid?: IntFieldUpdateOperationsInput | number
    gport?: StringFieldUpdateOperationsInput | string
    num?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Game_onlinenumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gid?: IntFieldUpdateOperationsInput | number
    gport?: StringFieldUpdateOperationsInput | string
    num?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type LineoutCreateInput = {
    userId: number
  }

  export type LineoutUncheckedCreateInput = {
    userId: number
  }

  export type LineoutUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type LineoutUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type LineoutCreateManyInput = {
    userId: number
  }

  export type LineoutUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type LineoutUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Login_historyCreateInput = {
    userId: number
    loginType: string
    loginToken: string
    passwordToken: number
    score: number
    loginDate?: Date | string
    loginIp: string
  }

  export type Login_historyUncheckedCreateInput = {
    id?: number
    userId: number
    loginType: string
    loginToken: string
    passwordToken: number
    score: number
    loginDate?: Date | string
    loginIp: string
  }

  export type Login_historyUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    loginType?: StringFieldUpdateOperationsInput | string
    loginToken?: StringFieldUpdateOperationsInput | string
    passwordToken?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginIp?: StringFieldUpdateOperationsInput | string
  }

  export type Login_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    loginType?: StringFieldUpdateOperationsInput | string
    loginToken?: StringFieldUpdateOperationsInput | string
    passwordToken?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginIp?: StringFieldUpdateOperationsInput | string
  }

  export type Login_historyCreateManyInput = {
    id?: number
    userId: number
    loginType: string
    loginToken: string
    passwordToken: number
    score: number
    loginDate?: Date | string
    loginIp: string
  }

  export type Login_historyUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    loginType?: StringFieldUpdateOperationsInput | string
    loginToken?: StringFieldUpdateOperationsInput | string
    passwordToken?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginIp?: StringFieldUpdateOperationsInput | string
  }

  export type Login_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    loginType?: StringFieldUpdateOperationsInput | string
    loginToken?: StringFieldUpdateOperationsInput | string
    passwordToken?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginIp?: StringFieldUpdateOperationsInput | string
  }

  export type LogintempCreateInput = {
    loginid: number
    logincode: string
    loginDate?: Date | string
  }

  export type LogintempUncheckedCreateInput = {
    id?: number
    loginid: number
    logincode: string
    loginDate?: Date | string
  }

  export type LogintempUpdateInput = {
    loginid?: IntFieldUpdateOperationsInput | number
    logincode?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogintempUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginid?: IntFieldUpdateOperationsInput | number
    logincode?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogintempCreateManyInput = {
    id?: number
    loginid: number
    logincode: string
    loginDate?: Date | string
  }

  export type LogintempUpdateManyMutationInput = {
    loginid?: IntFieldUpdateOperationsInput | number
    logincode?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogintempUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginid?: IntFieldUpdateOperationsInput | number
    logincode?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Logout_historyCreateInput = {
    userId: number
    logoutType: number
    score: number
    logoutDate?: Date | string
    logoutIp: string
  }

  export type Logout_historyUncheckedCreateInput = {
    id?: number
    userId: number
    logoutType: number
    score: number
    logoutDate?: Date | string
    logoutIp: string
  }

  export type Logout_historyUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    logoutType?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutIp?: StringFieldUpdateOperationsInput | string
  }

  export type Logout_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    logoutType?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutIp?: StringFieldUpdateOperationsInput | string
  }

  export type Logout_historyCreateManyInput = {
    id?: number
    userId: number
    logoutType: number
    score: number
    logoutDate?: Date | string
    logoutIp: string
  }

  export type Logout_historyUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    logoutType?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutIp?: StringFieldUpdateOperationsInput | string
  }

  export type Logout_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    logoutType?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    logoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutIp?: StringFieldUpdateOperationsInput | string
  }

  export type MarkCreateInput = {
    userId: number
    useCoin: number
    winCoin: number
    tax: number
    gameId: number
    serverId: number
    balanceTime?: Date | string
    mark: number
  }

  export type MarkUncheckedCreateInput = {
    id?: number
    userId: number
    useCoin: number
    winCoin: number
    tax: number
    gameId: number
    serverId: number
    balanceTime?: Date | string
    mark: number
  }

  export type MarkUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    useCoin?: IntFieldUpdateOperationsInput | number
    winCoin?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: IntFieldUpdateOperationsInput | number
    balanceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: IntFieldUpdateOperationsInput | number
  }

  export type MarkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useCoin?: IntFieldUpdateOperationsInput | number
    winCoin?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: IntFieldUpdateOperationsInput | number
    balanceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: IntFieldUpdateOperationsInput | number
  }

  export type MarkCreateManyInput = {
    id?: number
    userId: number
    useCoin: number
    winCoin: number
    tax: number
    gameId: number
    serverId: number
    balanceTime?: Date | string
    mark: number
  }

  export type MarkUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    useCoin?: IntFieldUpdateOperationsInput | number
    winCoin?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: IntFieldUpdateOperationsInput | number
    balanceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: IntFieldUpdateOperationsInput | number
  }

  export type MarkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useCoin?: IntFieldUpdateOperationsInput | number
    winCoin?: IntFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    serverId?: IntFieldUpdateOperationsInput | number
    balanceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: IntFieldUpdateOperationsInput | number
  }

  export type MsgCreateInput = {
    userId: number
    winPropId: number
    winPropCount: number
    winScore: number
    matchlogId: number
    isGetPrize: number
    type: number
    AddDate?: Date | string
    sendCoinUserId: number
    nickName: string
  }

  export type MsgUncheckedCreateInput = {
    msgId?: number
    userId: number
    winPropId: number
    winPropCount: number
    winScore: number
    matchlogId: number
    isGetPrize: number
    type: number
    AddDate?: Date | string
    sendCoinUserId: number
    nickName: string
  }

  export type MsgUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    winPropId?: IntFieldUpdateOperationsInput | number
    winPropCount?: IntFieldUpdateOperationsInput | number
    winScore?: IntFieldUpdateOperationsInput | number
    matchlogId?: IntFieldUpdateOperationsInput | number
    isGetPrize?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendCoinUserId?: IntFieldUpdateOperationsInput | number
    nickName?: StringFieldUpdateOperationsInput | string
  }

  export type MsgUncheckedUpdateInput = {
    msgId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    winPropId?: IntFieldUpdateOperationsInput | number
    winPropCount?: IntFieldUpdateOperationsInput | number
    winScore?: IntFieldUpdateOperationsInput | number
    matchlogId?: IntFieldUpdateOperationsInput | number
    isGetPrize?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendCoinUserId?: IntFieldUpdateOperationsInput | number
    nickName?: StringFieldUpdateOperationsInput | string
  }

  export type MsgCreateManyInput = {
    msgId?: number
    userId: number
    winPropId: number
    winPropCount: number
    winScore: number
    matchlogId: number
    isGetPrize: number
    type: number
    AddDate?: Date | string
    sendCoinUserId: number
    nickName: string
  }

  export type MsgUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    winPropId?: IntFieldUpdateOperationsInput | number
    winPropCount?: IntFieldUpdateOperationsInput | number
    winScore?: IntFieldUpdateOperationsInput | number
    matchlogId?: IntFieldUpdateOperationsInput | number
    isGetPrize?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendCoinUserId?: IntFieldUpdateOperationsInput | number
    nickName?: StringFieldUpdateOperationsInput | string
  }

  export type MsgUncheckedUpdateManyInput = {
    msgId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    winPropId?: IntFieldUpdateOperationsInput | number
    winPropCount?: IntFieldUpdateOperationsInput | number
    winScore?: IntFieldUpdateOperationsInput | number
    matchlogId?: IntFieldUpdateOperationsInput | number
    isGetPrize?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendCoinUserId?: IntFieldUpdateOperationsInput | number
    nickName?: StringFieldUpdateOperationsInput | string
  }

  export type NewuseraccountsCreateInput = {
    Account: string
    Password: string
    nickname: string
    score: number
    AddDate?: Date | string
    LoginCount: number
    p: string
    diamond: number
    giftTicket: number
    phoneNo: string
    email: string
    sex: number
    city: string
    province: string
    country: string
    headimgurl: string
    language: string
    Robot: number
    ChannelType: string
    official: number
    gametoken: string
    qdid: number
    housecard: number
    totalRecharge: Decimal | DecimalJsLike | number | string
    loginip: string
    iscanlogin: number
    diansha_score: number
    diansha_gameids: string
    is_vip: number
    g4_uid: string
    account_using: number
    bankPwd: string
    bankScore: number
  }

  export type NewuseraccountsUncheckedCreateInput = {
    Id?: number
    Account: string
    Password: string
    nickname: string
    score: number
    AddDate?: Date | string
    LoginCount: number
    p: string
    diamond: number
    giftTicket: number
    phoneNo: string
    email: string
    sex: number
    city: string
    province: string
    country: string
    headimgurl: string
    language: string
    Robot: number
    ChannelType: string
    official: number
    gametoken: string
    qdid: number
    housecard: number
    totalRecharge: Decimal | DecimalJsLike | number | string
    loginip: string
    iscanlogin: number
    diansha_score: number
    diansha_gameids: string
    is_vip: number
    g4_uid: string
    account_using: number
    bankPwd: string
    bankScore: number
  }

  export type NewuseraccountsUpdateInput = {
    Account?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LoginCount?: IntFieldUpdateOperationsInput | number
    p?: StringFieldUpdateOperationsInput | string
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
    phoneNo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    headimgurl?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    Robot?: IntFieldUpdateOperationsInput | number
    ChannelType?: StringFieldUpdateOperationsInput | string
    official?: IntFieldUpdateOperationsInput | number
    gametoken?: StringFieldUpdateOperationsInput | string
    qdid?: IntFieldUpdateOperationsInput | number
    housecard?: IntFieldUpdateOperationsInput | number
    totalRecharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loginip?: StringFieldUpdateOperationsInput | string
    iscanlogin?: IntFieldUpdateOperationsInput | number
    diansha_score?: IntFieldUpdateOperationsInput | number
    diansha_gameids?: StringFieldUpdateOperationsInput | string
    is_vip?: IntFieldUpdateOperationsInput | number
    g4_uid?: StringFieldUpdateOperationsInput | string
    account_using?: IntFieldUpdateOperationsInput | number
    bankPwd?: StringFieldUpdateOperationsInput | string
    bankScore?: IntFieldUpdateOperationsInput | number
  }

  export type NewuseraccountsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LoginCount?: IntFieldUpdateOperationsInput | number
    p?: StringFieldUpdateOperationsInput | string
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
    phoneNo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    headimgurl?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    Robot?: IntFieldUpdateOperationsInput | number
    ChannelType?: StringFieldUpdateOperationsInput | string
    official?: IntFieldUpdateOperationsInput | number
    gametoken?: StringFieldUpdateOperationsInput | string
    qdid?: IntFieldUpdateOperationsInput | number
    housecard?: IntFieldUpdateOperationsInput | number
    totalRecharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loginip?: StringFieldUpdateOperationsInput | string
    iscanlogin?: IntFieldUpdateOperationsInput | number
    diansha_score?: IntFieldUpdateOperationsInput | number
    diansha_gameids?: StringFieldUpdateOperationsInput | string
    is_vip?: IntFieldUpdateOperationsInput | number
    g4_uid?: StringFieldUpdateOperationsInput | string
    account_using?: IntFieldUpdateOperationsInput | number
    bankPwd?: StringFieldUpdateOperationsInput | string
    bankScore?: IntFieldUpdateOperationsInput | number
  }

  export type NewuseraccountsCreateManyInput = {
    Id?: number
    Account: string
    Password: string
    nickname: string
    score: number
    AddDate?: Date | string
    LoginCount: number
    p: string
    diamond: number
    giftTicket: number
    phoneNo: string
    email: string
    sex: number
    city: string
    province: string
    country: string
    headimgurl: string
    language: string
    Robot: number
    ChannelType: string
    official: number
    gametoken: string
    qdid: number
    housecard: number
    totalRecharge: Decimal | DecimalJsLike | number | string
    loginip: string
    iscanlogin: number
    diansha_score: number
    diansha_gameids: string
    is_vip: number
    g4_uid: string
    account_using: number
    bankPwd: string
    bankScore: number
  }

  export type NewuseraccountsUpdateManyMutationInput = {
    Account?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LoginCount?: IntFieldUpdateOperationsInput | number
    p?: StringFieldUpdateOperationsInput | string
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
    phoneNo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    headimgurl?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    Robot?: IntFieldUpdateOperationsInput | number
    ChannelType?: StringFieldUpdateOperationsInput | string
    official?: IntFieldUpdateOperationsInput | number
    gametoken?: StringFieldUpdateOperationsInput | string
    qdid?: IntFieldUpdateOperationsInput | number
    housecard?: IntFieldUpdateOperationsInput | number
    totalRecharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loginip?: StringFieldUpdateOperationsInput | string
    iscanlogin?: IntFieldUpdateOperationsInput | number
    diansha_score?: IntFieldUpdateOperationsInput | number
    diansha_gameids?: StringFieldUpdateOperationsInput | string
    is_vip?: IntFieldUpdateOperationsInput | number
    g4_uid?: StringFieldUpdateOperationsInput | string
    account_using?: IntFieldUpdateOperationsInput | number
    bankPwd?: StringFieldUpdateOperationsInput | string
    bankScore?: IntFieldUpdateOperationsInput | number
  }

  export type NewuseraccountsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    AddDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LoginCount?: IntFieldUpdateOperationsInput | number
    p?: StringFieldUpdateOperationsInput | string
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
    phoneNo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    headimgurl?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    Robot?: IntFieldUpdateOperationsInput | number
    ChannelType?: StringFieldUpdateOperationsInput | string
    official?: IntFieldUpdateOperationsInput | number
    gametoken?: StringFieldUpdateOperationsInput | string
    qdid?: IntFieldUpdateOperationsInput | number
    housecard?: IntFieldUpdateOperationsInput | number
    totalRecharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loginip?: StringFieldUpdateOperationsInput | string
    iscanlogin?: IntFieldUpdateOperationsInput | number
    diansha_score?: IntFieldUpdateOperationsInput | number
    diansha_gameids?: StringFieldUpdateOperationsInput | string
    is_vip?: IntFieldUpdateOperationsInput | number
    g4_uid?: StringFieldUpdateOperationsInput | string
    account_using?: IntFieldUpdateOperationsInput | number
    bankPwd?: StringFieldUpdateOperationsInput | string
    bankScore?: IntFieldUpdateOperationsInput | number
  }

  export type PcdandanCreateInput = {
    userId: number
    pcdandanId: string
    Devid: string
  }

  export type PcdandanUncheckedCreateInput = {
    userId: number
    pcdandanId: string
    Devid: string
  }

  export type PcdandanUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    pcdandanId?: StringFieldUpdateOperationsInput | string
    Devid?: StringFieldUpdateOperationsInput | string
  }

  export type PcdandanUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    pcdandanId?: StringFieldUpdateOperationsInput | string
    Devid?: StringFieldUpdateOperationsInput | string
  }

  export type PcdandanCreateManyInput = {
    userId: number
    pcdandanId: string
    Devid: string
  }

  export type PcdandanUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    pcdandanId?: StringFieldUpdateOperationsInput | string
    Devid?: StringFieldUpdateOperationsInput | string
  }

  export type PcdandanUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    pcdandanId?: StringFieldUpdateOperationsInput | string
    Devid?: StringFieldUpdateOperationsInput | string
  }

  export type Prop_changelogCreateInput = {
    userid: number
    propid: number
    change_before: number
    change_count: number
    change_after: number
    insertTime?: Date | string
    gameid: number
    codeid: number
  }

  export type Prop_changelogUncheckedCreateInput = {
    id?: number
    userid: number
    propid: number
    change_before: number
    change_count: number
    change_after: number
    insertTime?: Date | string
    gameid: number
    codeid: number
  }

  export type Prop_changelogUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    change_before?: IntFieldUpdateOperationsInput | number
    change_count?: IntFieldUpdateOperationsInput | number
    change_after?: IntFieldUpdateOperationsInput | number
    insertTime?: DateTimeFieldUpdateOperationsInput | Date | string
    gameid?: IntFieldUpdateOperationsInput | number
    codeid?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_changelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    change_before?: IntFieldUpdateOperationsInput | number
    change_count?: IntFieldUpdateOperationsInput | number
    change_after?: IntFieldUpdateOperationsInput | number
    insertTime?: DateTimeFieldUpdateOperationsInput | Date | string
    gameid?: IntFieldUpdateOperationsInput | number
    codeid?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_changelogCreateManyInput = {
    id?: number
    userid: number
    propid: number
    change_before: number
    change_count: number
    change_after: number
    insertTime?: Date | string
    gameid: number
    codeid: number
  }

  export type Prop_changelogUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    change_before?: IntFieldUpdateOperationsInput | number
    change_count?: IntFieldUpdateOperationsInput | number
    change_after?: IntFieldUpdateOperationsInput | number
    insertTime?: DateTimeFieldUpdateOperationsInput | Date | string
    gameid?: IntFieldUpdateOperationsInput | number
    codeid?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_changelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    change_before?: IntFieldUpdateOperationsInput | number
    change_count?: IntFieldUpdateOperationsInput | number
    change_after?: IntFieldUpdateOperationsInput | number
    insertTime?: DateTimeFieldUpdateOperationsInput | Date | string
    gameid?: IntFieldUpdateOperationsInput | number
    codeid?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_itemCreateInput = {
    userid: number
    propid: number
    propcount: number
  }

  export type Prop_itemUncheckedCreateInput = {
    id?: number
    userid: number
    propid: number
    propcount: number
  }

  export type Prop_itemUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    propcount?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    propcount?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_itemCreateManyInput = {
    id?: number
    userid: number
    propid: number
    propcount: number
  }

  export type Prop_itemUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    propcount?: IntFieldUpdateOperationsInput | number
  }

  export type Prop_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    propid?: IntFieldUpdateOperationsInput | number
    propcount?: IntFieldUpdateOperationsInput | number
  }

  export type RechargeCreateInput = {
    userId: number
    Account: string
    total_fee: number
    out_trade_no: string
    goodsid: number
    state: number
    createTime?: Date | string
  }

  export type RechargeUncheckedCreateInput = {
    id?: number
    userId: number
    Account: string
    total_fee: number
    out_trade_no: string
    goodsid: number
    state: number
    createTime?: Date | string
  }

  export type RechargeUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    total_fee?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    goodsid?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    total_fee?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    goodsid?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeCreateManyInput = {
    id?: number
    userId: number
    Account: string
    total_fee: number
    out_trade_no: string
    goodsid: number
    state: number
    createTime?: Date | string
  }

  export type RechargeUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    total_fee?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    goodsid?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    Account?: StringFieldUpdateOperationsInput | string
    total_fee?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    goodsid?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Recharge_firstCreateInput = {
    userId: number
    FIRST: number
    anyFirst: number
    goods1: number
    goods2: number
    goods3: number
    goods4: number
    goods5: number
    daytime?: Date | string
  }

  export type Recharge_firstUncheckedCreateInput = {
    userId: number
    FIRST: number
    anyFirst: number
    goods1: number
    goods2: number
    goods3: number
    goods4: number
    goods5: number
    daytime?: Date | string
  }

  export type Recharge_firstUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    FIRST?: IntFieldUpdateOperationsInput | number
    anyFirst?: IntFieldUpdateOperationsInput | number
    goods1?: IntFieldUpdateOperationsInput | number
    goods2?: IntFieldUpdateOperationsInput | number
    goods3?: IntFieldUpdateOperationsInput | number
    goods4?: IntFieldUpdateOperationsInput | number
    goods5?: IntFieldUpdateOperationsInput | number
    daytime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Recharge_firstUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    FIRST?: IntFieldUpdateOperationsInput | number
    anyFirst?: IntFieldUpdateOperationsInput | number
    goods1?: IntFieldUpdateOperationsInput | number
    goods2?: IntFieldUpdateOperationsInput | number
    goods3?: IntFieldUpdateOperationsInput | number
    goods4?: IntFieldUpdateOperationsInput | number
    goods5?: IntFieldUpdateOperationsInput | number
    daytime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Recharge_firstCreateManyInput = {
    userId: number
    FIRST: number
    anyFirst: number
    goods1: number
    goods2: number
    goods3: number
    goods4: number
    goods5: number
    daytime?: Date | string
  }

  export type Recharge_firstUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    FIRST?: IntFieldUpdateOperationsInput | number
    anyFirst?: IntFieldUpdateOperationsInput | number
    goods1?: IntFieldUpdateOperationsInput | number
    goods2?: IntFieldUpdateOperationsInput | number
    goods3?: IntFieldUpdateOperationsInput | number
    goods4?: IntFieldUpdateOperationsInput | number
    goods5?: IntFieldUpdateOperationsInput | number
    daytime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Recharge_firstUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    FIRST?: IntFieldUpdateOperationsInput | number
    anyFirst?: IntFieldUpdateOperationsInput | number
    goods1?: IntFieldUpdateOperationsInput | number
    goods2?: IntFieldUpdateOperationsInput | number
    goods3?: IntFieldUpdateOperationsInput | number
    goods4?: IntFieldUpdateOperationsInput | number
    goods5?: IntFieldUpdateOperationsInput | number
    daytime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargelogCreateInput = {
    adminid: number
    userid: number
    createtime: string
    czfee: number
    oldfee: number
    newfee: number
    type: number
  }

  export type RechargelogUncheckedCreateInput = {
    id?: number
    adminid: number
    userid: number
    createtime: string
    czfee: number
    oldfee: number
    newfee: number
    type: number
  }

  export type RechargelogUpdateInput = {
    adminid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    czfee?: IntFieldUpdateOperationsInput | number
    oldfee?: IntFieldUpdateOperationsInput | number
    newfee?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type RechargelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    czfee?: IntFieldUpdateOperationsInput | number
    oldfee?: IntFieldUpdateOperationsInput | number
    newfee?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type RechargelogCreateManyInput = {
    id?: number
    adminid: number
    userid: number
    createtime: string
    czfee: number
    oldfee: number
    newfee: number
    type: number
  }

  export type RechargelogUpdateManyMutationInput = {
    adminid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    czfee?: IntFieldUpdateOperationsInput | number
    oldfee?: IntFieldUpdateOperationsInput | number
    newfee?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type RechargelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    czfee?: IntFieldUpdateOperationsInput | number
    oldfee?: IntFieldUpdateOperationsInput | number
    newfee?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type ReturnscorelogCreateInput = {
    msg: string
    ret: string
    createtime: string
  }

  export type ReturnscorelogUncheckedCreateInput = {
    id?: number
    msg: string
    ret: string
    createtime: string
  }

  export type ReturnscorelogUpdateInput = {
    msg?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type ReturnscorelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type ReturnscorelogCreateManyInput = {
    id?: number
    msg: string
    ret: string
    createtime: string
  }

  export type ReturnscorelogUpdateManyMutationInput = {
    msg?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type ReturnscorelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Score_changelogCreateInput = {
    userid: string
    ret: string
    createtime: string
  }

  export type Score_changelogUncheckedCreateInput = {
    id?: number
    userid: string
    ret: string
    createtime: string
  }

  export type Score_changelogUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Score_changelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Score_changelogCreateManyInput = {
    id?: number
    userid: string
    ret: string
    createtime: string
  }

  export type Score_changelogUpdateManyMutationInput = {
    userid?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type Score_changelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    ret?: StringFieldUpdateOperationsInput | string
    createtime?: StringFieldUpdateOperationsInput | string
  }

  export type ScoreoutCreateInput = {
    userId: number
    score: number
    coin: number
    tax: number
    addDate?: Date | string
    state: string
    outDate: Date | string
    cardType: number
    cardId: number
    out_trade_no: string
    zfb_account: string
    zfb_name: string
    remark: string
  }

  export type ScoreoutUncheckedCreateInput = {
    id?: number
    userId: number
    score: number
    coin: number
    tax: number
    addDate?: Date | string
    state: string
    outDate: Date | string
    cardType: number
    cardId: number
    out_trade_no: string
    zfb_account: string
    zfb_name: string
    remark: string
  }

  export type ScoreoutUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    coin?: FloatFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    outDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cardType?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    zfb_account?: StringFieldUpdateOperationsInput | string
    zfb_name?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type ScoreoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    coin?: FloatFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    outDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cardType?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    zfb_account?: StringFieldUpdateOperationsInput | string
    zfb_name?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type ScoreoutCreateManyInput = {
    id?: number
    userId: number
    score: number
    coin: number
    tax: number
    addDate?: Date | string
    state: string
    outDate: Date | string
    cardType: number
    cardId: number
    out_trade_no: string
    zfb_account: string
    zfb_name: string
    remark: string
  }

  export type ScoreoutUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    coin?: FloatFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    outDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cardType?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    zfb_account?: StringFieldUpdateOperationsInput | string
    zfb_name?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type ScoreoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    coin?: FloatFieldUpdateOperationsInput | number
    tax?: IntFieldUpdateOperationsInput | number
    addDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    outDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cardType?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    out_trade_no?: StringFieldUpdateOperationsInput | string
    zfb_account?: StringFieldUpdateOperationsInput | string
    zfb_name?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type SendcoinlogCreateInput = {
    userid: number
    getcoinuserid: number
    sendcoin: number
    addtime?: Date | string
  }

  export type SendcoinlogUncheckedCreateInput = {
    id?: number
    userid: number
    getcoinuserid: number
    sendcoin: number
    addtime?: Date | string
  }

  export type SendcoinlogUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    getcoinuserid?: IntFieldUpdateOperationsInput | number
    sendcoin?: IntFieldUpdateOperationsInput | number
    addtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SendcoinlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    getcoinuserid?: IntFieldUpdateOperationsInput | number
    sendcoin?: IntFieldUpdateOperationsInput | number
    addtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SendcoinlogCreateManyInput = {
    id?: number
    userid: number
    getcoinuserid: number
    sendcoin: number
    addtime?: Date | string
  }

  export type SendcoinlogUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    getcoinuserid?: IntFieldUpdateOperationsInput | number
    sendcoin?: IntFieldUpdateOperationsInput | number
    addtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SendcoinlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    getcoinuserid?: IntFieldUpdateOperationsInput | number
    sendcoin?: IntFieldUpdateOperationsInput | number
    addtime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Server_logCreateInput = {
    txt: string
    status: number
    createtime: string
    updatetime: string
  }

  export type Server_logUncheckedCreateInput = {
    id?: number
    txt: string
    status: number
    createtime: string
    updatetime: string
  }

  export type Server_logUpdateInput = {
    txt?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    updatetime?: StringFieldUpdateOperationsInput | string
  }

  export type Server_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    txt?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    updatetime?: StringFieldUpdateOperationsInput | string
  }

  export type Server_logCreateManyInput = {
    id?: number
    txt: string
    status: number
    createtime: string
    updatetime: string
  }

  export type Server_logUpdateManyMutationInput = {
    txt?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    updatetime?: StringFieldUpdateOperationsInput | string
  }

  export type Server_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    txt?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createtime?: StringFieldUpdateOperationsInput | string
    updatetime?: StringFieldUpdateOperationsInput | string
  }

  export type TempadddiamondCreateInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempadddiamondUncheckedCreateInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempadddiamondUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempadddiamondUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempadddiamondCreateManyInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempadddiamondUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempadddiamondUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempaddscoreCreateInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempaddscoreUncheckedCreateInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempaddscoreUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempaddscoreUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempaddscoreCreateManyInput = {
    userId: number
    score: number
    change_type: number
  }

  export type TempaddscoreUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type TempaddscoreUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
  }

  export type Ticket_changelogCreateInput = {
    userid: number
    score_before: number
    score_change: number
    score_current: number
    change_type: number
    change_time?: Date | string
    isOnline: number
  }

  export type Ticket_changelogUncheckedCreateInput = {
    userid: number
    score_before: number
    score_change: number
    score_current: number
    change_type: number
    change_time?: Date | string
    isOnline: number
  }

  export type Ticket_changelogUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    score_before?: IntFieldUpdateOperationsInput | number
    score_change?: IntFieldUpdateOperationsInput | number
    score_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Ticket_changelogUncheckedUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    score_before?: IntFieldUpdateOperationsInput | number
    score_change?: IntFieldUpdateOperationsInput | number
    score_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Ticket_changelogCreateManyInput = {
    userid: number
    score_before: number
    score_change: number
    score_current: number
    change_type: number
    change_time?: Date | string
    isOnline: number
  }

  export type Ticket_changelogUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    score_before?: IntFieldUpdateOperationsInput | number
    score_change?: IntFieldUpdateOperationsInput | number
    score_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type Ticket_changelogUncheckedUpdateManyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    score_before?: IntFieldUpdateOperationsInput | number
    score_change?: IntFieldUpdateOperationsInput | number
    score_current?: IntFieldUpdateOperationsInput | number
    change_type?: IntFieldUpdateOperationsInput | number
    change_time?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: IntFieldUpdateOperationsInput | number
  }

  export type User_adminCreateInput = {
    user: string
    password: string
    ip: string
    time: string
    userflag: number
  }

  export type User_adminUncheckedCreateInput = {
    id?: number
    user: string
    password: string
    ip: string
    time: string
    userflag: number
  }

  export type User_adminUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    userflag?: IntFieldUpdateOperationsInput | number
  }

  export type User_adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    userflag?: IntFieldUpdateOperationsInput | number
  }

  export type User_adminCreateManyInput = {
    id?: number
    user: string
    password: string
    ip: string
    time: string
    userflag: number
  }

  export type User_adminUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    userflag?: IntFieldUpdateOperationsInput | number
  }

  export type User_adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    userflag?: IntFieldUpdateOperationsInput | number
  }

  export type UserinfoCreateInput = {
    userId: number
    Devid: number
    firstexchange: number
    zhifubao: string
    zhifubaoName: string
  }

  export type UserinfoUncheckedCreateInput = {
    userId: number
    Devid: number
    firstexchange: number
    zhifubao: string
    zhifubaoName: string
  }

  export type UserinfoUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Devid?: IntFieldUpdateOperationsInput | number
    firstexchange?: IntFieldUpdateOperationsInput | number
    zhifubao?: StringFieldUpdateOperationsInput | string
    zhifubaoName?: StringFieldUpdateOperationsInput | string
  }

  export type UserinfoUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Devid?: IntFieldUpdateOperationsInput | number
    firstexchange?: IntFieldUpdateOperationsInput | number
    zhifubao?: StringFieldUpdateOperationsInput | string
    zhifubaoName?: StringFieldUpdateOperationsInput | string
  }

  export type UserinfoCreateManyInput = {
    userId: number
    Devid: number
    firstexchange: number
    zhifubao: string
    zhifubaoName: string
  }

  export type UserinfoUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Devid?: IntFieldUpdateOperationsInput | number
    firstexchange?: IntFieldUpdateOperationsInput | number
    zhifubao?: StringFieldUpdateOperationsInput | string
    zhifubaoName?: StringFieldUpdateOperationsInput | string
  }

  export type UserinfoUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    Devid?: IntFieldUpdateOperationsInput | number
    firstexchange?: IntFieldUpdateOperationsInput | number
    zhifubao?: StringFieldUpdateOperationsInput | string
    zhifubaoName?: StringFieldUpdateOperationsInput | string
  }

  export type Userinfo_impCreateInput = {
    userId: number
    score: number
    diamond: number
    giftTicket: number
  }

  export type Userinfo_impUncheckedCreateInput = {
    userId: number
    score: number
    diamond: number
    giftTicket: number
  }

  export type Userinfo_impUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
  }

  export type Userinfo_impUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
  }

  export type Userinfo_impCreateManyInput = {
    userId: number
    score: number
    diamond: number
    giftTicket: number
  }

  export type Userinfo_impUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
  }

  export type Userinfo_impUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    diamond?: IntFieldUpdateOperationsInput | number
    giftTicket?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BankbindlistCountOrderByAggregateInput = {
    cardId?: SortOrder
    userId?: SortOrder
    account?: SortOrder
    name?: SortOrder
    bankType?: SortOrder
  }

  export type BankbindlistAvgOrderByAggregateInput = {
    cardId?: SortOrder
    userId?: SortOrder
  }

  export type BankbindlistMaxOrderByAggregateInput = {
    cardId?: SortOrder
    userId?: SortOrder
    account?: SortOrder
    name?: SortOrder
    bankType?: SortOrder
  }

  export type BankbindlistMinOrderByAggregateInput = {
    cardId?: SortOrder
    userId?: SortOrder
    account?: SortOrder
    name?: SortOrder
    bankType?: SortOrder
  }

  export type BankbindlistSumOrderByAggregateInput = {
    cardId?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BanknameCountOrderByAggregateInput = {
    typeId?: SortOrder
    bankName?: SortOrder
  }

  export type BanknameAvgOrderByAggregateInput = {
    typeId?: SortOrder
  }

  export type BanknameMaxOrderByAggregateInput = {
    typeId?: SortOrder
    bankName?: SortOrder
  }

  export type BanknameMinOrderByAggregateInput = {
    typeId?: SortOrder
    bankName?: SortOrder
  }

  export type BanknameSumOrderByAggregateInput = {
    typeId?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ChatlogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    nickname?: SortOrder
    msg?: SortOrder
    isSendEnd?: SortOrder
    addDate?: SortOrder
  }

  export type ChatlogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    isSendEnd?: SortOrder
  }

  export type ChatlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    nickname?: SortOrder
    msg?: SortOrder
    isSendEnd?: SortOrder
    addDate?: SortOrder
  }

  export type ChatlogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    nickname?: SortOrder
    msg?: SortOrder
    isSendEnd?: SortOrder
    addDate?: SortOrder
  }

  export type ChatlogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    toUserId?: SortOrder
    isSendEnd?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type Diamond_changelogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Diamond_changelogAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    isOnline?: SortOrder
  }

  export type Diamond_changelogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Diamond_changelogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Diamond_changelogSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    diamond_before?: SortOrder
    diamond_change?: SortOrder
    diamond_current?: SortOrder
    change_type?: SortOrder
    isOnline?: SortOrder
  }

  export type DongshanzaiqiCountOrderByAggregateInput = {
    userId?: SortOrder
    dcount?: SortOrder
    dtime?: SortOrder
  }

  export type DongshanzaiqiAvgOrderByAggregateInput = {
    userId?: SortOrder
    dcount?: SortOrder
  }

  export type DongshanzaiqiMaxOrderByAggregateInput = {
    userId?: SortOrder
    dcount?: SortOrder
    dtime?: SortOrder
  }

  export type DongshanzaiqiMinOrderByAggregateInput = {
    userId?: SortOrder
    dcount?: SortOrder
    dtime?: SortOrder
  }

  export type DongshanzaiqiSumOrderByAggregateInput = {
    userId?: SortOrder
    dcount?: SortOrder
  }

  export type Game_login_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type Game_login_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
  }

  export type Game_login_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type Game_login_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type Game_login_historySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    encoin?: SortOrder
    login_score?: SortOrder
    logout_score?: SortOrder
  }

  export type Game_onlinenumCountOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    gport?: SortOrder
    num?: SortOrder
    createtime?: SortOrder
  }

  export type Game_onlinenumAvgOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    num?: SortOrder
  }

  export type Game_onlinenumMaxOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    gport?: SortOrder
    num?: SortOrder
    createtime?: SortOrder
  }

  export type Game_onlinenumMinOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    gport?: SortOrder
    num?: SortOrder
    createtime?: SortOrder
  }

  export type Game_onlinenumSumOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    num?: SortOrder
  }

  export type LineoutCountOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type LineoutAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type LineoutMaxOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type LineoutMinOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type LineoutSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type Login_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginType?: SortOrder
    loginToken?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
    loginDate?: SortOrder
    loginIp?: SortOrder
  }

  export type Login_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
  }

  export type Login_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginType?: SortOrder
    loginToken?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
    loginDate?: SortOrder
    loginIp?: SortOrder
  }

  export type Login_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginType?: SortOrder
    loginToken?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
    loginDate?: SortOrder
    loginIp?: SortOrder
  }

  export type Login_historySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordToken?: SortOrder
    score?: SortOrder
  }

  export type LogintempCountOrderByAggregateInput = {
    id?: SortOrder
    loginid?: SortOrder
    logincode?: SortOrder
    loginDate?: SortOrder
  }

  export type LogintempAvgOrderByAggregateInput = {
    id?: SortOrder
    loginid?: SortOrder
  }

  export type LogintempMaxOrderByAggregateInput = {
    id?: SortOrder
    loginid?: SortOrder
    logincode?: SortOrder
    loginDate?: SortOrder
  }

  export type LogintempMinOrderByAggregateInput = {
    id?: SortOrder
    loginid?: SortOrder
    logincode?: SortOrder
    loginDate?: SortOrder
  }

  export type LogintempSumOrderByAggregateInput = {
    id?: SortOrder
    loginid?: SortOrder
  }

  export type Logout_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
    logoutDate?: SortOrder
    logoutIp?: SortOrder
  }

  export type Logout_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
  }

  export type Logout_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
    logoutDate?: SortOrder
    logoutIp?: SortOrder
  }

  export type Logout_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
    logoutDate?: SortOrder
    logoutIp?: SortOrder
  }

  export type Logout_historySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    logoutType?: SortOrder
    score?: SortOrder
  }

  export type MarkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    balanceTime?: SortOrder
    mark?: SortOrder
  }

  export type MarkAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    mark?: SortOrder
  }

  export type MarkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    balanceTime?: SortOrder
    mark?: SortOrder
  }

  export type MarkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    balanceTime?: SortOrder
    mark?: SortOrder
  }

  export type MarkSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    useCoin?: SortOrder
    winCoin?: SortOrder
    tax?: SortOrder
    gameId?: SortOrder
    serverId?: SortOrder
    mark?: SortOrder
  }

  export type MsgCountOrderByAggregateInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    AddDate?: SortOrder
    sendCoinUserId?: SortOrder
    nickName?: SortOrder
  }

  export type MsgAvgOrderByAggregateInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    sendCoinUserId?: SortOrder
  }

  export type MsgMaxOrderByAggregateInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    AddDate?: SortOrder
    sendCoinUserId?: SortOrder
    nickName?: SortOrder
  }

  export type MsgMinOrderByAggregateInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    AddDate?: SortOrder
    sendCoinUserId?: SortOrder
    nickName?: SortOrder
  }

  export type MsgSumOrderByAggregateInput = {
    msgId?: SortOrder
    userId?: SortOrder
    winPropId?: SortOrder
    winPropCount?: SortOrder
    winScore?: SortOrder
    matchlogId?: SortOrder
    isGetPrize?: SortOrder
    type?: SortOrder
    sendCoinUserId?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NewuseraccountsCountOrderByAggregateInput = {
    Id?: SortOrder
    Account?: SortOrder
    Password?: SortOrder
    nickname?: SortOrder
    score?: SortOrder
    AddDate?: SortOrder
    LoginCount?: SortOrder
    p?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    phoneNo?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    headimgurl?: SortOrder
    language?: SortOrder
    Robot?: SortOrder
    ChannelType?: SortOrder
    official?: SortOrder
    gametoken?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    loginip?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    diansha_gameids?: SortOrder
    is_vip?: SortOrder
    g4_uid?: SortOrder
    account_using?: SortOrder
    bankPwd?: SortOrder
    bankScore?: SortOrder
  }

  export type NewuseraccountsAvgOrderByAggregateInput = {
    Id?: SortOrder
    score?: SortOrder
    LoginCount?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    sex?: SortOrder
    Robot?: SortOrder
    official?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    is_vip?: SortOrder
    account_using?: SortOrder
    bankScore?: SortOrder
  }

  export type NewuseraccountsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Account?: SortOrder
    Password?: SortOrder
    nickname?: SortOrder
    score?: SortOrder
    AddDate?: SortOrder
    LoginCount?: SortOrder
    p?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    phoneNo?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    headimgurl?: SortOrder
    language?: SortOrder
    Robot?: SortOrder
    ChannelType?: SortOrder
    official?: SortOrder
    gametoken?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    loginip?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    diansha_gameids?: SortOrder
    is_vip?: SortOrder
    g4_uid?: SortOrder
    account_using?: SortOrder
    bankPwd?: SortOrder
    bankScore?: SortOrder
  }

  export type NewuseraccountsMinOrderByAggregateInput = {
    Id?: SortOrder
    Account?: SortOrder
    Password?: SortOrder
    nickname?: SortOrder
    score?: SortOrder
    AddDate?: SortOrder
    LoginCount?: SortOrder
    p?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    phoneNo?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    headimgurl?: SortOrder
    language?: SortOrder
    Robot?: SortOrder
    ChannelType?: SortOrder
    official?: SortOrder
    gametoken?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    loginip?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    diansha_gameids?: SortOrder
    is_vip?: SortOrder
    g4_uid?: SortOrder
    account_using?: SortOrder
    bankPwd?: SortOrder
    bankScore?: SortOrder
  }

  export type NewuseraccountsSumOrderByAggregateInput = {
    Id?: SortOrder
    score?: SortOrder
    LoginCount?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
    sex?: SortOrder
    Robot?: SortOrder
    official?: SortOrder
    qdid?: SortOrder
    housecard?: SortOrder
    totalRecharge?: SortOrder
    iscanlogin?: SortOrder
    diansha_score?: SortOrder
    is_vip?: SortOrder
    account_using?: SortOrder
    bankScore?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type PcdandanCountOrderByAggregateInput = {
    userId?: SortOrder
    pcdandanId?: SortOrder
    Devid?: SortOrder
  }

  export type PcdandanAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type PcdandanMaxOrderByAggregateInput = {
    userId?: SortOrder
    pcdandanId?: SortOrder
    Devid?: SortOrder
  }

  export type PcdandanMinOrderByAggregateInput = {
    userId?: SortOrder
    pcdandanId?: SortOrder
    Devid?: SortOrder
  }

  export type PcdandanSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type Prop_changelogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    insertTime?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_changelogAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_changelogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    insertTime?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_changelogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    insertTime?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_changelogSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    change_before?: SortOrder
    change_count?: SortOrder
    change_after?: SortOrder
    gameid?: SortOrder
    codeid?: SortOrder
  }

  export type Prop_itemCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type Prop_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type Prop_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type Prop_itemMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type Prop_itemSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    propid?: SortOrder
    propcount?: SortOrder
  }

  export type RechargeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    Account?: SortOrder
    total_fee?: SortOrder
    out_trade_no?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
    createTime?: SortOrder
  }

  export type RechargeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    total_fee?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
  }

  export type RechargeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    Account?: SortOrder
    total_fee?: SortOrder
    out_trade_no?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
    createTime?: SortOrder
  }

  export type RechargeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    Account?: SortOrder
    total_fee?: SortOrder
    out_trade_no?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
    createTime?: SortOrder
  }

  export type RechargeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    total_fee?: SortOrder
    goodsid?: SortOrder
    state?: SortOrder
  }

  export type Recharge_firstCountOrderByAggregateInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
    daytime?: SortOrder
  }

  export type Recharge_firstAvgOrderByAggregateInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
  }

  export type Recharge_firstMaxOrderByAggregateInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
    daytime?: SortOrder
  }

  export type Recharge_firstMinOrderByAggregateInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
    daytime?: SortOrder
  }

  export type Recharge_firstSumOrderByAggregateInput = {
    userId?: SortOrder
    FIRST?: SortOrder
    anyFirst?: SortOrder
    goods1?: SortOrder
    goods2?: SortOrder
    goods3?: SortOrder
    goods4?: SortOrder
    goods5?: SortOrder
  }

  export type RechargelogCountOrderByAggregateInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    createtime?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type RechargelogAvgOrderByAggregateInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type RechargelogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    createtime?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type RechargelogMinOrderByAggregateInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    createtime?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type RechargelogSumOrderByAggregateInput = {
    id?: SortOrder
    adminid?: SortOrder
    userid?: SortOrder
    czfee?: SortOrder
    oldfee?: SortOrder
    newfee?: SortOrder
    type?: SortOrder
  }

  export type ReturnscorelogCountOrderByAggregateInput = {
    id?: SortOrder
    msg?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type ReturnscorelogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReturnscorelogMaxOrderByAggregateInput = {
    id?: SortOrder
    msg?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type ReturnscorelogMinOrderByAggregateInput = {
    id?: SortOrder
    msg?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type ReturnscorelogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Score_changelogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type Score_changelogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Score_changelogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type Score_changelogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    ret?: SortOrder
    createtime?: SortOrder
  }

  export type Score_changelogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type ScoreoutCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    addDate?: SortOrder
    state?: SortOrder
    outDate?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
    out_trade_no?: SortOrder
    zfb_account?: SortOrder
    zfb_name?: SortOrder
    remark?: SortOrder
  }

  export type ScoreoutAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
  }

  export type ScoreoutMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    addDate?: SortOrder
    state?: SortOrder
    outDate?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
    out_trade_no?: SortOrder
    zfb_account?: SortOrder
    zfb_name?: SortOrder
    remark?: SortOrder
  }

  export type ScoreoutMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    addDate?: SortOrder
    state?: SortOrder
    outDate?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
    out_trade_no?: SortOrder
    zfb_account?: SortOrder
    zfb_name?: SortOrder
    remark?: SortOrder
  }

  export type ScoreoutSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    coin?: SortOrder
    tax?: SortOrder
    cardType?: SortOrder
    cardId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type SendcoinlogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
    addtime?: SortOrder
  }

  export type SendcoinlogAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
  }

  export type SendcoinlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
    addtime?: SortOrder
  }

  export type SendcoinlogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
    addtime?: SortOrder
  }

  export type SendcoinlogSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    getcoinuserid?: SortOrder
    sendcoin?: SortOrder
  }

  export type Server_logCountOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
    status?: SortOrder
    createtime?: SortOrder
    updatetime?: SortOrder
  }

  export type Server_logAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type Server_logMaxOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
    status?: SortOrder
    createtime?: SortOrder
    updatetime?: SortOrder
  }

  export type Server_logMinOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
    status?: SortOrder
    createtime?: SortOrder
    updatetime?: SortOrder
  }

  export type Server_logSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type TempadddiamondCountOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempadddiamondAvgOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempadddiamondMaxOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempadddiamondMinOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempadddiamondSumOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreCountOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreAvgOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreMaxOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreMinOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type TempaddscoreSumOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    change_type?: SortOrder
  }

  export type Ticket_changelogCountOrderByAggregateInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Ticket_changelogAvgOrderByAggregateInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    isOnline?: SortOrder
  }

  export type Ticket_changelogMaxOrderByAggregateInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Ticket_changelogMinOrderByAggregateInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    change_time?: SortOrder
    isOnline?: SortOrder
  }

  export type Ticket_changelogSumOrderByAggregateInput = {
    userid?: SortOrder
    score_before?: SortOrder
    score_change?: SortOrder
    score_current?: SortOrder
    change_type?: SortOrder
    isOnline?: SortOrder
  }

  export type User_adminCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    userflag?: SortOrder
  }

  export type User_adminAvgOrderByAggregateInput = {
    id?: SortOrder
    userflag?: SortOrder
  }

  export type User_adminMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    userflag?: SortOrder
  }

  export type User_adminMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    userflag?: SortOrder
  }

  export type User_adminSumOrderByAggregateInput = {
    id?: SortOrder
    userflag?: SortOrder
  }

  export type UserinfoCountOrderByAggregateInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
    zhifubao?: SortOrder
    zhifubaoName?: SortOrder
  }

  export type UserinfoAvgOrderByAggregateInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
  }

  export type UserinfoMaxOrderByAggregateInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
    zhifubao?: SortOrder
    zhifubaoName?: SortOrder
  }

  export type UserinfoMinOrderByAggregateInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
    zhifubao?: SortOrder
    zhifubaoName?: SortOrder
  }

  export type UserinfoSumOrderByAggregateInput = {
    userId?: SortOrder
    Devid?: SortOrder
    firstexchange?: SortOrder
  }

  export type Userinfo_impCountOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type Userinfo_impAvgOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type Userinfo_impMaxOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type Userinfo_impMinOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type Userinfo_impSumOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    diamond?: SortOrder
    giftTicket?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}